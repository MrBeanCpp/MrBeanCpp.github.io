

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="MrBeanC">
  <meta name="keywords" content="">
  
    <meta name="description" content="extern &amp; __declspec(dllimport) 杂谈">
<meta property="og:type" content="article">
<meta property="og:title" content="extern vs __declspec(dllimport)">
<meta property="og:url" content="https://mrbeancpp.github.io/2024/12/25/extern-vs-declspec-dllimport/index.html">
<meta property="og:site_name" content="MrBeanC-Blog">
<meta property="og:description" content="extern &amp; __declspec(dllimport) 杂谈">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-25T14:35:04.000Z">
<meta property="article:modified_time" content="2024-12-29T09:13:21.757Z">
<meta property="article:author" content="MrBeanC">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="dll">
<meta property="article:tag" content="lib">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>extern vs __declspec(dllimport) - MrBeanC-Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"mrbeancpp.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>MrBeanC</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="extern vs __declspec(dllimport)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        MrBeanC
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-25 22:35" pubdate>
          2024年12月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          110 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">extern vs __declspec(dllimport)</h1>
            
              <p class="note note-info">
                
                  
                    <!-- compatible with older versions-->
                    本文最后更新于：2024年12月29日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>C/C++</code>中<code>extern</code>表明<strong>外部链接</strong>，说…说明可以在多个文件共享巴拉…的（小声）</p>
<p>记者：那外部链接是什么意思，与之相对的是什么关键字？</p>
<p>记者：<code>extern</code>用于声明还是定义？</p>
<p>记者：对于函数、变量、类以及<code>dll</code>分别有什么作用？</p>
<p>：别说了别说了（小声）</p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><blockquote>
<p>该关键字意味着：<strong>外部链接（External Linkage）</strong>，具有 <strong>外部链接</strong> 的符号是可以在<strong>多个</strong>源文件中访问的。也就是说，这些符号在程序中是<strong>全局可见</strong>的，可以在一个源文件中定义，在其他源文件中<strong>引用</strong>。通过链接器，程序的多个源文件可以<strong>共享</strong>这些符号</p>
</blockquote>
<p>当编译器看到一个外部链接的符号（如函数或全局变量）时，它会知道该符号在当前翻译单元（<code>.cpp</code>文件）中<strong>没有定义</strong>，但不会立即报错</p>
<p>而是将该符号的引用<strong>推迟到链接阶段</strong>，链接器负责在链接时查找<strong>其他</strong>翻译单元中的定义，并将这些引用<strong>解析为实际的地址</strong></p>
<blockquote>
<p>注意：如果链接器在链接时找不到外部链接符号的定义，通常会报错（如 <strong>LNK1120</strong> 错误，”无法解析外部符号”）</p>
</blockquote>
<p>例如：</p>
<p><strong>a.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>b.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大家可能会奇怪：诶，怎么没有<code>.h</code>头文件也可以使用其他文件定义的函数了</p>
<p>别急，听我细嗦</p>
<h3 id="默认可见性"><a href="#默认可见性" class="headerlink" title="默认可见性"></a>默认可见性</h3><p>其实，函数和全局变量默认就是<strong>外部链接</strong>的，所以一定程度上，<code>extern</code>是可以省略的</p>
<p>为什么是一定程度呢，这个有点子复杂</p>
<h3 id="extern-用于声明还是定义"><a href="#extern-用于声明还是定义" class="headerlink" title="extern 用于声明还是定义"></a>extern 用于声明还是定义</h3><p>这确实是个值得商榷的问题，从<strong>外部链接</strong>的作用来看，是为了在使用时可以不去寻找定义，那么用在<strong>声明</strong>是最合理的：<code>extern int func();</code></p>
<p>不过其实<strong>定义</strong>也可以加，但是没什么用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> var = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="什么是声明，什么是定义"><a href="#什么是声明，什么是定义" class="headerlink" title="什么是声明，什么是定义"></a>什么是声明，什么是定义</h3><p>是不是有同学笑了一下（盯——）</p>
<p>这个问题对于函数没有什么异议，有花括号（函数体）就是定义</p>
<p>那么变量呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>其实只有<code>extern int x;</code>是声明，其余都是定义</p>
<p><code>int x;</code>虽然没有显式初始化，但是作为全局变量，默认初始化为0；</p>
<p>其实对于变量来说，定义意味着<strong>分配存储空间</strong>，而<code>extern</code>意味着<strong>在别处定义</strong></p>
<p>所以有显示初始化的一定是定义（分配空间），而有<code>extern</code>且无初始化的才是<strong>纯声明</strong></p>
<p>所以刚刚说：“一定程度上，<code>extern</code>是可以省略的”，指的是：</p>
<ul>
<li>函数、全局变量定义时的<code>extern</code>可以省略（默认外部可见）</li>
<li>在另一个文件声明时，函数的<code>extern</code>可以省略，变量不能（否则变成了定义）（😾）</li>
</ul>
<p><strong>a.cpp</strong>（声明）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> var; <span class="hljs-comment">// 不能省略extern，否则触发&quot;重定义&quot;错误</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 可以省略extern</span><br></code></pre></td></tr></table></figure>

<p><strong>b.cpp</strong>（定义）（可以省略<code>extern</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> var = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>谨记：声明可以多次，定义只能一次</em></p>
<h3 id="include-头文件的本质（😾）"><a href="#include-头文件的本质（😾）" class="headerlink" title="#include 头文件的本质（😾）"></a>#include 头文件的本质（😾）</h3><p><code>#include</code> 的本质其实是文本替换：</p>
<p>当预处理器处理到<code>#include</code> 指令时，它会将这一行替换为头文件的全部内容，其实就是<strong>复制</strong>了一份<code>.h</code>到<code>.cpp</code>中，但是可以少写点重复代码（预处理器帮忙复制）</p>
<p>例如，我们平时最常见的写法是这样的：</p>
<p><strong>test.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>test.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其本质上就是：</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 拷贝了 test.h 中的内容</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是不是看出了什么端倪，这不就是上述<strong>a.cpp</strong>省略<code>extern</code>的函数声明嘛（抖包袱）</p>
<p>所以我们平时一直在利用函数默认是<strong>外部链接</strong>这个特性，而不自知</p>
<h4 id="那么代价是什么"><a href="#那么代价是什么" class="headerlink" title="那么代价是什么"></a>那么代价是什么</h4><p>由于 <code>#include</code>是无脑复制，所以就很容易出现<strong>重定义</strong>问题（复制了太多份定义）</p>
<p>这时候有同学要说了，怎么可能，谁会 <code>#include</code>多个一样的头文件啊</p>
<p>直接包含可能不太可能，那么间接包含呢？</p>
<p>可能<code>#include &quot;b.h&quot;</code>，而<code>b.h</code>中<code>#include &quot;a.h&quot;</code></p>
<p>这种情况就很难发现了，但是最终都会复制展开到一个翻译单元（.cpp）中，造成重复定义错误</p>
<p>肿么办</p>
<h4 id="一般有两种解决方案："><a href="#一般有两种解决方案：" class="headerlink" title="一般有两种解决方案："></a>一般有两种解决方案：</h4><ol>
<li>宏定义法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> A_H <span class="hljs-comment">// 注意宏不要太短，防止冲突</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A_H</span><br><br><span class="hljs-comment">// 头文件内容</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// A_H</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li>第一次包含 <code>a.h</code> 时，<code>#ifndef A_H</code> 判断条件为 <code>false</code>，因此定义了 <code>A_H</code>，并开始包含文件内容</li>
<li>第二次再包含 <code>a.h</code> 时，<code>#ifndef A_H</code> 条件为 <code>true</code>，直接跳过，从而避免了重复定义</li>
</ul>
<ol start="2">
<li><code>#pragma once</code>（编译器指令）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-comment">// 头文件内容</span><br></code></pre></td></tr></table></figure>

<p><code>#pragma once</code>更简洁，也是更现代的做法，支持的编译器很多，但某些老旧的编译器（或者特定的工具链）可能不支持</p>
<p>所以如果考虑<strong>兼容性</strong>的话，可以采用第一种做法（貌似<code>Clion</code>默认生成的是第一种）</p>
<h2 id="declspec-dllimport"><a href="#declspec-dllimport" class="headerlink" title="__declspec(dllimport)"></a>__declspec(dllimport)</h2><p><code>__declspec</code>实际上是微软对于<code>C/C++</code>的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2284610/what-is-declspec-and-when-do-i-need-to-use-it">特定拓展</a>，并不是语言本身的标准，只在<code>Windows</code>平台使用</p>
<p>&#x2F;&#x2F; 更搞的是，甚至还有<code>_declspec</code>（单下划线版本），其实是同义词，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1399215/difference-between-declspec-and-declspec">为了兼容旧版编译器</a></p>
<p>显然，从名字来看，<code>__declspec(dllimport)</code>是用于从<code>dll</code>中导入符号（函数、变量等），与之相对应的是<code>__declspec(dllexport)</code>，用于导出</p>
<p>所以很多同学可能没有接触过，因为只在编写<code>dll</code>(Dynamic-Link Library)库时需要用到</p>
<p>太抽象了，多说无益，还是 <strong>Show me the code</strong> 吧</p>
<p>一般用<code>Visual Studio</code>来编写（新建<code>dll</code>工程就有模板）ref : <a target="_blank" rel="noopener" href="https://blog.cls.ink/2022/04/07/Windows-Hook-%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/#%E5%AE%9E%E6%93%8D2%EF%BC%9A%E9%BC%A0%E6%A0%87%E9%92%A9%E5%AD%90%EF%BC%88dll%EF%BC%89">Windows Hook 技术浅析 - MrBeanC-Blog</a></p>
<p><strong>dllmain.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>只有被<code>__declspec(dllexport)</code>标记的符号才会被导出（这和<code>linux</code>的<code>.so</code>(Shared Object file)正好相反，<code>.so</code>是默认导出所有符号）</p>
<p>直接编译（生成解决方案）就可以得到产物：<code>test.dll</code> <code>test.lib</code></p>
<h3 id="dll-amp-lib"><a href="#dll-amp-lib" class="headerlink" title=".dll &amp; .lib"></a>.dll &amp; .lib</h3><p>为什么<code>Windows</code>下的动态库有两个文件构成，而<code>Linux</code>只有一个<code>.so</code>呢</p>
<p>这个说起来就比较复杂了</p>
<h4 id="lib"><a href="#lib" class="headerlink" title=".lib"></a>.lib</h4><p><code>.lib</code>实际上有两种用途</p>
<ul>
<li>静态库（Static Library）：包含所有代码实现，直接编译到可执行文件中</li>
<li>导入库（Import Library）：此时需要和<code>dll</code>配合使用，此时的<code>.lib</code>文件内并不包含具体的代码实现，而是一个<strong>符号表</strong>，用于让静态链接器知道如何连接到<code>dll</code>中的符号，起到中介的作用</li>
</ul>
<blockquote>
<p>没有简单的方法可以区分它们，除了作为 dll 导入库的 lib 通常比匹配的静态 lib 小（通常小得多）<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic-link_library#Import_libraries">Dynamic-link library - Wikipedia</a></p>
</blockquote>
<p>试想一下，我们如何使用刚刚编译出来的<code>dll</code>库，也许是这样：</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_cpp</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看起来很合理对吧，但是在运行时，程序怎么知道<code>test_cpp</code>函数在哪个<code>dll</code>文件的哪个位置（偏移量）呢？</p>
<p>所以虽然编译能过，但是<strong>链接</strong>阶段会直接报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.cpp.obj : error LNK2019: 无法解析的外部符号 <span class="hljs-string">&quot;int __cdecl test_cpp(int)&quot;</span> (?test_cpp@@YAHH@Z)，函数 main 中引用了该符号<br></code></pre></td></tr></table></figure>

<p>因为链接器根本不知道去哪里找这个函数</p>
<p>这不纯纯抓瞎嘛，只要代入机器视角就能发现端倪了</p>
<h4 id="dll-only"><a href="#dll-only" class="headerlink" title=".dll only"></a>.dll only</h4><p>我们先来看看假如只有<code>.dll</code>的情况下，应该如何使用其中的函数吧</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(* pfnTestC)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 定义函数指针类型</span><br>    HMODULE hMouse = <span class="hljs-built_in">LoadLibrary</span>(<span class="hljs-string">&quot;mouseHook.dll&quot;</span>); <span class="hljs-comment">// 加载dll (Only once for each process)</span><br>    <span class="hljs-keyword">if</span> (hMouse) &#123;<br>        <span class="hljs-keyword">auto</span> testC = (pfnTestC) <span class="hljs-built_in">GetProcAddress</span>(hMouse, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// 获取test函数在dll中的地址</span><br>        <span class="hljs-keyword">if</span> (testC)<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;dynamic load: &quot;</span> &lt;&lt; <span class="hljs-built_in">testC</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样应该能比较清晰地看明白调用一个<code>dll</code>中函数的过程</p>
<ol>
<li>加载<code>dll</code>进内存（同一个<code>dll</code>只会加载一份）</li>
<li>获取函数在<code>dll</code>中的地址（指针）</li>
<li>将地址转换为对应的函数指针就可以调用了</li>
</ol>
<p>这种方法不需要依赖<code>.h</code>和<code>.lib</code>，但是调用起来稍微复杂一点</p>
<p>通常，这种方式被称为：<strong>显式链接</strong>（<em>Explicit linking</em>），或 <em>dynamic load</em> or <em>run-time dynamic linking</em></p>
<p>一般用在插件系统（运行时加载新插件，而无需重新编译和分发主程序）或者未公开API</p>
<p>例如：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/dwm/setwindowcompositionattribute">SetWindowCompositionAttribute</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWindowBlur</span><span class="hljs-params">(HWND hWnd)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">BOOL</span><span class="hljs-params">(WINAPI* pfnSetWindowCompositionAttribute)</span><span class="hljs-params">(HWND, WINDOWCOMPOSITIONATTRIBDATA*)</span></span>;<br>    <br>    HMODULE hUser = <span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-string">L&quot;user32.dll&quot;</span>); <span class="hljs-comment">// 在确定dll已经被加载的情况下，可以用 GetModuleHandle 替代 LoadLibrary</span><br>    <span class="hljs-keyword">if</span> (hUser) &#123;<br>        <span class="hljs-keyword">auto</span> setWindowCompositionAttribute = (pfnSetWindowCompositionAttribute) <span class="hljs-built_in">GetProcAddress</span>(hUser, <span class="hljs-string">&quot;SetWindowCompositionAttribute&quot;</span>);<br>        <span class="hljs-keyword">if</span> (setWindowCompositionAttribute) &#123;<br>            ACCENT_POLICY accent = &#123;ACCENT_ENABLE_BLURBEHIND, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            WINDOWCOMPOSITIONATTRIBDATA data;<br>            data.Attrib = WCA_ACCENT_POLICY;<br>            data.pvData = &amp;accent;<br>            data.cbData = <span class="hljs-built_in">sizeof</span>(accent);<br>            <span class="hljs-built_in">setWindowCompositionAttribute</span>(hWnd, &amp;data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数可以为窗口实现毛玻璃效果，但是可能由于性能原因，并没有公开</p>
<blockquote>
<p>微软文档：<br><strong>该函数没有关联的导入库或头文件；您必须使用</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a><strong>和</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress"><strong>GetProcAddress</strong></a><strong>函数来调用它。该 API 是从 user32.dll 导出的</strong></p>
</blockquote>
<h3 id="Why-extern-“C”"><a href="#Why-extern-“C”" class="headerlink" title="Why extern “C”"></a>Why extern “C”</h3><p>相信大家已经注意到了，刚刚是通过<code>GetProcAddress(hMouse, &quot;test&quot;)</code>函数获取函数地址的</p>
<p>但是为什么”test”就能定位到<code>test</code>函数呢（虽然听起来有点脱裤子放屁）</p>
<p>但是你仔细想想，<code>C++</code>的函数签名真的是可以通过<strong>函数名</strong>唯一确定吗？视重载为何物</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">float</span> a)</span></span>;<br></code></pre></td></tr></table></figure>

<p>所以，其实上文的<code>test</code>函数其实并不是以<code>C++</code>函数的形式导出的</p>
<p><strong>dllmain.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;<br>&#125;<br><br>__declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>没错，和<code>test_cpp</code>相比，<code>test</code>函数多了<code>extern &quot;C&quot;</code></p>
<h4 id="Name-Mangling"><a href="#Name-Mangling" class="headerlink" title="Name Mangling"></a>Name Mangling</h4><p><code>extern &quot;C&quot;</code>意味着把<code>test</code>作为一个<code>C</code>函数进行导出，不要进行名称修饰（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Name_mangling">Name Mangling</a>）</p>
<p>ref: <a target="_blank" rel="noopener" href="https://coderslegacy.com/c/extern-c-in-cpp/">How to use extern “C” in C++ - CodersLegacy</a></p>
<p>简单来说，名称修饰是由于<code>C++</code>函数存在<strong>重载</strong>，所以函数名具有<strong>二义性</strong>，需要在符号中加入其他信息来区分彼此</p>
<p>我们可以使用<code>VS</code>自带的<code>dumpbin.exe</code>工具来查看<code>dll</code>中的符号</p>
<p>&#x2F;&#x2F; 路径可能是：<code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\bin\Hostx86\x86\dumpbin.exe</code></p>
<p>&#x2F;&#x2F; 打开<code>Developer Command Prompt for VS 2022</code>可以自动加载到环境变量</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">// Developer Command Prompt <span class="hljs-keyword">for</span> VS <span class="hljs-number">2022</span><br>dumpbin /exports mouseHook.dll<br><br>ordinal hint RVA      name<br>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span> <span class="hljs-number">000112</span>F3 ?test_cpp<span class="hljs-selector-tag">@</span>@YAHH@Z = @ILT+<span class="hljs-number">750</span>(?test_cpp<span class="hljs-selector-tag">@</span>@YAHH@Z)<br>    <span class="hljs-number">2</span>    <span class="hljs-number">1</span> <span class="hljs-number">000112</span>D5 ?test_macro<span class="hljs-selector-tag">@</span>@YAHH@Z = @ILT+<span class="hljs-number">720</span>(?test_macro<span class="hljs-selector-tag">@</span>@YAHH@Z)<br>    <span class="hljs-number">3</span>    <span class="hljs-number">2</span> <span class="hljs-number">0001</span>D000 ?test_var<span class="hljs-selector-tag">@</span>@<span class="hljs-number">3</span>HA = ?test_var<span class="hljs-selector-tag">@</span>@<span class="hljs-number">3</span>HA (int test_var)<br>    <span class="hljs-number">4</span>    <span class="hljs-number">3</span> <span class="hljs-number">000112</span>F8 clearHook = @ILT+<span class="hljs-number">755</span>(clearHook)<br>    <span class="hljs-number">5</span>    <span class="hljs-number">4</span> <span class="hljs-number">000110</span>C3 setMouseHook = @ILT+<span class="hljs-number">190</span>(setMouseHook)<br>    <span class="hljs-number">6</span>    <span class="hljs-number">5</span> <span class="hljs-number">0001114</span>A test = @ILT+<span class="hljs-number">325</span>(test)<br></code></pre></td></tr></table></figure>

<p>比如上述<code>test_cpp</code>函数在<code>dll</code>中表示为：<code>?test_cpp@@YAHH@Z</code>，而不是<code>test_cpp</code></p>
<ul>
<li>以<code>?</code>标识函数名的开始，后跟函数名，函数名后面以<code>@@YA</code>（对于<code>__cdecl</code>调用方式）标识参数表的开始，后跟参数表</li>
<li><code>H</code>代表<code>int</code>，<code>D--char</code>，<code>X--void</code>等等</li>
<li>第一个<code>H</code>代表返回值，第二个<code>H</code>代表参数</li>
<li>最后的<code>@Z</code>标记参数表结尾</li>
</ul>
<p>ref: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/yxysuanfa/p/6984895.html">C++ 编译器的函数名修饰规则 - yxysuanfa - 博客园</a></p>
<p>所以我们可以这样获取一个<code>C++</code>函数地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">GetProcAddress</span>(hMouse, <span class="hljs-string">&quot;?test_cpp@@YAHH@Z&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>看起来有点鬼畜，但是没办法</p>
<p>使用<code>extern &quot;C&quot;</code>可以避免进行名称修饰，让<code>dll</code>函数调用简单很多</p>
<p>当然，简单并不是最关键的理由</p>
<ol>
<li><p>这样可以兼容C程序</p>
</li>
<li><p>可以跨编译器调用<code>dll</code></p>
<p>因为不同编译器的名称修饰规则不同，例如<code>MinGW</code>是以<code>_Z</code>开头，而<code>MSVC</code>是以<code>?</code>开头，所以无法互相识别</p>
</li>
</ol>
<p>要注意一个显而易见的道理，使用<code>extern &quot;C&quot;</code>之后会被视为<code>C</code>函数，所以函数重载不可用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C2733 “<span class="hljs-built_in">test</span>”: 无法重载具有外部 <span class="hljs-string">&quot;C&quot;</span> 链接的函数<br></code></pre></td></tr></table></figure>

<p>当然，如果只是为了自己使用，或者条件允许（相同编译器）的情况下，可以不使用<code>extern &quot;C&quot;</code>，例如：<code>Qt</code></p>
<h3 id="dll-with-lib"><a href="#dll-with-lib" class="headerlink" title=".dll with .lib"></a>.dll with .lib</h3><p>好的，通过上述的例子，我们已经知道了直接调用裸<code>dll</code>中函数的复杂性</p>
<p>不仅要考虑<code>dll</code>的加载释放，还要考虑修饰后的不可读名称，晕头转向</p>
<p>此时就轮到<code>.lib</code>出场了</p>
<p>本质上，<code>.lib</code>文件就是一个中介，帮助程序找到函数所在<code>dll</code>和地址</p>
<p>无非就是这两行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">LoadLibrary</span>(<span class="hljs-string">&quot;mouseHook.dll&quot;</span>);<br><span class="hljs-built_in">GetProcAddress</span>(hMouse, <span class="hljs-string">&quot;?test_cpp@@YAHH@Z&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>用<code>dumpbin /all</code>命令查看<code>.lib</code>文件内部保存的详细符号信息</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmd">dumpbin /all mouseHook.lib<br><br>Archive member name <span class="hljs-built_in">at</span> <span class="hljs-number">7</span>E0: mouseHook.dll/<br>...<br><br>  Version      : <span class="hljs-number">0</span><br>  Machine      : <span class="hljs-number">8664</span> (x64)<br><span class="hljs-function">  TimeDateStamp: <span class="hljs-title">FB36C7D7</span></span><br><span class="hljs-function">  <span class="hljs-title">SizeOfData</span>   : 00000020</span><br><span class="hljs-function">  <span class="hljs-title">DLL</span> <span class="hljs-title">name</span>     : <span class="hljs-title">mouseHook.dll</span></span><br><span class="hljs-function">  <span class="hljs-title">Symbol</span> <span class="hljs-title">name</span>  : ?<span class="hljs-title">test_cpp</span>@@<span class="hljs-title">YAHH</span>@<span class="hljs-title">Z</span> (<span class="hljs-title">int</span> <span class="hljs-title">__cdecl</span> <span class="hljs-title">test_cpp</span>(<span class="hljs-title">int</span>))</span><br><span class="hljs-function">  <span class="hljs-title">Type</span>         : <span class="hljs-title">code</span></span><br><span class="hljs-function">  <span class="hljs-title">Name</span> <span class="hljs-title">type</span>    : <span class="hljs-title">name</span></span><br><span class="hljs-function">  <span class="hljs-title">Hint</span>         : 0</span><br><span class="hljs-function">  <span class="hljs-title">Name</span>         : ?<span class="hljs-title">test_cpp</span>@@<span class="hljs-title">YAHH</span>@<span class="hljs-title">Z</span></span><br><span class="hljs-function">...</span><br></code></pre></td></tr></table></figure>

<p>有了这些信息，就可以大大简化我们对<code>.dll</code>的使用</p>
<h4 id="use-lib"><a href="#use-lib" class="headerlink" title="use .lib"></a>use .lib</h4><p>使用<code>.lib</code>也很简单</p>
<ol>
<li>对于<code>MSVC</code>编译器，加上一行编译器指令即可</li>
</ol>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;E:\\Projects\\cpp\\tests\\dllimport\\mouseHook.lib&quot;</span>) <span class="hljs-comment">// 如果是系统库 一般只需要相对路径</span></span><br>__declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_cpp</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>对于<code>cmake</code>，更加通用的做法是：</li>
</ol>
<p><strong>CMakeLists.txt</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/mouseHook.lib)<br></code></pre></td></tr></table></figure>

<p>如此一来，链接器在根据<code>int test_cpp(int a)</code>得到符号<code>?test_cpp@@YAHH@Z</code>后</p>
<p>就能通过<code>.lib</code>找到对应的<code>dll</code>名称<code>mouseHook.dll</code>，以及相应的函数地址了</p>
<p>在程序<strong>启动时</strong>，会自动寻找对应的<code>dll</code>并加载</p>
<p>这被称为：<strong>隐式链接</strong>（<em>Implicit linking</em>），或 <em>static load</em> or <em>load-time dynamic linking</em></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll?view=msvc-170&redirectedfrom=MSDN#:~:text=%E8%BF%9B%E7%A8%8B%E4%B8%8D%E4%BC%9A%E7%BB%88%E6%AD%A2%E3%80%82-,An%20application,-that%20implicitly%20links">微软文档</a></p>
<p>隐式链接到许多 DLL 的应用程序启动速度可能会很慢，因为 Windows 在加载应用程序时会加载所有 DLL<br>为了提高启动性能，应用程序可能只对加载后立即需要的 DLL 使用隐式链接。它可能仅在需要时使用显式链接来加载其他 DLL</p>
</blockquote>
<h4 id="默认库"><a href="#默认库" class="headerlink" title="默认库"></a>默认库</h4><p>其实，我们调用<code>Windows API</code>时调用的就是动态库，但是为什么好像一般不需要指定<code>.lib</code>呢</p>
<p>这是因为编译器帮我们链接了常用的系统默认库</p>
<p>在<code>Visual Studio</code>，“配置属性”&gt;“链接器”&gt;“命令行”属性页中可以看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;kernel32.lib&quot;</span> <span class="hljs-string">&quot;user32.lib&quot;</span> <span class="hljs-string">&quot;gdi32.lib&quot;</span> <span class="hljs-string">&quot;winspool.lib&quot;</span> <span class="hljs-string">&quot;comdlg32.lib&quot;</span> <span class="hljs-string">&quot;advapi32.lib&quot;</span> <span class="hljs-string">&quot;shell32.lib&quot;</span> <span class="hljs-string">&quot;ole32.lib&quot;</span> <span class="hljs-string">&quot;oleaut32.lib&quot;</span> <span class="hljs-string">&quot;uuid.lib&quot;</span> <span class="hljs-string">&quot;odbc32.lib&quot;</span> <span class="hljs-string">&quot;odbccp32.lib&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="dll-搜索目录"><a href="#dll-搜索目录" class="headerlink" title="dll 搜索目录"></a>dll 搜索目录</h4><p>ref: <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN">Dynamic-link library search order - Win32 apps | Microsoft Learn</a></p>
<p>那么程序启动后会在哪里搜索<code>dll</code>呢</p>
<p>文档看起来有点复杂，不过一般来说，只需要考虑：</p>
<ul>
<li><code>exe</code>所在目录</li>
<li>系统文件夹</li>
<li>当前目录</li>
<li><code>PATH</code>环境变量</li>
</ul>
<h3 id="dll-统一头文件"><a href="#dll-统一头文件" class="headerlink" title="dll - 统一头文件"></a>dll - 统一头文件</h3><p>我们都知道，<code>Qt</code>基本上是动态链接的</p>
<p>但是平时是不是没有特别在意过这个事实</p>
<p>我指的是，使用起来相当无缝，以至于并不需要在意是动态&#x2F;静态库</p>
<p>为什么呢，为什么<code>Qt</code>可以有这样的体验？</p>
<p>问题还是出在头文件上，我们之前提到了<code>.lib</code> <code>.dll</code>，唯独没有提到<code>.h</code></p>
<h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><p>对于<code>QString qt_error_string(int code)</code>函数，我并不需显式地<code>__declspec(dllimport)</code>或者<code>extern</code></p>
<p>只需要<code>#include&lt;qlogging.h&gt;</code>或者<code>#include&lt;QDebug&gt;</code>即可使用该函数</p>
<p><strong>qlogging.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Q_CORE_EXPORT QString <span class="hljs-title">qt_error_string</span><span class="hljs-params">(<span class="hljs-type">int</span> errorCode = <span class="hljs-number">-1</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>qsystemerror.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;xx.h&gt;</span></span><br><span class="hljs-function">QString <span class="hljs-title">qt_error_string</span><span class="hljs-params">(<span class="hljs-type">int</span> code)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">windowsErrorString</span>(code == <span class="hljs-number">-1</span> ? <span class="hljs-built_in">GetLastError</span>() : code);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>玄机就在<code>Q_CORE_EXPORT</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#  <span class="hljs-keyword">define</span> Q_DECL_EXPORT __declspec(dllexport)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> Q_DECL_IMPORT __declspec(dllimport)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(QT_SHARED) || !defined(QT_STATIC)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> defined(QT_BUILD_CORE_LIB)</span><br><span class="hljs-meta">#    <span class="hljs-keyword">define</span> Q_CORE_EXPORT Q_DECL_EXPORT</span><br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#    <span class="hljs-keyword">define</span> Q_CORE_EXPORT Q_DECL_IMPORT</span><br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> Q_CORE_EXPORT</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>如果定义了<code>QT_BUILD_CORE_LIB</code>，<code>Q_CORE_EXPORT</code>就是<code>__declspec(dllexport)</code>，否则为<code>__declspec(dllimport)</code></p>
<p>既然导入导出的声明代码是类似的，就可以通过宏开关的方式实现复用，妙哉</p>
<h5 id="编译-dll"><a href="#编译-dll" class="headerlink" title="编译 dll"></a>编译 dll</h5><p>我们唯一要做的就是在编译<code>dll</code>时启动这个宏<code>QT_BUILD_CORE_LIB</code></p>
<p>例如在<code>CMakelists.txt</code>中开启这个宏，或者直接在<code>.cpp</code>文件中<code>#define</code></p>
<p><strong>dll.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BUILDING_DLL)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> API_EXPORT __declspec(dllexport)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> API_EXPORT __declspec(dllimport)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function">API_EXPORT <span class="hljs-type">int</span> <span class="hljs-title">test_macro</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure>

<p><strong>dllmain.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUILDING_DLL</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dll.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_macro</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(a, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="使用-dll"><a href="#使用-dll" class="headerlink" title="使用 dll"></a>使用 dll</h5><p>然后，在客户端使用<code>dll</code>时，也就可以复用同一套<code>.h</code>进行<code>dllimport</code>了，perfect</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;E:\\Projects\\cpp\\tests\\dllimport\\mouseHook.lib&quot;</span>) <span class="hljs-comment">// 推荐 CMakeLists.txt 统一控制</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dll.h&quot;</span> <span class="hljs-comment">// 本质是拷贝</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_macro</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时<code>API_EXPORT</code>会自动变成<code>__declspec(dllimport)</code>，进行导入，十分无感</p>
<p>甚至都不需要手动写什么函数声明了😄</p>
<h3 id="Why-dll"><a href="#Why-dll" class="headerlink" title="Why dll"></a>Why dll</h3><p>说了这么多，话说我们到底为什么要用<code>dll</code>呢？</p>
<p>如果不是使用<code>dll</code>动态库，其实我们就只剩下了两种选择：<code>.lib</code>静态库 &amp; 拷贝源码</p>
<h4 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h4><p>静态库会在编译链接时被打包进最终的可执行文件中，运行时不再依赖额外的<code>dll</code>文件，更方便</p>
<p>但带来的是<code>exe</code>文件体积膨胀，启动速度变慢，以及代码复用性变差等问题</p>
<p>同时，如果想要升级外部库代码，就必须重新编译链接，不便于软件升级</p>
<blockquote>
<p><code>Qt</code>貌似不太允许静态编译，因为这样就隐藏了<code>Qt</code>的文件标识，属于白嫖行为</p>
</blockquote>
<h4 id="2-源码"><a href="#2-源码" class="headerlink" title="2.源码"></a>2.源码</h4><p>如果你既不想用静态库，又不想用动态库，那么你只能拷贝第三方库源代码了对吧</p>
<p>这个，很难评😄</p>
<h4 id="dll-的优势"><a href="#dll-的优势" class="headerlink" title="dll 的优势"></a>dll 的优势</h4><p>Okay，那么最后再总结一下<code>dll</code>的优点，坚定一下打工人使用动态库的决心</p>
<ul>
<li><strong>内存共享</strong>：多个进程可以共享同一个 DLL 文件，操作系统只需要在内存中加载一次，节省了大量的内存资源<ul>
<li>现代的程序一般都自带第三库，例如<code>Qt5Core.dll</code>，假如目录&#x2F;路径不同，可能会加载多份（？）</li>
</ul>
</li>
<li><strong>可扩展性</strong>：可以将核心功能和插件分离，在运行时动态加载不同的模块，方便地进行功能扩展而无需修改主程序</li>
<li><strong>简化更新</strong>：如果需要更新某个 DLL 文件的功能或修复 Bug，只需要替换 DLL 文件，无需重新编译整个应用程序<ul>
<li>好像破解也会替换<code>dll</code> hhh</li>
</ul>
</li>
</ul>
<h2 id="extern-vs-declspec-dllimport"><a href="#extern-vs-declspec-dllimport" class="headerlink" title="extern vs __declspec(dllimport)"></a>extern vs __declspec(dllimport)</h2><blockquote>
<p>就是为了这点醋，才包了这顿饺子</p>
</blockquote>
<p>我相信大家一定有这样的疑惑：<code>extern</code>和<code>__declspec(dllimport)</code>都是用来声明外部符号，他们之间有什么区别呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-keyword">extern</span> __declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure>

<p>观察这两行声明，同时用到了<code>extern</code>和<code>__declspec(dllimport)</code>，非常令人头大</p>
<p>不慌，我们先来看看第二行：<code>test_cpp</code></p>
<ul>
<li>首先，我们知道函数默认是<strong>外部链接</strong>的，意味着<code>extern</code>可以省略</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>其次，对于<strong>函数</strong>而言，<code>__declspec(dllimport)</code>也是可选的，这只是为了优化</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/importing-into-an-application-using-declspec-dllimport?view=msvc-170">微软文档</a><br>Using <strong><code>__declspec(dllimport)</code></strong> is optional on function declarations, but the compiler produces more efficient code if you use this keyword. However, you must use <strong><code>__declspec(dllimport)</code></strong> for the importing executable to access the DLL’s public data symbols and objects. Note that the users of your DLL still need to link with an import library.<br>在函数声明中使用**<code>__declspec(dllimport)</code><strong>是可选的，但如果使用此关键字，编译器会生成更高效的代码。但是，您必须使用</strong><code>__declspec(dllimport)</code>**作为导入可执行文件才能访问 DLL 的公共数据符号和对象。请注意，DLL 的用户仍然需要链接导入库</p>
</blockquote>
<p>所以其实只要这样写就可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure>

<p>不过对于以<code>C</code>格式进行导出的<code>test</code>函数，还是需要保留<code>extern &quot;C&quot;</code>的，否则无法找到对应的符号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure>

<p>根据文档，<strong>变量</strong>不能省略<code>__declspec(dllimport)</code></p>
<p>所以需要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) <span class="hljs-type">int</span> test_var;<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">extern</span> __declspec(dllimport) <span class="hljs-type">int</span> test_var; <span class="hljs-comment">// 这里 extern 可选，因为 dllimport 肯定表明了是外部链接</span><br></code></pre></td></tr></table></figure>

<p>So, 他俩的区别是什么</p>
<p>当然，<code>__declspec(dllimport)</code>只能用于<code>dll</code>的处理，这就不多说了</p>
<p>单从导入<code>dll</code>的函数和变量来看，他俩还是相辅相成、相爱相杀，不分伯仲的</p>
<h3 id="Class-的导出"><a href="#Class-的导出" class="headerlink" title="Class 的导出"></a>Class 的导出</h3><p>说完了函数、变量，我们再来聊聊<code>dll</code>中类的导出吧</p>
<p>其实也很简单，只要加上<code>API_EXPORT</code>，其他的都没有变化：</p>
<p><strong>dll.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">API_EXPORT</span> Test &#123;<br>	<span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a);<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>dllmain.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a) &#123;<br>	<span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Test::get</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用时，也只需要包含<code>dll.h</code>即可</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;mouseHook.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dll.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span></span>;<br>	std::cout &lt;&lt; t.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>不过要注意，我们包含了<code>dll.h</code>，事实上就是包含了<code>Test</code>类的完整声明</p>
<p>如果直接写<code>class API_EXPORT Test;</code>，就会由于类信息不完整导致编译报错</p>
<p>其实仔细想想，类内包含成员<strong>变量</strong>和成员<strong>函数</strong>，导出类的本质就是导出<strong>变量</strong>与<strong>函数</strong></p>
<p>如果没有完整声明，只有类名，那属于是强人所难了</p>
<p>所以从这个角度来讲，<code>extern</code>也一样，对类没有什么帮助，还是需要依赖<code>.h</code>中的类声明</p>
<h4 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h4><p>上述直接导出<code>Class</code>的方法固然非常方便，也被广泛使用（<code>Qt</code>）</p>
<p>但是存在一定的局限性，如果我们改动了类的声明（增添成员或更换顺序），会导致<code>.lib</code>也发生变化，需要重新编译主程序才能继续使用<code>.dll</code></p>
<p>为了避免这一现象，我们可以使用<strong>抽象接口方式</strong>导出类，对类细节进行封装</p>
<p>具体可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/g0ose/article/details/128959823">Dll导出C++类的3种方式_c++ 导出类-CSDN博客</a></p>
<h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40860986/article/details/87534506">extern关键字（声明和定义的区别）_外部函数和外部变量在声明时,都不能省略关键词extern-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://coderslegacy.com/c/extern-c-in-cpp/">How to use extern “C” in C++ - CodersLegacy</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yxysuanfa/p/6984895.html">C++ 编译器的函数名修饰规则 - yxysuanfa - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39220334/article/details/122394610">Win10 查看 DLL 中的函数_查看dll函数及参数-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c">What is the effect of extern “C” in C++? - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dynamic-link_library#Import_libraries">Dynamic-link library - Wikipedia</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3573475/how-does-the-import-library-work-details">c++ - How does the Import Library work? Details? - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll?view=msvc-170&redirectedfrom=MSDN">Link an executable to a DLL | Microsoft Learn</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/suphgcm/p/18592386">Windows环境下，.lib导入库 详解 - suphgcm - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/importing-into-an-application-using-declspec-dllimport?view=msvc-170">Import into an application using __declspec(dllimport) | Microsoft Learn</a></p>
<p><a target="_blank" rel="noopener" href="http://cppblog.com/suiaiguo/archive/2009/07/20/90643.html">DLL入门浅析（3）——从DLL中导出变量 - C++ Programmer - C++博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/g0ose/article/details/128959823">Dll导出C++类的3种方式_c++ 导出类-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JingJ/p/4442286.html">浅谈Windows中DLL导出类 - JinJ - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8863193/what-does-declspecdllimport-really-mean">what does __declspec(dllimport) really mean? - Stack Overflow</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/603959298">【重学C&#x2F;C++系列（二）】：extern关键字用法全解析 - 知乎</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/dll/" class="category-chain-item">dll</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/">#C++</a>
      
        <a href="/tags/Windows/">#Windows</a>
      
        <a href="/tags/dll/">#dll</a>
      
        <a href="/tags/lib/">#lib</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>extern vs __declspec(dllimport)</div>
      <div>https://mrbeancpp.github.io/2024/12/25/extern-vs-declspec-dllimport/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>MrBeanC</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年12月25日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/18/WSL2-SpeedRun/" title="WSL2 SpeedRun Any%">
                        <span class="hidden-mobile">WSL2 SpeedRun Any%</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"fmutbgyn8rDyZx0KbsXNOdlt-gzGzoHsz","appKey":"BhEqZGSXY9dJvGosmjKSfvEV","path":"window.location.pathname","placeholder":"Say sth.","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://fmutbgyn.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
