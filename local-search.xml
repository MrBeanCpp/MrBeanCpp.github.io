<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>extern vs __declspec(dllimport)</title>
    <link href="/2024/12/25/extern-vs-declspec-dllimport/"/>
    <url>/2024/12/25/extern-vs-declspec-dllimport/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>C/C++</code>中<code>extern</code>表明<strong>外部链接</strong>，说…说明可以在多个文件共享巴拉…的（小声）</p><p>记者：那外部链接是什么意思，与之相对的是什么关键字？</p><p>记者：<code>extern</code>用于声明还是定义？</p><p>记者：对于函数、变量、类以及<code>dll</code>分别有什么作用？</p><p>：别说了别说了（小声）</p><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><blockquote><p>该关键字意味着：<strong>外部链接（External Linkage）</strong>，具有 <strong>外部链接</strong> 的符号是可以在<strong>多个</strong>源文件中访问的。也就是说，这些符号在程序中是<strong>全局可见</strong>的，可以在一个源文件中定义，在其他源文件中<strong>引用</strong>。通过链接器，程序的多个源文件可以<strong>共享</strong>这些符号</p></blockquote><p>当编译器看到一个外部链接的符号（如函数或全局变量）时，它会知道该符号在当前翻译单元（<code>.cpp</code>文件）中<strong>没有定义</strong>，但不会立即报错</p><p>而是将该符号的引用<strong>推迟到链接阶段</strong>，链接器负责在链接时查找<strong>其他</strong>翻译单元中的定义，并将这些引用<strong>解析为实际的地址</strong></p><blockquote><p>注意：如果链接器在链接时找不到外部链接符号的定义，通常会报错（如 <strong>LNK1120</strong> 错误，”无法解析外部符号”）</p></blockquote><p>例如：</p><p><strong>a.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>b.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可能会奇怪：诶，怎么没有<code>.h</code>头文件也可以使用其他文件定义的函数了</p><p>别急，听我细嗦</p><h3 id="默认可见性"><a href="#默认可见性" class="headerlink" title="默认可见性"></a>默认可见性</h3><p>其实，函数和全局变量默认就是<strong>外部链接</strong>的，所以一定程度上，<code>extern</code>是可以省略的</p><p>为什么是一定程度呢，这个有点子复杂</p><h3 id="extern-用于声明还是定义"><a href="#extern-用于声明还是定义" class="headerlink" title="extern 用于声明还是定义"></a>extern 用于声明还是定义</h3><p>这确实是个值得商榷的问题，从<strong>外部链接</strong>的作用来看，是为了在使用时可以不去寻找定义，那么用在<strong>声明</strong>是最合理的：<code>extern int func();</code></p><p>不过其实<strong>定义</strong>也可以加，但是没什么用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> var = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是声明，什么是定义"><a href="#什么是声明，什么是定义" class="headerlink" title="什么是声明，什么是定义"></a>什么是声明，什么是定义</h3><p>是不是有同学笑了一下（盯——）</p><p>这个问题对于函数没有什么异议，有花括号（函数体）就是定义</p><p>那么变量呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>其实只有<code>extern int x;</code>是声明，其余都是定义</p><p><code>int x;</code>虽然没有显式初始化，但是作为全局变量，默认初始化为0；</p><p>其实对于变量来说，定义意味着<strong>分配存储空间</strong>，而<code>extern</code>意味着<strong>在别处定义</strong></p><p>所以有显示初始化的一定是定义（分配空间），而有<code>extern</code>且无初始化的才是<strong>纯声明</strong></p><p>所以刚刚说：“一定程度上，<code>extern</code>是可以省略的”，指的是：</p><ul><li>函数、全局变量定义时的<code>extern</code>可以省略（默认外部可见）</li><li>在另一个文件声明时，函数的<code>extern</code>可以省略，变量不能（否则变成了定义）（😾）</li></ul><p><strong>a.cpp</strong>（声明）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> var; <span class="hljs-comment">// 不能省略extern，否则触发&quot;重定义&quot;错误</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 可以省略extern</span><br></code></pre></td></tr></table></figure><p><strong>b.cpp</strong>（定义）（可以省略<code>extern</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> var = <span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>谨记：声明可以多次，定义只能一次</em></p><h3 id="include-头文件的本质（😾）"><a href="#include-头文件的本质（😾）" class="headerlink" title="#include 头文件的本质（😾）"></a>#include 头文件的本质（😾）</h3><p><code>#include</code> 的本质其实是文本替换：</p><p>当预处理器处理到<code>#include</code> 指令时，它会将这一行替换为头文件的全部内容，其实就是<strong>复制</strong>了一份<code>.h</code>到<code>.cpp</code>中，但是可以少写点重复代码（预处理器帮忙复制）</p><p>例如，我们平时最常见的写法是这样的：</p><p><strong>test.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><strong>test.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其本质上就是：</p><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 拷贝了 test.h 中的内容</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">func</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是看出了什么端倪，这不就是上述<strong>a.cpp</strong>省略<code>extern</code>的函数声明嘛（抖包袱）</p><p>所以我们平时一直在利用函数默认是<strong>外部链接</strong>这个特性，而不自知</p><h4 id="那么代价是什么"><a href="#那么代价是什么" class="headerlink" title="那么代价是什么"></a>那么代价是什么</h4><p>由于 <code>#include</code>是无脑复制，所以就很容易出现<strong>重定义</strong>问题（复制了太多份定义）</p><p>这时候有同学要说了，怎么可能，谁会 <code>#include</code>多个一样的头文件啊</p><p>直接包含可能不太可能，那么间接包含呢？</p><p>可能<code>#include &quot;b.h&quot;</code>，而<code>b.h</code>中<code>#include &quot;a.h&quot;</code></p><p>这种情况就很难发现了，但是最终都会复制展开到一个翻译单元（.cpp）中，造成重复定义错误</p><p>肿么办</p><h4 id="一般有两种解决方案："><a href="#一般有两种解决方案：" class="headerlink" title="一般有两种解决方案："></a>一般有两种解决方案：</h4><ol><li>宏定义法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> A_H <span class="hljs-comment">// 注意宏不要太短，防止冲突</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A_H</span><br><br><span class="hljs-comment">// 头文件内容</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// A_H</span></span><br></code></pre></td></tr></table></figure><ul><li>第一次包含 <code>a.h</code> 时，<code>#ifndef A_H</code> 判断条件为 <code>false</code>，因此定义了 <code>A_H</code>，并开始包含文件内容</li><li>第二次再包含 <code>a.h</code> 时，<code>#ifndef A_H</code> 条件为 <code>true</code>，直接跳过，从而避免了重复定义</li></ul><ol start="2"><li><code>#pragma once</code>（编译器指令）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-comment">// 头文件内容</span><br></code></pre></td></tr></table></figure><p><code>#pragma once</code>更简洁，也是更现代的做法，支持的编译器很多，但某些老旧的编译器（或者特定的工具链）可能不支持</p><p>所以如果考虑<strong>兼容性</strong>的话，可以采用第一种做法（貌似<code>Clion</code>默认生成的是第一种）</p><h2 id="declspec-dllimport"><a href="#declspec-dllimport" class="headerlink" title="__declspec(dllimport)"></a>__declspec(dllimport)</h2><p><code>__declspec</code>实际上是微软对于<code>C/C++</code>的<a href="https://stackoverflow.com/questions/2284610/what-is-declspec-and-when-do-i-need-to-use-it">特定拓展</a>，并不是语言本身的标准，只在<code>Windows</code>平台使用</p><p>&#x2F;&#x2F; 更搞的是，甚至还有<code>_declspec</code>（单下划线版本），其实是同义词，<a href="https://stackoverflow.com/questions/1399215/difference-between-declspec-and-declspec">为了兼容旧版编译器</a></p><p>显然，从名字来看，<code>__declspec(dllimport)</code>是用于从<code>dll</code>中导入符号（函数、变量等），与之相对应的是<code>__declspec(dllexport)</code>，用于导出</p><p>所以很多同学可能没有接触过，因为只在编写<code>dll</code>(Dynamic-Link Library)库时需要用到</p><p>太抽象了，多说无益，还是 <strong>Show me the code</strong> 吧</p><p>一般用<code>Visual Studio</code>来编写（新建<code>dll</code>工程就有模板）ref : <a href="https://blog.cls.ink/2022/04/07/Windows-Hook-%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/#%E5%AE%9E%E6%93%8D2%EF%BC%9A%E9%BC%A0%E6%A0%87%E9%92%A9%E5%AD%90%EF%BC%88dll%EF%BC%89">Windows Hook 技术浅析 - MrBeanC-Blog</a></p><p><strong>dllmain.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有被<code>__declspec(dllexport)</code>标记的符号才会被导出（这和<code>linux</code>的<code>.so</code>(Shared Object file)正好相反，<code>.so</code>是默认导出所有符号）</p><p>直接编译（生成解决方案）就可以得到产物：<code>test.dll</code> <code>test.lib</code></p><h3 id="dll-amp-lib"><a href="#dll-amp-lib" class="headerlink" title=".dll &amp; .lib"></a>.dll &amp; .lib</h3><p>为什么<code>Windows</code>下的动态库有两个文件构成，而<code>Linux</code>只有一个<code>.so</code>呢</p><p>这个说起来就比较复杂了</p><h4 id="lib"><a href="#lib" class="headerlink" title=".lib"></a>.lib</h4><p><code>.lib</code>实际上有两种用途</p><ul><li>静态库（Static Library）：包含所有代码实现，直接编译到可执行文件中</li><li>导入库（Import Library）：此时需要和<code>dll</code>配合使用，此时的<code>.lib</code>文件内并不包含具体的代码实现，而是一个<strong>符号表</strong>，用于让静态链接器知道如何连接到<code>dll</code>中的符号，起到中介的作用</li></ul><blockquote><p>没有简单的方法可以区分它们，除了作为 dll 导入库的 lib 通常比匹配的静态 lib 小（通常小得多）<br><a href="https://en.wikipedia.org/wiki/Dynamic-link_library#Import_libraries">Dynamic-link library - Wikipedia</a></p></blockquote><p>试想一下，我们如何使用刚刚编译出来的<code>dll</code>库，也许是这样：</p><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_cpp</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来很合理对吧，但是在运行时，程序怎么知道<code>test_cpp</code>函数在哪个<code>dll</code>文件的哪个位置（偏移量）呢？</p><p>所以虽然编译能过，但是<strong>链接</strong>阶段会直接报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">main.cpp.obj : error LNK2019: 无法解析的外部符号 <span class="hljs-string">&quot;int __cdecl test_cpp(int)&quot;</span> (?test_cpp@@YAHH@Z)，函数 main 中引用了该符号<br></code></pre></td></tr></table></figure><p>因为链接器根本不知道去哪里找这个函数</p><p>这不纯纯抓瞎嘛，只要代入机器视角就能发现端倪了</p><h4 id="dll-only"><a href="#dll-only" class="headerlink" title=".dll only"></a>.dll only</h4><p>我们先来看看假如只有<code>.dll</code>的情况下，应该如何使用其中的函数吧</p><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(* pfnTestC)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 定义函数指针类型</span><br>    HMODULE hMouse = <span class="hljs-built_in">LoadLibrary</span>(<span class="hljs-string">&quot;mouseHook.dll&quot;</span>); <span class="hljs-comment">// 加载dll (Only once for each process)</span><br>    <span class="hljs-keyword">if</span> (hMouse) &#123;<br>        <span class="hljs-keyword">auto</span> testC = (pfnTestC) <span class="hljs-built_in">GetProcAddress</span>(hMouse, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">// 获取test函数在dll中的地址</span><br>        <span class="hljs-keyword">if</span> (testC)<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;dynamic load: &quot;</span> &lt;&lt; <span class="hljs-built_in">testC</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样应该能比较清晰地看明白调用一个<code>dll</code>中函数的过程</p><ol><li>加载<code>dll</code>进内存（同一个<code>dll</code>只会加载一份）</li><li>获取函数在<code>dll</code>中的地址（指针）</li><li>将地址转换为对应的函数指针就可以调用了</li></ol><p>这种方法不需要依赖<code>.h</code>和<code>.lib</code>，但是调用起来稍微复杂一点</p><p>通常，这种方式被称为：<strong>显式链接</strong>（<em>Explicit linking</em>），或 <em>dynamic load</em> or <em>run-time dynamic linking</em></p><p>一般用在插件系统（运行时加载新插件，而无需重新编译和分发主程序）或者未公开API</p><p>例如：<a href="https://learn.microsoft.com/en-us/windows/win32/dwm/setwindowcompositionattribute">SetWindowCompositionAttribute</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWindowBlur</span><span class="hljs-params">(HWND hWnd)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">BOOL</span><span class="hljs-params">(WINAPI* pfnSetWindowCompositionAttribute)</span><span class="hljs-params">(HWND, WINDOWCOMPOSITIONATTRIBDATA*)</span></span>;<br>    <br>    HMODULE hUser = <span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-string">L&quot;user32.dll&quot;</span>); <span class="hljs-comment">// 在确定dll已经被加载的情况下，可以用 GetModuleHandle 替代 LoadLibrary</span><br>    <span class="hljs-keyword">if</span> (hUser) &#123;<br>        <span class="hljs-keyword">auto</span> setWindowCompositionAttribute = (pfnSetWindowCompositionAttribute) <span class="hljs-built_in">GetProcAddress</span>(hUser, <span class="hljs-string">&quot;SetWindowCompositionAttribute&quot;</span>);<br>        <span class="hljs-keyword">if</span> (setWindowCompositionAttribute) &#123;<br>            ACCENT_POLICY accent = &#123;ACCENT_ENABLE_BLURBEHIND, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            WINDOWCOMPOSITIONATTRIBDATA data;<br>            data.Attrib = WCA_ACCENT_POLICY;<br>            data.pvData = &amp;accent;<br>            data.cbData = <span class="hljs-built_in">sizeof</span>(accent);<br>            <span class="hljs-built_in">setWindowCompositionAttribute</span>(hWnd, &amp;data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数可以为窗口实现毛玻璃效果，但是可能由于性能原因，并没有公开</p><blockquote><p>微软文档：<br><strong>该函数没有关联的导入库或头文件；您必须使用</strong><a href="https://learn.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya"><strong>LoadLibrary</strong></a><strong>和</strong><a href="https://learn.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress"><strong>GetProcAddress</strong></a><strong>函数来调用它。该 API 是从 user32.dll 导出的</strong></p></blockquote><h3 id="Why-extern-“C”"><a href="#Why-extern-“C”" class="headerlink" title="Why extern “C”"></a>Why extern “C”</h3><p>相信大家已经注意到了，刚刚是通过<code>GetProcAddress(hMouse, &quot;test&quot;)</code>函数获取函数地址的</p><p>但是为什么”test”就能定位到<code>test</code>函数呢（虽然听起来有点脱裤子放屁）</p><p>但是你仔细想想，<code>C++</code>的函数签名真的是可以通过<strong>函数名</strong>唯一确定吗？视重载为何物</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">float</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p>所以，其实上文的<code>test</code>函数其实并不是以<code>C++</code>函数的形式导出的</p><p><strong>dllmain.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;<br>&#125;<br><br>__declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>没错，和<code>test_cpp</code>相比，<code>test</code>函数多了<code>extern &quot;C&quot;</code></p><h4 id="Name-Mangling"><a href="#Name-Mangling" class="headerlink" title="Name Mangling"></a>Name Mangling</h4><p><code>extern &quot;C&quot;</code>意味着把<code>test</code>作为一个<code>C</code>函数进行导出，不要进行名称修饰（<a href="https://en.wikipedia.org/wiki/Name_mangling">Name Mangling</a>）</p><p>ref: <a href="https://coderslegacy.com/c/extern-c-in-cpp/">How to use extern “C” in C++ - CodersLegacy</a></p><p>简单来说，名称修饰是由于<code>C++</code>函数存在<strong>重载</strong>，所以函数名具有<strong>二义性</strong>，需要在符号中加入其他信息来区分彼此</p><p>我们可以使用<code>VS</code>自带的<code>dumpbin.exe</code>工具来查看<code>dll</code>中的符号</p><p>&#x2F;&#x2F; 路径可能是：<code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\bin\Hostx86\x86\dumpbin.exe</code></p><p>&#x2F;&#x2F; 打开<code>Developer Command Prompt for VS 2022</code>可以自动加载到环境变量</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">// Developer Command Prompt <span class="hljs-keyword">for</span> VS <span class="hljs-number">2022</span><br>dumpbin /exports mouseHook.dll<br><br>ordinal hint RVA      name<br>    <span class="hljs-number">1</span>    <span class="hljs-number">0</span> <span class="hljs-number">000112</span>F3 ?test_cpp<span class="hljs-selector-tag">@</span>@YAHH@Z = @ILT+<span class="hljs-number">750</span>(?test_cpp<span class="hljs-selector-tag">@</span>@YAHH@Z)<br>    <span class="hljs-number">2</span>    <span class="hljs-number">1</span> <span class="hljs-number">000112</span>D5 ?test_macro<span class="hljs-selector-tag">@</span>@YAHH@Z = @ILT+<span class="hljs-number">720</span>(?test_macro<span class="hljs-selector-tag">@</span>@YAHH@Z)<br>    <span class="hljs-number">3</span>    <span class="hljs-number">2</span> <span class="hljs-number">0001</span>D000 ?test_var<span class="hljs-selector-tag">@</span>@<span class="hljs-number">3</span>HA = ?test_var<span class="hljs-selector-tag">@</span>@<span class="hljs-number">3</span>HA (int test_var)<br>    <span class="hljs-number">4</span>    <span class="hljs-number">3</span> <span class="hljs-number">000112</span>F8 clearHook = @ILT+<span class="hljs-number">755</span>(clearHook)<br>    <span class="hljs-number">5</span>    <span class="hljs-number">4</span> <span class="hljs-number">000110</span>C3 setMouseHook = @ILT+<span class="hljs-number">190</span>(setMouseHook)<br>    <span class="hljs-number">6</span>    <span class="hljs-number">5</span> <span class="hljs-number">0001114</span>A test = @ILT+<span class="hljs-number">325</span>(test)<br></code></pre></td></tr></table></figure><p>比如上述<code>test_cpp</code>函数在<code>dll</code>中表示为：<code>?test_cpp@@YAHH@Z</code>，而不是<code>test_cpp</code></p><ul><li>以<code>?</code>标识函数名的开始，后跟函数名，函数名后面以<code>@@YA</code>（对于<code>__cdecl</code>调用方式）标识参数表的开始，后跟参数表</li><li><code>H</code>代表<code>int</code>，<code>D--char</code>，<code>X--void</code>等等</li><li>第一个<code>H</code>代表返回值，第二个<code>H</code>代表参数</li><li>最后的<code>@Z</code>标记参数表结尾</li></ul><p>ref: <a href="https://www.cnblogs.com/yxysuanfa/p/6984895.html">C++ 编译器的函数名修饰规则 - yxysuanfa - 博客园</a></p><p>所以我们可以这样获取一个<code>C++</code>函数地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">GetProcAddress</span>(hMouse, <span class="hljs-string">&quot;?test_cpp@@YAHH@Z&quot;</span>);<br></code></pre></td></tr></table></figure><p>看起来有点鬼畜，但是没办法</p><p>使用<code>extern &quot;C&quot;</code>可以避免进行名称修饰，让<code>dll</code>函数调用简单很多</p><p>当然，简单并不是最关键的理由</p><ol><li><p>这样可以兼容C程序</p></li><li><p>可以跨编译器调用<code>dll</code></p><p>因为不同编译器的名称修饰规则不同，例如<code>MinGW</code>是以<code>_Z</code>开头，而<code>MSVC</code>是以<code>?</code>开头，所以无法互相识别</p></li></ol><p>要注意一个显而易见的道理，使用<code>extern &quot;C&quot;</code>之后会被视为<code>C</code>函数，所以函数重载不可用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C2733 “<span class="hljs-built_in">test</span>”: 无法重载具有外部 <span class="hljs-string">&quot;C&quot;</span> 链接的函数<br></code></pre></td></tr></table></figure><p>当然，如果只是为了自己使用，或者条件允许（相同编译器）的情况下，可以不使用<code>extern &quot;C&quot;</code>，例如：<code>Qt</code></p><h3 id="dll-with-lib"><a href="#dll-with-lib" class="headerlink" title=".dll with .lib"></a>.dll with .lib</h3><p>好的，通过上述的例子，我们已经知道了直接调用裸<code>dll</code>中函数的复杂性</p><p>不仅要考虑<code>dll</code>的加载释放，还要考虑修饰后的不可读名称，晕头转向</p><p>此时就轮到<code>.lib</code>出场了</p><p>本质上，<code>.lib</code>文件就是一个中介，帮助程序找到函数所在<code>dll</code>和地址</p><p>无非就是这两行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">LoadLibrary</span>(<span class="hljs-string">&quot;mouseHook.dll&quot;</span>);<br><span class="hljs-built_in">GetProcAddress</span>(hMouse, <span class="hljs-string">&quot;?test_cpp@@YAHH@Z&quot;</span>);<br></code></pre></td></tr></table></figure><p>用<code>dumpbin /all</code>命令查看<code>.lib</code>文件内部保存的详细符号信息</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmd">dumpbin /all mouseHook.lib<br><br>Archive member name <span class="hljs-built_in">at</span> <span class="hljs-number">7</span>E0: mouseHook.dll/<br>...<br><br>  Version      : <span class="hljs-number">0</span><br>  Machine      : <span class="hljs-number">8664</span> (x64)<br><span class="hljs-function">  TimeDateStamp: <span class="hljs-title">FB36C7D7</span></span><br><span class="hljs-function">  <span class="hljs-title">SizeOfData</span>   : 00000020</span><br><span class="hljs-function">  <span class="hljs-title">DLL</span> <span class="hljs-title">name</span>     : <span class="hljs-title">mouseHook.dll</span></span><br><span class="hljs-function">  <span class="hljs-title">Symbol</span> <span class="hljs-title">name</span>  : ?<span class="hljs-title">test_cpp</span>@@<span class="hljs-title">YAHH</span>@<span class="hljs-title">Z</span> (<span class="hljs-title">int</span> <span class="hljs-title">__cdecl</span> <span class="hljs-title">test_cpp</span>(<span class="hljs-title">int</span>))</span><br><span class="hljs-function">  <span class="hljs-title">Type</span>         : <span class="hljs-title">code</span></span><br><span class="hljs-function">  <span class="hljs-title">Name</span> <span class="hljs-title">type</span>    : <span class="hljs-title">name</span></span><br><span class="hljs-function">  <span class="hljs-title">Hint</span>         : 0</span><br><span class="hljs-function">  <span class="hljs-title">Name</span>         : ?<span class="hljs-title">test_cpp</span>@@<span class="hljs-title">YAHH</span>@<span class="hljs-title">Z</span></span><br><span class="hljs-function">...</span><br></code></pre></td></tr></table></figure><p>有了这些信息，就可以大大简化我们对<code>.dll</code>的使用</p><h4 id="use-lib"><a href="#use-lib" class="headerlink" title="use .lib"></a>use .lib</h4><p>使用<code>.lib</code>也很简单</p><ol><li>对于<code>MSVC</code>编译器，加上一行编译器指令即可</li></ol><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;E:\\Projects\\cpp\\tests\\dllimport\\mouseHook.lib&quot;</span>) <span class="hljs-comment">// 如果是系统库 一般只需要相对路径</span></span><br>__declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_cpp</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>对于<code>cmake</code>，更加通用的做法是：</li></ol><p><strong>CMakeLists.txt</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/mouseHook.lib)<br></code></pre></td></tr></table></figure><p>如此一来，链接器在根据<code>int test_cpp(int a)</code>得到符号<code>?test_cpp@@YAHH@Z</code>后</p><p>就能通过<code>.lib</code>找到对应的<code>dll</code>名称<code>mouseHook.dll</code>，以及相应的函数地址了</p><p>在程序<strong>启动时</strong>，会自动寻找对应的<code>dll</code>并加载</p><p>这被称为：<strong>隐式链接</strong>（<em>Implicit linking</em>），或 <em>static load</em> or <em>load-time dynamic linking</em></p><blockquote><p><a href="https://learn.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll?view=msvc-170&redirectedfrom=MSDN#:~:text=%E8%BF%9B%E7%A8%8B%E4%B8%8D%E4%BC%9A%E7%BB%88%E6%AD%A2%E3%80%82-,An%20application,-that%20implicitly%20links">微软文档</a></p><p>隐式链接到许多 DLL 的应用程序启动速度可能会很慢，因为 Windows 在加载应用程序时会加载所有 DLL<br>为了提高启动性能，应用程序可能只对加载后立即需要的 DLL 使用隐式链接。它可能仅在需要时使用显式链接来加载其他 DLL</p></blockquote><h4 id="默认库"><a href="#默认库" class="headerlink" title="默认库"></a>默认库</h4><p>其实，我们调用<code>Windows API</code>时调用的就是动态库，但是为什么好像一般不需要指定<code>.lib</code>呢</p><p>这是因为编译器帮我们链接了常用的系统默认库</p><p>在<code>Visual Studio</code>，“配置属性”&gt;“链接器”&gt;“命令行”属性页中可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;kernel32.lib&quot;</span> <span class="hljs-string">&quot;user32.lib&quot;</span> <span class="hljs-string">&quot;gdi32.lib&quot;</span> <span class="hljs-string">&quot;winspool.lib&quot;</span> <span class="hljs-string">&quot;comdlg32.lib&quot;</span> <span class="hljs-string">&quot;advapi32.lib&quot;</span> <span class="hljs-string">&quot;shell32.lib&quot;</span> <span class="hljs-string">&quot;ole32.lib&quot;</span> <span class="hljs-string">&quot;oleaut32.lib&quot;</span> <span class="hljs-string">&quot;uuid.lib&quot;</span> <span class="hljs-string">&quot;odbc32.lib&quot;</span> <span class="hljs-string">&quot;odbccp32.lib&quot;</span><br></code></pre></td></tr></table></figure><h4 id="dll-搜索目录"><a href="#dll-搜索目录" class="headerlink" title="dll 搜索目录"></a>dll 搜索目录</h4><p>ref: <a href="https://learn.microsoft.com/zh-cn/windows/win32/dlls/dynamic-link-library-search-order?redirectedfrom=MSDN">Dynamic-link library search order - Win32 apps | Microsoft Learn</a></p><p>那么程序启动后会在哪里搜索<code>dll</code>呢</p><p>文档看起来有点复杂，不过一般来说，只需要考虑：</p><ul><li><code>exe</code>所在目录</li><li>系统文件夹</li><li>当前目录</li><li><code>PATH</code>环境变量</li></ul><h3 id="dll-统一头文件"><a href="#dll-统一头文件" class="headerlink" title="dll - 统一头文件"></a>dll - 统一头文件</h3><p>我们都知道，<code>Qt</code>基本上是动态链接的</p><p>但是平时是不是没有特别在意过这个事实</p><p>我指的是，使用起来相当无缝，以至于并不需要在意是动态&#x2F;静态库</p><p>为什么呢，为什么<code>Qt</code>可以有这样的体验？</p><p>问题还是出在头文件上，我们之前提到了<code>.lib</code> <code>.dll</code>，唯独没有提到<code>.h</code></p><h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><p>对于<code>QString qt_error_string(int code)</code>函数，我并不需显式地<code>__declspec(dllimport)</code>或者<code>extern</code></p><p>只需要<code>#include&lt;qlogging.h&gt;</code>或者<code>#include&lt;QDebug&gt;</code>即可使用该函数</p><p><strong>qlogging.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Q_CORE_EXPORT QString <span class="hljs-title">qt_error_string</span><span class="hljs-params">(<span class="hljs-type">int</span> errorCode = <span class="hljs-number">-1</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>qsystemerror.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;xx.h&gt;</span></span><br><span class="hljs-function">QString <span class="hljs-title">qt_error_string</span><span class="hljs-params">(<span class="hljs-type">int</span> code)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">windowsErrorString</span>(code == <span class="hljs-number">-1</span> ? <span class="hljs-built_in">GetLastError</span>() : code);<br>&#125;<br></code></pre></td></tr></table></figure><p>玄机就在<code>Q_CORE_EXPORT</code>中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#  <span class="hljs-keyword">define</span> Q_DECL_EXPORT __declspec(dllexport)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> Q_DECL_IMPORT __declspec(dllimport)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(QT_SHARED) || !defined(QT_STATIC)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">if</span> defined(QT_BUILD_CORE_LIB)</span><br><span class="hljs-meta">#    <span class="hljs-keyword">define</span> Q_CORE_EXPORT Q_DECL_EXPORT</span><br><span class="hljs-meta">#  <span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#    <span class="hljs-keyword">define</span> Q_CORE_EXPORT Q_DECL_IMPORT</span><br><span class="hljs-meta">#  <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> Q_CORE_EXPORT</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>如果定义了<code>QT_BUILD_CORE_LIB</code>，<code>Q_CORE_EXPORT</code>就是<code>__declspec(dllexport)</code>，否则为<code>__declspec(dllimport)</code></p><p>既然导入导出的声明代码是类似的，就可以通过宏开关的方式实现复用，妙哉</p><h5 id="编译-dll"><a href="#编译-dll" class="headerlink" title="编译 dll"></a>编译 dll</h5><p>我们唯一要做的就是在编译<code>dll</code>时启动这个宏<code>QT_BUILD_CORE_LIB</code></p><p>例如在<code>CMakelists.txt</code>中开启这个宏，或者直接在<code>.cpp</code>文件中<code>#define</code></p><p><strong>dll.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BUILDING_DLL)</span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> API_EXPORT __declspec(dllexport)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> API_EXPORT __declspec(dllimport)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-function">API_EXPORT <span class="hljs-type">int</span> <span class="hljs-title">test_macro</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>dllmain.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUILDING_DLL</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dll.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_macro</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(a, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-dll"><a href="#使用-dll" class="headerlink" title="使用 dll"></a>使用 dll</h5><p>然后，在客户端使用<code>dll</code>时，也就可以复用同一套<code>.h</code>进行<code>dllimport</code>了，perfect</p><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;E:\\Projects\\cpp\\tests\\dllimport\\mouseHook.lib&quot;</span>) <span class="hljs-comment">// 推荐 CMakeLists.txt 统一控制</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dll.h&quot;</span> <span class="hljs-comment">// 本质是拷贝</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test_macro</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时<code>API_EXPORT</code>会自动变成<code>__declspec(dllimport)</code>，进行导入，十分无感</p><p>甚至都不需要手动写什么函数声明了😄</p><h3 id="Why-dll"><a href="#Why-dll" class="headerlink" title="Why dll"></a>Why dll</h3><p>说了这么多，话说我们到底为什么要用<code>dll</code>呢？</p><p>如果不是使用<code>dll</code>动态库，其实我们就只剩下了两种选择：<code>.lib</code>静态库 &amp; 拷贝源码</p><h4 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1.静态库"></a>1.静态库</h4><p>静态库会在编译链接时被打包进最终的可执行文件中，运行时不再依赖额外的<code>dll</code>文件，更方便</p><p>但带来的是<code>exe</code>文件体积膨胀，启动速度变慢，以及代码复用性变差等问题</p><p>同时，如果想要升级外部库代码，就必须重新编译链接，不便于软件升级</p><blockquote><p><code>Qt</code>貌似不太允许静态编译，因为这样就隐藏了<code>Qt</code>的文件标识，属于白嫖行为</p></blockquote><h4 id="2-源码"><a href="#2-源码" class="headerlink" title="2.源码"></a>2.源码</h4><p>如果你既不想用静态库，又不想用动态库，那么你只能拷贝第三方库源代码了对吧</p><p>这个，很难评😄</p><h4 id="dll-的优势"><a href="#dll-的优势" class="headerlink" title="dll 的优势"></a>dll 的优势</h4><p>Okay，那么最后再总结一下<code>dll</code>的优点，坚定一下打工人使用动态库的决心</p><ul><li><strong>内存共享</strong>：多个进程可以共享同一个 DLL 文件，操作系统只需要在内存中加载一次，节省了大量的内存资源<ul><li>现代的程序一般都自带第三库，例如<code>Qt5Core.dll</code>，假如目录&#x2F;路径不同，可能会加载多份（？）</li></ul></li><li><strong>可扩展性</strong>：可以将核心功能和插件分离，在运行时动态加载不同的模块，方便地进行功能扩展而无需修改主程序</li><li><strong>简化更新</strong>：如果需要更新某个 DLL 文件的功能或修复 Bug，只需要替换 DLL 文件，无需重新编译整个应用程序<ul><li>好像破解也会替换<code>dll</code> hhh</li></ul></li></ul><h2 id="extern-vs-declspec-dllimport"><a href="#extern-vs-declspec-dllimport" class="headerlink" title="extern vs __declspec(dllimport)"></a>extern vs __declspec(dllimport)</h2><blockquote><p>就是为了这点醋，才包了这顿饺子</p></blockquote><p>我相信大家一定有这样的疑惑：<code>extern</code>和<code>__declspec(dllimport)</code>都是用来声明外部符号，他们之间有什么区别呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> __declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-keyword">extern</span> __declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p>观察这两行声明，同时用到了<code>extern</code>和<code>__declspec(dllimport)</code>，非常令人头大</p><p>不慌，我们先来看看第二行：<code>test_cpp</code></p><ul><li>首先，我们知道函数默认是<strong>外部链接</strong>的，意味着<code>extern</code>可以省略</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>其次，对于<strong>函数</strong>而言，<code>__declspec(dllimport)</code>也是可选的，这只是为了优化</li></ul><blockquote><p><a href="https://learn.microsoft.com/en-us/cpp/build/importing-into-an-application-using-declspec-dllimport?view=msvc-170">微软文档</a><br>Using <strong><code>__declspec(dllimport)</code></strong> is optional on function declarations, but the compiler produces more efficient code if you use this keyword. However, you must use <strong><code>__declspec(dllimport)</code></strong> for the importing executable to access the DLL’s public data symbols and objects. Note that the users of your DLL still need to link with an import library.<br>在函数声明中使用**<code>__declspec(dllimport)</code><strong>是可选的，但如果使用此关键字，编译器会生成更高效的代码。但是，您必须使用</strong><code>__declspec(dllimport)</code>**作为导入可执行文件才能访问 DLL 的公共数据符号和对象。请注意，DLL 的用户仍然需要链接导入库</p></blockquote><p>所以其实只要这样写就可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test_cpp</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p>不过对于以<code>C</code>格式进行导出的<code>test</code>函数，还是需要保留<code>extern &quot;C&quot;</code>的，否则无法找到对应的符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br></code></pre></td></tr></table></figure><p>根据文档，<strong>变量</strong>不能省略<code>__declspec(dllimport)</code></p><p>所以需要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__declspec(dllimport) <span class="hljs-type">int</span> test_var;<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">extern</span> __declspec(dllimport) <span class="hljs-type">int</span> test_var; <span class="hljs-comment">// 这里 extern 可选，因为 dllimport 肯定表明了是外部链接</span><br></code></pre></td></tr></table></figure><p>So, 他俩的区别是什么</p><p>当然，<code>__declspec(dllimport)</code>只能用于<code>dll</code>的处理，这就不多说了</p><p>单从导入<code>dll</code>的函数和变量来看，他俩还是相辅相成、相爱相杀，不分伯仲的</p><h3 id="Class-的导出"><a href="#Class-的导出" class="headerlink" title="Class 的导出"></a>Class 的导出</h3><p>说完了函数、变量，我们再来聊聊<code>dll</code>中类的导出吧</p><p>其实也很简单，只要加上<code>API_EXPORT</code>，其他的都没有变化：</p><p><strong>dll.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">API_EXPORT</span> Test &#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>dllmain.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Test::<span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a) &#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Test::get</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用时，也只需要包含<code>dll.h</code>即可</p><p><strong>main.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;mouseHook.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dll.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">1024</span>)</span></span>;<br>std::cout &lt;&lt; t.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h4><p>不过要注意，我们包含了<code>dll.h</code>，事实上就是包含了<code>Test</code>类的完整声明</p><p>如果直接写<code>class API_EXPORT Test;</code>，就会由于类信息不完整导致编译报错</p><p>其实仔细想想，类内包含成员<strong>变量</strong>和成员<strong>函数</strong>，导出类的本质就是导出<strong>变量</strong>与<strong>函数</strong></p><p>如果没有完整声明，只有类名，那属于是强人所难了</p><p>所以从这个角度来讲，<code>extern</code>也一样，对类没有什么帮助，还是需要依赖<code>.h</code>中的类声明</p><h4 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h4><p>上述直接导出<code>Class</code>的方法固然非常方便，也被广泛使用（<code>Qt</code>）</p><p>但是存在一定的局限性，如果我们改动了类的声明（增添成员或更换顺序），会导致<code>.lib</code>也发生变化，需要重新编译主程序才能继续使用<code>.dll</code></p><p>为了避免这一现象，我们可以使用<strong>抽象接口方式</strong>导出类，对类细节进行封装</p><p>具体可以参考：<a href="https://blog.csdn.net/g0ose/article/details/128959823">Dll导出C++类的3种方式_c++ 导出类-CSDN博客</a></p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/qq_40860986/article/details/87534506">extern关键字（声明和定义的区别）_外部函数和外部变量在声明时,都不能省略关键词extern-CSDN博客</a></p><p><a href="https://coderslegacy.com/c/extern-c-in-cpp/">How to use extern “C” in C++ - CodersLegacy</a></p><p><a href="https://www.cnblogs.com/yxysuanfa/p/6984895.html">C++ 编译器的函数名修饰规则 - yxysuanfa - 博客园</a></p><p><a href="https://blog.csdn.net/qq_39220334/article/details/122394610">Win10 查看 DLL 中的函数_查看dll函数及参数-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c">What is the effect of extern “C” in C++? - Stack Overflow</a></p><p><a href="https://en.wikipedia.org/wiki/Dynamic-link_library#Import_libraries">Dynamic-link library - Wikipedia</a></p><p><a href="https://stackoverflow.com/questions/3573475/how-does-the-import-library-work-details">c++ - How does the Import Library work? Details? - Stack Overflow</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll?view=msvc-170&redirectedfrom=MSDN">Link an executable to a DLL | Microsoft Learn</a></p><p><a href="https://www.cnblogs.com/suphgcm/p/18592386">Windows环境下，.lib导入库 详解 - suphgcm - 博客园</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/build/importing-into-an-application-using-declspec-dllimport?view=msvc-170">Import into an application using __declspec(dllimport) | Microsoft Learn</a></p><p><a href="http://cppblog.com/suiaiguo/archive/2009/07/20/90643.html">DLL入门浅析（3）——从DLL中导出变量 - C++ Programmer - C++博客</a></p><p><a href="https://blog.csdn.net/g0ose/article/details/128959823">Dll导出C++类的3种方式_c++ 导出类-CSDN博客</a></p><p><a href="https://www.cnblogs.com/JingJ/p/4442286.html">浅谈Windows中DLL导出类 - JinJ - 博客园</a></p><p><a href="https://stackoverflow.com/questions/8863193/what-does-declspecdllimport-really-mean">what does __declspec(dllimport) really mean? - Stack Overflow</a></p><p><a href="https://zhuanlan.zhihu.com/p/603959298">【重学C&#x2F;C++系列（二）】：extern关键字用法全解析 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>dll</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Windows</tag>
      
      <tag>dll</tag>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2 SpeedRun Any%</title>
    <link href="/2024/10/18/WSL2-SpeedRun/"/>
    <url>/2024/10/18/WSL2-SpeedRun/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，这个世界对<code>Windows</code>开发者不太友好🥹</p><p>大量开源项目很难在<code>Windows</code>上跑起来，要么是依赖支持不完善，要么是噼里啪啦</p><p>由于纯<code>Linux</code>笔记本的日常App生态不够完善，因此程序员一般人手一台<code>Mac</code></p><p>但是，我对这<code>Windows</code>爱得深沉😢</p><p>不过好消息是 巨硬（微软）推出了<code>WSL（Windows Subsystem for Linux）</code></p><p>至此，<code>Windows</code>成了最好的<code>Linux</code>虚拟机</p><h2 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h2><p><code>WSL2</code>与<code>WSL</code>有着本质的不同</p><p><code>WSL</code>通过指令转译运行于<code>Windows</code>内核之上，没有完整的 <code>Linux</code> 内核，可能会存在兼容性问题</p><p>而<code>WSL2</code>是运行于<code>Hyper-V</code>虚拟化平台之上，运行一个完整的 <code>Linux</code> 内核，整体性能会更好</p><p>此时，<code>Windows</code>和<code>WSL2</code>成了平级关系，均成了虚拟机，会有那么一点点的性能损失</p><p>不过<code>WSL2</code>自带显卡直通（<code>nvidia-smi</code>查看），人工智能专业狂喜</p><p>缺点是<code>WSL2</code>与<code>Windows</code>的文件系统互访会稍慢</p><p>总体上来讲，没有特殊需求还是更推荐<code>WSL2</code>（现在默认也是这个版本）</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>闲话少叙，本篇是速通，还是来讲讲<code>WSL2</code>的安装吧</p><p>首先我们需要开启两个<code>Windows</code>功能：</p><ul><li>适用于Linux的Windows子系统</li><li>虚拟机平台</li></ul><p><img src="/img/image-20241018174146435.png" alt="Windows功能"></p><p><em>安装之后会提示重启</em></p><p>接下来，直接到微软商店里搜<code>Ubuntu</code>就有了（推荐22.04版本，24.04可能会有点问题）</p><p>或者使用<code>Powershell</code>（管理员权限）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --install -d Ubuntu-22.04<br></code></pre></td></tr></table></figure><ul><li><p>不加<code>-d Ubuntu-22.04</code>也可以，会下载默认版本</p></li><li><p><code>--web-download</code>：从 internet 而不是 Microsoft  Store 下载 WSL 的最新版本，如果网络有问题可以试试</p></li></ul><p> <code>wsl --list --online</code>：可以用于列出所有支持的发行版</p><p>当Ubuntu下载完毕后，会自动进行安装，大概几分钟就好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">正在安装: Ubuntu 22.04 LTS<br>已安装 Ubuntu 22.04 LTS。<br>正在启动 Ubuntu 22.04 LTS...<br>Installing, this may take a few minutes...<br></code></pre></td></tr></table></figure><p>然后会提示输入用户名和密码</p><p>至此，你就成功地进入了<code>WSL2</code></p><p>完结撒花（🫡🎶😉✌️）</p><h2 id="Launch"><a href="#Launch" class="headerlink" title="Launch"></a>Launch</h2><p>之后有多种途径可以进入WSL</p><ol><li><p>命令行</p><p>直接在命令行输入<code>wsl</code>即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Windows\System32&gt;wsl<br>cls@MrBeanCPC:/mnt/c/Windows/System32$<br></code></pre></td></tr></table></figure><p>但要注意，此时的工作目录是<code>Windows</code>的C盘（&#x2F;mnt&#x2F;c）（😾）</p><p>可以通过<code>cd ~</code>切换回去，但不太方便</p></li><li><p><code>Windows</code>终端下拉列表</p><p><img src="/img/image-20241018201342053.png" alt="终端下拉列表"></p><p>我们可以看到最后一个就是<code>Ubuntu</code></p></li><li><p>开始菜单</p><p>在开始菜单中（Win键），我们可以看到两个新的应用已经被添加</p><p><img src="/img/image-20241018201545728.png" alt="WSL &amp; Settings"></p><p><code>WSL Settings</code>是在最近的更新中才添加的可视化配置工具，非常好用</p><p>而<code>WSL</code>打开之后就会进入到默认的Linux发行版，也很方便</p></li></ol><h2 id="Get-out-of-C"><a href="#Get-out-of-C" class="headerlink" title="Get out of C:\"></a>Get out of <code>C:\</code></h2><p><strong>如果你的C盘够大，可以跳过这一节</strong></p><h3 id="安装位置"><a href="#安装位置" class="headerlink" title="安装位置"></a>安装位置</h3><p>默认情况下，WSL 2 使用一个虚拟硬盘（VHD）来存储文件：</p><p><code>C:\Users\&lt;YourUsername&gt;\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_&lt;version&gt;\LocalState\ext4.vhdx</code></p><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><p>为了不让C盘爆掉，我们还是需要进行一次迁移</p><p>其实也不难，仅数个步骤：</p><ol><li><p>停止WSL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><p>我们还可以通过<code>wsl -l -v</code>查看所有安装的linux子系统状态（Stopped&#x2F;Running）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">PS C:\WINDOWS\system32&gt; wsl -l -v<br>  NAME            STATE           VERSION<br>* Ubuntu-22.04    Running         2<br></code></pre></td></tr></table></figure></li><li><p>导出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --<span class="hljs-built_in">export</span> &lt;名称&gt; &lt;要保存的路径&gt;<br></code></pre></td></tr></table></figure><p>例如：<code>wsl --export Ubuntu-22.04 D:\ubuntu.tar</code></p><p>注意，这里的名称要与<code>wsl -l -v</code>显示的<code>Name</code>对应（😾）</p></li><li><p>取消注册</p><p>然后我们需要先把原本的Linux删除（C盘）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --unregister Ubuntu-22.04<br></code></pre></td></tr></table></figure><p>酱紫，上文提到的<strong>VHD</strong>就消失了（C盘空间释放）</p><p>需要注意的是，<code>WindowsApps</code>文件夹中还会留有一个<code>Ubuntu-22.04</code>的应用，可以在开始菜单（Win键）右键卸载</p><p>&amp; ↑如果直接点击这个应用的话，会自动在C盘再次重装<code>Ubuntu</code>（😾）</p></li><li><p>导入</p><p>此时，我们可以将<code>ubuntu.tar</code>重新导入系统（可选目录）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --import &lt;Name&gt; &lt;安装目录&gt; &lt;.tar路径&gt; --version 2<br></code></pre></td></tr></table></figure><p>例如：<code>wsl --import Ubuntu D:\WSL-Ubuntu D:\ubuntu.tar --version 2</code></p><p>此时，我们已经完成了<code>Ubuntu</code>的目录迁移</p><p>可以在终端的下拉列表中看到一个新的配置文件</p><p><img src="/img/image-20241018202523735.png" alt="小企鹅"></p><p>其实这个也没有什么特别的，点进设置我们可以看到其内部也是调用了<code>wsl</code>命令</p><p><img src="/img/image-20241018202619936.png" alt="终端配置文件"></p><p>用<code>wsl</code>命令启动了名为<code>Ubuntu</code>的发行版，且<code>cd</code>启动目录到了<code>~</code>, Just</p><p>但是直接进入<code>Ubuntu</code>，我们会发现默认用户是<code>root</code>（为什么root在终端没有高亮！震怒🙃）</p></li><li><p>设置默认用户（可选）</p><p>进入<code>WSL2</code>后，我们可以通过编辑<code>/etc/wsl.conf</code>配置默认用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[user]<br>default=mrbean<br></code></pre></td></tr></table></figure><p>加这两行就行</p><p><strong>然后记得<code>wsl --shutdown</code>关闭重启一下</strong>（😾）</p><p>&#x2F;&#x2F; 什么，你说你不会用vim or nano</p><p>&#x2F;&#x2F; 别急，直接装个gedit（往下看）</p></li></ol><h2 id="WSLg"><a href="#WSLg" class="headerlink" title="WSLg"></a>WSLg</h2><p><code>WSLg</code>是微软的又一黑科技（他真的，我哭死）</p><p>aka, WSL GUI</p><p>可以直接在<code>Windows</code>中打开并显示<code>Linux</code>的<code>GUI</code>程序（显示在任务栏的那种）</p><p>小试牛刀一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gedit<br>gedit<br></code></pre></td></tr></table></figure><p>注意：Ubuntu 24.04启动（非sudo情况下）WSLg可能出现启动慢的情况</p><p><img src="/img/image-20241018203433563.png" alt="gedit in windows"></p><p>神不神奇，<code>gedit</code>的界面直接无缝显示在了<code>Windows</code>中</p><p>而且你还能在<code>Windows</code>的开始菜单中看到他（Text Editor）</p><p><img src="/img/image-20241018203519716.png" alt="gedit 开始菜单"></p><p>貌似是RDP协议巴拉的</p><p>但是大部分的GUI程序其实显示的时候都会有一个白色边框</p><p><img src="/img/image-20241018203729170.png" alt="Chome-WSLg"></p><p>emmmm，非常膈应人</p><p>只能说，可以用，但是，aaaa</p><p>关于解决方案的话，好像资料并不多，这里有一个issue可以看看：<a href="https://github.com/microsoft/wslg/issues/530">Run X11 windows without windows manager decoration · Issue #530</a></p><p>Linux Chrome安装详见：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps#install-google-chrome-for-linux">使用 WSL 运行 Linux GUI 应用 | Microsoft Learn</a></p><p>（否则没有浏览器的话<code>Jetbrains</code>的登录、认证跳转会失败）（😾）</p><h2 id="中文支持"><a href="#中文支持" class="headerlink" title="中文支持"></a>中文支持</h2><p><code>WSL2</code>貌似默认不能显示中文（会变成方框）</p><p>可以参考一下这篇博客：<a href="https://blog.csdn.net/lujian45/article/details/135314466#:~:text=%E8%BE%93%E5%85%A5%EF%BC%9Agoogle%2Dchrome-,3.,-%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E7%8E%AF%E5%A2%83">安装中文环境和字体</a></p><ol><li><h3 id="安装中文环境和字体"><a href="#安装中文环境和字体" class="headerlink" title="安装中文环境和字体"></a>安装中文环境和字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install language-pack-zh-hans<br></code></pre></td></tr></table></figure></li><li><p>手动配置一下<code>locale</code>（选择<code>zh_CN.UTF-8 UTF-8</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dpkg-reconfigure locales<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 空格选择，TAB切换按钮</p></li><li><p>映射<code>Windows</code>字体到<code>Ubuntu</code></p><p>打开<code>/etc/fonts/local.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/fonts/local.conf<br></code></pre></td></tr></table></figure><p>输入以下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">fontconfig</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>/mnt/c/Windows/Fonts<span class="hljs-tag">&lt;/<span class="hljs-name">dir</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>刷新字体缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fc-cache -f -v<br></code></pre></td></tr></table></figure></li><li><p>最后重启WSL</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--shutdown</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="WSL-Settings"><a href="#WSL-Settings" class="headerlink" title="WSL Settings"></a>WSL Settings</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>好了，这是一个老生常谈的问题</p><p>不过好消息是，近期的<code>WSL2</code>更新了<code>mirrored</code>镜像模式（默认是NAT），可以和主机共用一个IP</p><p>开启后，还能自动检测<code>Windows</code>的代理设置，简直不要太方便</p><p><img src="/img/image-20241018210303009.png" alt="WSL2设置网络"></p><p>只要打开<code>WSL Settings</code>，并将网络-网络模式改为<code>Mirrored</code>，然后重启即可</p><p>通过<code>ifconfig</code>命令就可以看到ip的变化了</p><h3 id="延迟关闭"><a href="#延迟关闭" class="headerlink" title="延迟关闭"></a>延迟关闭</h3><p><img src="/img/image-20241018212656790.png" alt="空闲超时"></p><p>这里顺便说一下，关闭<code>Ubuntu</code>命令行界面之后，WSL并不会马上关闭，而是等待60s不活动之后再关闭</p><h2 id="WSL2与Windows互通"><a href="#WSL2与Windows互通" class="headerlink" title="WSL2与Windows互通"></a>WSL2与Windows互通</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>两个系统分别都可以访问对方的文件系统，但是跨文件系统会比较慢</p><p>而且<code>WSL2</code>的文件可以直接在<code>Windows</code>的资源管理器中查看（嘿嘿）</p><p><img src="/img/image-20241018211139456.png" alt="资源管理器-WSL2"></p><p>在<code>WSL2</code>中，<code>Windows</code>的磁盘路径为：<code>/mnt/c</code>, <code>/mnt/d</code>（c d是盘符，以此类推）</p><p>而在<code>Windows</code>中，WSL2的路径为：<code>\\wsl.localhost\Ubuntu\</code></p><p>都可以用自身的软件打开对方的文件，没有问题，但是很慢（不建议）</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>他俩命令也是互通的，惊不惊喜，意不意外</p><p>在<code>WSL2</code>，可以调用<code>Windows</code>的notepad，explorer等程序，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">notepad.exe /etc/wsl.conf<br></code></pre></td></tr></table></figure><p>而在<code>Windows</code>中，可以使用<code>wsl xxx</code>这样的形式调用WSL命令，如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl gedit<br></code></pre></td></tr></table></figure><p>甚至可以命令混写：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> | wsl grep power<br></code></pre></td></tr></table></figure><p>秀儿</p><h2 id="端口无权限问题"><a href="#端口无权限问题" class="headerlink" title="端口无权限问题"></a>端口无权限问题</h2><p>注意：开启<code>Hyper-V</code>之后，可能导致某些端口无权限访问，例如<code>heox server</code>默认使用的4000端口（😾）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error: listen EACCES: permission denied 0.0.0.0:4000<br></code></pre></td></tr></table></figure><p>这里提示的并不是端口占用，而是无权限</p><p>使用<code>netstat -ano|findstr &quot;:4000&quot;</code>也是找不到什么结果的</p><p>这是因为开启Hyper-V之后这一段端口被系统保留了，无法使用</p><p>可以使用以下命令查看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> netsh interface ipv4 show excludedportrange protocol=tcp<br>协议 tcp 端口排除范围<br>开始端口    结束端口<br><span class="hljs-literal">----------</span>    <span class="hljs-literal">--------</span><br>      <span class="hljs-number">1462</span>        <span class="hljs-number">1462</span><br>      <span class="hljs-number">3437</span>        <span class="hljs-number">3536</span><br>      <span class="hljs-number">3537</span>        <span class="hljs-number">3636</span><br>      <span class="hljs-number">3783</span>        <span class="hljs-number">3882</span><br>      <span class="hljs-number">3883</span>        <span class="hljs-number">3982</span><br>      <span class="hljs-number">3983</span>        <span class="hljs-number">4082</span><br>      <span class="hljs-number">4083</span>        <span class="hljs-number">4182</span><br>      <span class="hljs-number">4283</span>        <span class="hljs-number">4382</span><br>      <span class="hljs-number">4383</span>        <span class="hljs-number">4482</span><br>      <span class="hljs-number">4483</span>        <span class="hljs-number">4582</span><br>      <span class="hljs-number">4683</span>        <span class="hljs-number">4782</span><br>      <span class="hljs-number">4783</span>        <span class="hljs-number">4882</span><br>      <span class="hljs-number">5357</span>        <span class="hljs-number">5357</span><br>      <span class="hljs-number">5358</span>        <span class="hljs-number">5457</span><br>     <span class="hljs-number">50000</span>       <span class="hljs-number">50059</span>     *<br><br>* - 管理的端口排除。<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> netsh interface ipv4 show excludedportrange protocol=udp<br><br>协议 udp 端口排除范围<br><br>开始端口    结束端口<br><span class="hljs-literal">----------</span>    <span class="hljs-literal">--------</span><br>     <span class="hljs-number">50000</span>       <span class="hljs-number">50059</span>     *<br>     <span class="hljs-number">52672</span>       <span class="hljs-number">52771</span><br>     <span class="hljs-number">54373</span>       <span class="hljs-number">54472</span><br>     <span class="hljs-number">61228</span>       <span class="hljs-number">61327</span><br>     <span class="hljs-number">61432</span>       <span class="hljs-number">61531</span><br>     <span class="hljs-number">61673</span>       <span class="hljs-number">61772</span><br>     <span class="hljs-number">62278</span>       <span class="hljs-number">62377</span><br>     <span class="hljs-number">62378</span>       <span class="hljs-number">62477</span><br>     <span class="hljs-number">62478</span>       <span class="hljs-number">62577</span><br>     <span class="hljs-number">62578</span>       <span class="hljs-number">62677</span><br>     <span class="hljs-number">62778</span>       <span class="hljs-number">62877</span><br>     <span class="hljs-number">62978</span>       <span class="hljs-number">63077</span><br>     <span class="hljs-number">63178</span>       <span class="hljs-number">63277</span><br><br>* - 管理的端口排除。<br></code></pre></td></tr></table></figure><p>所以没办法，只能手动改用其他端口了</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/gui-apps#install-google-chrome-for-linux">使用 WSL 运行 Linux GUI 应用 | Microsoft Learn</a></p><p><a href="https://www.bilibili.com/video/BV1EF4m1V7pp/">[WSL2教程] WSL安装linux系统以及从C盘迁移至其他盘</a></p><p><a href="https://www.bilibili.com/video/BV1tW42197za/">超详细的WSL教程：Windows上的Linux子系统_哔哩哔哩_bilibili</a></p><p><a href="https://github.com/microsoft/wslg/issues/530">Run X11 windows without windows manager decoration · Issue #530 · microsoft&#x2F;wslg (github.com)</a></p><p><a href="https://blog.csdn.net/lujian45/article/details/135314466">在Windows10\11的WSL2中使用图形化应用Chrome和搜狗拼音输入法_win11 wsl2 图形化-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/428957165">WSL2 基于WSLg运行Clion等GUI应用 - 知乎 (zhihu.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/faq">关于适用于 Linux 的 Windows 子系统的常见问题解答 | Microsoft Learn</a></p><p><a href="https://www.cnblogs.com/oaks/p/16054012.html">给WSL应用程序创建Windows快捷方式 - oaksharks - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.skitisu.com/win10-1080-port-bind-forbidden/">解决Win10 1080端口无权限使用的问题 - 四季天书SkiTiSu’s blog</a></p><p><a href="https://blog.ll00.cn/archives/159.html">记录一个端口监听失败问题 - 零零博客 (ll00.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>WSL2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>WSL2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QMake to CMake</title>
    <link href="/2024/10/13/QMake-to-CMake/"/>
    <url>/2024/10/13/QMake-to-CMake/</url>
    
    <content type="html"><![CDATA[<h2 id="Test-new-img-src"><a href="#Test-new-img-src" class="headerlink" title="Test new img src"></a>Test new img src</h2><h2 id="详情敬请期待…（等我逃离魔爪）"><a href="#详情敬请期待…（等我逃离魔爪）" class="headerlink" title="详情敬请期待…（等我逃离魔爪）"></a>详情敬请期待…（等我逃离魔爪）</h2><p><img src="/img/%E4%BA%BA%E7%94%9F%E5%95%8A.jpg" alt="life"></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
      <tag>CMake</tag>
      
      <tag>QMake</tag>
      
      <tag>Clion</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt Clion CMake 项目无法定位 qwindowsvistastyle.dll</title>
    <link href="/2024/10/06/Qt-Cmake-project-lost-qwindowsvistastyle-dll/"/>
    <url>/2024/10/06/Qt-Cmake-project-lost-qwindowsvistastyle-dll/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Qt6</code>已经开始慢慢抛弃<code>qmake</code>了，开始皈依<code>cmake</code></p><p>而且宇宙第一IDE - <code>Clion</code>，也是不支持<code>qmake</code></p><p>所以，我们在<code>Clion</code>上只能采用<code>cmake</code>编译<code>Qt</code>项目</p><p>但是，很快我们就会发现，运行后的窗体非常地old fashion</p><p><img src="/img/2CT4G.png" alt="style对比"></p><p>这是为什么捏？</p><p>其实就是找不着<code>qwindowsvistastyle.dll</code></p><p>该文件位于<code>D:\Qt\5.15.2\msvc2019_64\plugins\styles</code>（Qt安装目录的<code>plugins</code>目录下）</p><p>其实我们可以发现<code>Clion</code>自动生成的<code>CMakeLists.txt</code>把<code>&quot;$&#123;QT_INSTALL_PATH&#125;/plugins/platforms/qwindows$&#123;DEBUG_SUFFIX&#125;.dll&quot;</code>复制到了exe目录下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">EXISTS</span> <span class="hljs-string">&quot;$&#123;QT_INSTALL_PATH&#125;/plugins/platforms/qwindows$&#123;DEBUG_SUFFIX&#125;.dll&quot;</span>)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD<br>            <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E <span class="hljs-keyword">make_directory</span><br>            <span class="hljs-string">&quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;/plugins/platforms/&quot;</span>)<br>    <span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD<br>            <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy<br>            <span class="hljs-string">&quot;$&#123;QT_INSTALL_PATH&#125;/plugins/platforms/qwindows$&#123;DEBUG_SUFFIX&#125;.dll&quot;</span><br>            <span class="hljs-string">&quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;/plugins/platforms/&quot;</span>)<br><span class="hljs-keyword">endif</span> ()<br></code></pre></td></tr></table></figure><p>但却没有理睬<code>qwindowsvistastyle.dll</code>（可能是因为这不是必须文件吧）</p><h3 id="修正：注意，Clion生成的针对Qt6的模板已经包含了这个dll"><a href="#修正：注意，Clion生成的针对Qt6的模板已经包含了这个dll" class="headerlink" title="修正：注意，Clion生成的针对Qt6的模板已经包含了这个dll"></a>修正：注意，Clion生成的针对Qt6的模板已经包含了这个dll</h3><h2 id="怎办"><a href="#怎办" class="headerlink" title="怎办"></a>怎办</h2><p>默认情况下，<code>Windows</code> 系统会按以下顺序查找 DLL 文件：</p><ol><li><strong>可执行文件所在的目录</strong>。</li><li><strong>系统目录</strong>（如 <code>C:\Windows\System32</code>）。</li><li><strong>当前工作目录</strong>。</li><li><strong>环境变量 <code>PATH</code> 指定的目录</strong>。</li></ol><p>其实手动地复制一下就可以了（可执行文件所在目录）</p><p>注意路径是<code>style\qwindowsvistastyle.dll</code> or <code>plugins\style\qwindowsvistastyle.dll</code></p><p>但是知其然而不知其所以然</p><p>为什么<code>qmake</code>编译的<code>exe</code>就可以正确定位该<code>dll</code>位置（not <code>.lib</code>）呢（即便我没有设置plugins的环境变量）</p><p>合理的推测是，在编译期将dll搜索目录写入了exe</p><p>但貌似<code>cmake</code>无法做到这一点（on Windows）？</p><p><a href="https://blog.csdn.net/poinsettia/article/details/129084744">[windows] cmake 如何设置 需要使用的 dll_cmake添加dll-CSDN博客</a></p><p><code>qmake</code>和<code>cmake</code>最终生成的都是<code>Makefile</code>，没道理出现这样的能力差异</p><h3 id="Qt-Creator-CMake-vs-Clion-CMake"><a href="#Qt-Creator-CMake-vs-Clion-CMake" class="headerlink" title="Qt Creator CMake vs Clion CMake"></a>Qt Creator CMake vs Clion CMake</h3><p>而且而且，使用<code>Qt Creator</code>创建的<code>CMake</code>项目，是可以正确找到<code>plugins</code>文件夹的！</p><p>aaaaaaa</p><h2 id="仙人指路"><a href="#仙人指路" class="headerlink" title="仙人指路"></a>仙人指路</h2><p>Qt官方文档指出：</p><blockquote><p><strong>在 Qt 中，当应用程序启动时，应用程序的可执行目录是 Qt 搜索插件的基本目录。</strong></p><p><strong>Qt 还会查找</strong><a href="https://doc.qt.io/qt-6/qlibraryinfo.html#path">QLibraryInfo::path</a> <strong>(</strong> <a href="https://doc.qt.io/qt-6/qlibraryinfo.html#LibraryPath-enum">QLibraryInfo::PluginsPath</a> <strong>) 指定的目录，该目录通常位于</strong><code>QTDIR/plugins</code><strong>中；</strong> <code>QTDIR</code><strong>是Qt的安装目录。如果您希望 Qt 查看其他位置，您可以通过调用</strong><a href="https://doc.qt.io/qt-6/qcoreapplication.html#addLibraryPath">QCoreApplication::addLibraryPath</a> <strong>() 添加所需数量的路径。如果你想设置自己的路径，你可以使用</strong><a href="https://doc.qt.io/qt-6/qcoreapplication.html#setLibraryPaths">QCoreApplication::setLibraryPaths</a> <strong>()。</strong></p><p><strong>或者，您可以使用</strong><code>qt.conf</code><strong>文件来覆盖编译到 Qt 库中的硬编码路径。有关更多信息，请参阅</strong><a href="https://doc.qt.io/qt-6/qt-conf.html">使用 qt.conf</a> <strong>。</strong></p><p><strong>另一种可能性是在运行应用程序之前设置</strong><code>QT_PLUGIN_PATH</code><strong>环境变量；可以使用系统路径分隔符分隔多个路径。设置后，Qt 在此变量中指定的路径中查找插件。</strong></p><p><strong>注意：请勿将</strong><code>QT_PLUGIN_PATH</code>导出为系统范围的环境变量，因为它可能会干扰其他 Qt 安装</p></blockquote><p>通过<code>qApp-&gt;libraryPaths()</code>，我们可以观察在不同编译系统下dll的搜索路径</p><p>qmake &amp; Qt Creator cmake：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-string">&quot;D:/Qt/5.15.2/msvc2019_64/plugins&quot;</span>, <span class="hljs-string">&quot;D:/Qt/projects/Follower-v2.0-MSVC-Release/release&quot;</span>)<br></code></pre></td></tr></table></figure><p>Clion cmake:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(<span class="hljs-string">&quot;E:/Projects/cpp/QtCmakeTest-2/cmake-build-debug/plugins&quot;</span>, <span class="hljs-string">&quot;E:/Projects/cpp/QtCmakeTest-2/cmake-build-debug&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>The default path list consists of a single entry, the installation directory for plugins. The default installation directory for plugins is INSTALL&#x2F;plugins, where INSTALL is the directory where Qt was installed.</p></blockquote><p>我们可以发现，在默认情况下，qmake的行为与官方文档一致，返回了 Qt安装目录下的<code>plugins</code>目录 &amp; 可执行文件所在目录</p><p><strong>但是cmake却返回了可执行文件目录下的<code>plugins</code>文件夹，这是为什么！</strong></p><p>&#x2F;&#x2F; 这也解释了前文说，为什么<code>style\qwindowsvistastyle.dll</code> or <code>plugins\style\qwindowsvistastyle.dll</code>都可以</p><p>好吧，也许<code>Qt</code>自己知道自己在哪里（<code>$QTDIR</code>），而<code>Clion</code>不知道？</p><p>aaaaaa</p><h2 id="Temp-Solution"><a href="#Temp-Solution" class="headerlink" title="Temp Solution"></a>Temp Solution</h2><p>好吧，寄了，世界十大未解之谜</p><p>那么想要在<code>Clion</code>开发<code>Qt</code>怎么办捏</p><ol><li><p>手动复制<code>plugins\style\qwindowsvistastyle.dll</code></p></li><li><p>使用<code>CMakeLists.txt</code>自动化复制</p></li><li><p>使用<code>qt.conf</code>（最好放入资源文件嵌入exe）</p></li><li><p>使用<code>QCoreApplication::addLibraryPath</code>添加<code>plugins</code>目录</p></li><li><p>在<code>Clion</code>的运行配置中设置局部环境变量<code>QT_PLUGIN_PATH</code>（这样只会影响<code>Clion</code>的开发，不会影响全局）</p><p>这个比较好，这样还可以删掉<code>CMakeLists.txt</code>中拷贝<code>dll</code>的部分</p><p><img src="/img/image-20241007125801037.png" alt="Clion配置环境变量"></p></li></ol><p>当然，这些都是开发配置，对于项目发布，那肯定是要使用<code>windeployqt.exe</code>工具拷贝所有<code>dll</code>的</p><p>详情请参见：<a href="https://blog.cls.ink/2022/10/12/Qt-windeployqt%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E6%B5%85%E8%B0%88/">Qt-windeployqt部署发布浅谈 - MrBeanC-Blog (cls.ink)</a></p><p>Peace</p><h2 id="我焯，等一下"><a href="#我焯，等一下" class="headerlink" title="我焯，等一下"></a>我焯，等一下</h2><p>我突然发现，用<code>Qt Creator</code>创建的<code>cmake</code>项目，用<code>Clion</code>打开之后是可以正确搜索到<code>plugins</code>目录的</p><p>但是<code>qDebug()</code>就无法正常输出了，加上<code>QT_ASSUME_STDERR_HAS_CONSOLE=1</code>之后，也只能在<code>debug</code>模式输出</p><p>而<code>std::cout</code>也只能在<code>debug</code>模式输出，aaaaa</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>CMake太恐怖了</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>真相了，默认情况下<code>CMake</code>项目生成的<code>exe</code>直接打开是包含命令行窗口的</p><p>需要加上<code>set_target_properties($&#123;PROJECT_NAME&#125; PROPERTIES WIN32_EXECUTABLE true)</code>才能消除</p><p><code>Qt</code>默认加上了这一行</p><p>但是这样做<code>Clion</code>就无法捕获输出了</p><p>所以最好是只在<code>Release</code>模式下加上这一行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span> (CMAKE_BUILD_TYPE <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Release&quot;</span>)<br>    <span class="hljs-keyword">set_target_properties</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES WIN32_EXECUTABLE <span class="hljs-keyword">true</span>) <span class="hljs-comment"># 设置为窗口应用程序, 无控制台，同时会导致Clion无法捕获输出</span><br><span class="hljs-keyword">endif</span> ()<br></code></pre></td></tr></table></figure><h3 id="控制台意外换行-amp-颜色"><a href="#控制台意外换行-amp-颜色" class="headerlink" title="控制台意外换行 &amp; 颜色"></a>控制台意外换行 &amp; 颜色</h3><p>同时由于<code>Clion</code>貌似是直接<strong>1:1</strong>镜像了控制台中输出的内容</p><p>导致其甚至包括原本控制台宽度不够造成的额外<strong>换行</strong></p><p>听说<code>qDebug()</code>默认是输出到<code>stderr</code>，所以Clion中显示的是<strong>红色</strong>的输出，非常刺眼</p><p>那么如何解决以上两个问题呢？</p><p>其实只要开启一个设置即可：<strong>在输出控制台中模拟终端</strong></p><p><img src="/img/Clion-%E5%9C%A8%E8%BE%93%E5%87%BA%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%A8%A1%E6%8B%9F%E7%BB%88%E7%AB%AF-2.png" alt="Clion-在输出控制台中模拟终端"></p><p>这样，<code>Clion</code>的输出就完全正常了，无论是换行，还是颜色</p><h2 id="等一下，兄弟们，再等一下"><a href="#等一下，兄弟们，再等一下" class="headerlink" title="等一下，兄弟们，再等一下"></a>等一下，兄弟们，再等一下</h2><p>我又有新发现了</p><p>实际上的规则是：</p><p>如果可执行文件（exe）目录下存在<code>Qt5Core.dll</code>&#x2F;<code>Qt5Cored.dll</code>，那么<code>exe</code>就会在本目录下搜索<code>plugins</code></p><p>且<code>qApp-&gt;libraryPaths()</code>也会是本目录下的<code>plugins</code></p><p>但是，假如在exe同目录下没有<code>Qt5Core.dll</code>&#x2F;<code>Qt5Cored.dll</code>，就会自动从<code>Qt</code>安装目录下搜索正确的<code>plugins</code>下的dll</p><p>且<code>qApp-&gt;libraryPaths()</code>也会变成<code>&quot;D:/Qt/5.15.2/msvc2019_64/plugins&quot;</code>，离子谱</p><p>WTF，Core是定位符吗？</p><p>所以实际上正确的处理方案是，删除<code>Clion</code>自动生成的<code>CMakeLists.txt</code>中的<code>dll</code>复制部分的代码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#if (WIN32 AND NOT DEFINED CMAKE_TOOLCHAIN_FILE)</span><br><span class="hljs-comment">#    set(DEBUG_SUFFIX)</span><br><span class="hljs-comment">#    if (MSVC AND CMAKE_BUILD_TYPE MATCHES &quot;Debug&quot;)</span><br><span class="hljs-comment">#        set(DEBUG_SUFFIX &quot;d&quot;)</span><br><span class="hljs-comment">#    endif ()</span><br><span class="hljs-comment">#    set(QT_INSTALL_PATH &quot;$&#123;CMAKE_PREFIX_PATH&#125;&quot;)</span><br><span class="hljs-comment">#    if (NOT EXISTS &quot;$&#123;QT_INSTALL_PATH&#125;/bin&quot;)</span><br><span class="hljs-comment">#        set(QT_INSTALL_PATH &quot;$&#123;QT_INSTALL_PATH&#125;/..&quot;)</span><br><span class="hljs-comment">#        if (NOT EXISTS &quot;$&#123;QT_INSTALL_PATH&#125;/bin&quot;)</span><br><span class="hljs-comment">#            set(QT_INSTALL_PATH &quot;$&#123;QT_INSTALL_PATH&#125;/..&quot;)</span><br><span class="hljs-comment">#        endif ()</span><br><span class="hljs-comment">#    endif ()</span><br><span class="hljs-comment">#    if (EXISTS &quot;$&#123;QT_INSTALL_PATH&#125;/plugins/platforms/qwindows$&#123;DEBUG_SUFFIX&#125;.dll&quot;)</span><br><span class="hljs-comment">#        add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD</span><br><span class="hljs-comment">#                COMMAND $&#123;CMAKE_COMMAND&#125; -E make_directory</span><br><span class="hljs-comment">#                &quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;/plugins/platforms/&quot;)</span><br><span class="hljs-comment">#        add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD</span><br><span class="hljs-comment">#                COMMAND $&#123;CMAKE_COMMAND&#125; -E copy</span><br><span class="hljs-comment">#                &quot;$&#123;QT_INSTALL_PATH&#125;/plugins/platforms/qwindows$&#123;DEBUG_SUFFIX&#125;.dll&quot;</span><br><span class="hljs-comment">#                &quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;/plugins/platforms/&quot;)</span><br><span class="hljs-comment">#    endif ()</span><br><span class="hljs-comment">#    foreach (QT_LIB Core Gui Widgets)</span><br><span class="hljs-comment">#        add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD</span><br><span class="hljs-comment">#                COMMAND $&#123;CMAKE_COMMAND&#125; -E copy</span><br><span class="hljs-comment">#                &quot;$&#123;QT_INSTALL_PATH&#125;/bin/Qt5$&#123;QT_LIB&#125;$&#123;DEBUG_SUFFIX&#125;.dll&quot;</span><br><span class="hljs-comment">#                &quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;&quot;)</span><br><span class="hljs-comment">#    endforeach (QT_LIB)</span><br><span class="hljs-comment">#endif ()</span><br></code></pre></td></tr></table></figure><p>aaaaaaaa</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>[<a href="https://blog.csdn.net/poinsettia/article/details/129084744">windows] cmake 如何设置 需要使用的 dll_cmake添加dll-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/44784414/qt-gui-theme-looks-old-fashioned">c++ - Qt GUI主题看起来过时 - VoidCC — c++ - Qt GUI theme looks old-fashioned - Stack Overflow</a></p><p><a href="https://weikeup.medium.com/%E4%BD%BF%E7%94%A8-clion-%E9%96%8B%E7%99%BC-qt5-599784958c0a">使用 CLion 開發 Qt5. Build with CLion 2021.1 11.0.10 &amp; Qt… | by Weikeup | Medium</a></p><p><a href="https://doc.qt.io/qt-6/deployment-plugins.html">Deploying Plugins | Qt 6.7</a></p><p><a href="https://blog.csdn.net/xcksj888/article/details/134237540">Qt程序pro中如何设置运行时库的位置_qt的pro设置库路径-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>CMake</tag>
      
      <tag>Clion</tag>
      
      <tag>dll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何获取文件（夹）图标 without Cache</title>
    <link href="/2024/08/01/How-to-get-file-folder-icon/"/>
    <url>/2024/08/01/How-to-get-file-folder-icon/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要（迫真）"><a href="#前情提要（迫真）" class="headerlink" title="前情提要（迫真）"></a>前情提要（迫真）</h2><p>书接上回，我们已经介绍了如何设置文件夹图标，想必大家都意犹未尽</p><p>那么根据有<code>Set</code>必有<code>Get</code>定理，本节我们来讲讲图标的获取（on <code>Windows</code>）</p><p>众所周知，<code>Qt</code>是一个<code>Convenient</code>的<code>C++</code>库</p><p>So，长话短说，两行代码秒了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">QFileIconProvider iconPro;<br>QIcon icon = iconPro.<span class="hljs-built_in">icon</span>(dirPath);<br></code></pre></td></tr></table></figure><p>好的，请大家有序退场👋</p><blockquote><p> 新吃席观众还在懵逼，老吃席观众已经开始排排坐了：都知道笔者出手必有大坑</p></blockquote><h2 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h2><p>大家看看这是什么☝，老朋友了</p><p>缓存是个好东西啊，空间换时间，现代CPU都上到三级缓存了</p><blockquote><p>可是没有什么是永恒的，是非好坏、真假对错，甚至是这句话本身 —— MrBeanC</p></blockquote><p>和文件系统打交道，时效性确实不太能保证，无论是<code>HDD</code>亦或是<code>SSD</code>，在<code>Memory</code>面前就是弟弟</p><p>那么<code>Qt</code>给<code>QFileIconProvider</code>上缓存也不难理解了</p><h3 id="文件夹图标缓存"><a href="#文件夹图标缓存" class="headerlink" title="文件夹图标缓存"></a>文件夹图标缓存</h3><p>没错，在程序生命周期内，使用<code>QFileIconProvider::icon</code>获取文件夹图标，会在<strong>全局</strong>范围内进行缓存</p><p>无论后续文件夹图标是否改变，都只会返回第一次缓存的结果</p><h3 id="基操分割线"><a href="#基操分割线" class="headerlink" title="基操分割线"></a>基操分割线</h3><p>到目前为止，都是基操（基本操作）</p><p>但是捏，对于缓存这件事，<code>QFileIconProvider</code>的<a href="https://doc.qt.io/qt-5/qfileiconprovider.html">文档</a>里只字未提，甚至查不到<code>Cache</code>这个词</p><p>而且哈，这个类，也没有提供任何方法（method）来清除缓存或选择不缓存</p><p>No, Nothing</p><p>这或许就是无形的手吧.🤌</p><p>😠😾🤬💬🗯︎</p><h3 id="So-What"><a href="#So-What" class="headerlink" title="So What"></a>So What</h3><p>可能（不可能）有人觉得这没什么</p><p>万一，我是说万一哈，有这么一款软件，它的功能是修改文件夹图标</p><p>&#x2F;&#x2F; 源码级广告植入：<a href="https://github.com/MrBeanCpp/Dr-Folder">Dr.Folder</a></p><p>修改完成后，软件会重新获取并展示该图标（或者是不重启的情况下刷新）</p><p>然后假如获取的还是旧图标，你说这不完犊子了😑</p><h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>那没办法了，你仁我义（的反义词）</p><p>还是看看远方的<code>Windows API</code>吧，家人们</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QIcon <span class="hljs-title">getFileIcon</span><span class="hljs-params">(QString filePath)</span> </span>&#123;<br>    filePath = QDir::<span class="hljs-built_in">toNativeSeparators</span>(filePath); <span class="hljs-comment">// IMPORTANT: 否则会找不到文件</span><br><br>    <span class="hljs-built_in">CoInitialize</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// important for SHGetFileInfo，否则失败</span><br>    SHFILEINFO sfi;<br>    <span class="hljs-built_in">memset</span>(&amp;sfi, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(SHFILEINFO));<br><br>    QIcon icon;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">SHGetFileInfo</span>(filePath.<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>, &amp;sfi, <span class="hljs-built_in">sizeof</span>(SHFILEINFO), SHGFI_ICON)) &#123;<br>        icon = QtWin::<span class="hljs-built_in">fromHICON</span>(sfi.hIcon); <span class="hljs-comment">// 貌似Qt6删除了这个模块 哭</span><br>        <span class="hljs-built_in">DestroyIcon</span>(sfi.hIcon);<br>    &#125;<br>    <span class="hljs-built_in">CoUninitialize</span>();<br><br>    <span class="hljs-keyword">return</span> icon;<br>&#125;<br></code></pre></td></tr></table></figure><p>Okay，完美，兄弟们，可以获取到原汁原味的图标了</p><h3 id="小丑"><a href="#小丑" class="headerlink" title="小丑"></a>小丑</h3><p>好的，缓存是没缓存了，但是卡炸了</p><p>这波啊，这波是时间换时效</p><h3 id="系统级缓存（Attention）"><a href="#系统级缓存（Attention）" class="headerlink" title="系统级缓存（Attention）"></a>系统级缓存（Attention）</h3><p>注意，除了<code>Qt</code>内部的图标缓存外，<code>Windows</code>文件系统也会对进行一定的缓存</p><p>参考我的上一篇文章：<a href="https://blog.cls.ink/2024/07/27/Set-Folder-Icon-and-Refresh-Cache-Immediately/#%E5%9B%BE%E6%A0%87%E7%BC%93%E5%AD%98">更改文件夹图标 &amp; 使其立即生效 - MrBeanC-Blog (cls.ink)</a></p><p>这么说吧，在一定时间内连续调用<code>SHGetFileInfo</code>，其速度会越来越快</p><p>但是第一次的调用时长可达数秒（最多）或数百毫秒（常见），这是不可接受的</p><h3 id="姜还是老的辣"><a href="#姜还是老的辣" class="headerlink" title="姜还是老的辣"></a>姜还是老的辣</h3><p>但是<code>QFileIconProvider</code>人家就不卡，这可和什么内部缓存无关啊</p><p>人家第一次获取就不卡的</p><p>而且比<code>SHGetFileInfo</code>快了一个数量级（WTF？）</p><p>这不科学吧，用了什么黑科技</p><h2 id="QFileIconProvider源码剖析"><a href="#QFileIconProvider源码剖析" class="headerlink" title="QFileIconProvider源码剖析"></a><code>QFileIconProvider</code>源码剖析</h2><blockquote><p>都把自己的心肺肠子翻出来，晒一晒，洗一洗，拾掇拾掇 —— 康熙</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QIcon <span class="hljs-title">QFileIconProviderPrivate::getIcon</span><span class="hljs-params">(<span class="hljs-type">const</span> QFileInfo &amp;fi)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> QGuiApplicationPrivate::<span class="hljs-built_in">platformTheme</span>()-&gt;<span class="hljs-built_in">fileIcon</span>(fi, <span class="hljs-built_in">toThemeIconOptions</span>(options));<br>&#125;<br><span class="hljs-function">QIcon <span class="hljs-title">QFileIconProvider::icon</span><span class="hljs-params">(<span class="hljs-type">const</span> QFileInfo &amp;info)</span> <span class="hljs-type">const</span> </span>&#123;<br>...<br>    QIcon retIcon = d-&gt;<span class="hljs-built_in">getIcon</span>(info);<br>    <span class="hljs-keyword">if</span> (!retIcon.<span class="hljs-built_in">isNull</span>())<br>        <span class="hljs-keyword">return</span> retIcon;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到实现细节隐藏在了<code>platformTheme()-&gt;fileIcon()</code></p><p>这也是<code>Qt</code>实现跨平台的秘诀：每个平台写一份代码</p><p>这里我们来重点关注一下<code>Windows</code>的实现（<code>qtbase/src/plugins/platforms/windows/qwindowstheme.cpp</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QIcon <span class="hljs-title">QWindowsTheme::fileIcon</span><span class="hljs-params">(<span class="hljs-type">const</span> QFileInfo &amp;fileInfo, QPlatformTheme::IconOptions iconOptions)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">QIcon</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">QWindowsFileIconEngine</span>(fileInfo, iconOptions));<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里不禁感叹：妙哉妙哉</p><p>原来我们通过<code>QFileIconProvider::icon</code>获取的图标里并没有真正的图像数据，而是封装了一个<code>Engine</code>（用于获取图标的中介）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QWindowsFileIconEngine</span> : <span class="hljs-keyword">public</span> QAbstractFileIconEngine<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">QWindowsFileIconEngine</span><span class="hljs-params">(<span class="hljs-type">const</span> QFileInfo &amp;info, QPlatformTheme::IconOptions opts)</span> :</span><br><span class="hljs-function">        QAbstractFileIconEngine(info, opts) &#123;</span>&#125;<br><br>    <span class="hljs-function">QList&lt;QSize&gt; <span class="hljs-title">availableSizes</span><span class="hljs-params">(QIcon::Mode = QIcon::Normal, QIcon::State = QIcon::Off)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> QWindowsTheme::<span class="hljs-built_in">instance</span>()-&gt;<span class="hljs-built_in">availableFileIconSizes</span>(); &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function">QString <span class="hljs-title">cacheKey</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function">QPixmap <span class="hljs-title">filePixmap</span><span class="hljs-params">(<span class="hljs-type">const</span> QSize &amp;size, QIcon::Mode mode, QIcon::State)</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>怪不得<code>.icon()</code>获取图标那么快呢，敢情是没有真数据啊</p><p>好的，盯帧一下我们就能发现<code>filePixmap</code>这个函数才是真正的重点</p><h3 id="QWindowsFileIconEngine-filePixmap"><a href="#QWindowsFileIconEngine-filePixmap" class="headerlink" title="QWindowsFileIconEngine::filePixmap"></a>QWindowsFileIconEngine::filePixmap</h3><h4 id="文件夹缓存"><a href="#文件夹缓存" class="headerlink" title="文件夹缓存"></a>文件夹缓存</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> cacheableDirIcon = <span class="hljs-built_in">fileInfo</span>().<span class="hljs-built_in">isDir</span>() &amp;&amp; !<span class="hljs-built_in">fileInfo</span>().<span class="hljs-built_in">isRoot</span>();<br><span class="hljs-keyword">if</span> (cacheableDirIcon) &#123;<br>    <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mx)</span></span>;<br>    <span class="hljs-type">int</span> iIcon = (useDefaultFolderIcon &amp;&amp; defaultFolderIIcon &gt;= <span class="hljs-number">0</span>) ? defaultFolderIIcon<br>         : **dirIconEntryCache.<span class="hljs-built_in">object</span>(filePath);<br>    <span class="hljs-keyword">if</span> (iIcon) &#123;<br>        QPixmapCache::<span class="hljs-built_in">find</span>(<span class="hljs-built_in">dirIconPixmapCacheKey</span>(iIcon, iconSize, requestedImageListSize), &amp;pixmap);<br>        <span class="hljs-keyword">if</span> (pixmap.<span class="hljs-built_in">isNull</span>()) <span class="hljs-comment">// Let&#x27;s keep both caches in sync</span><br>            dirIconEntryCache.<span class="hljs-built_in">remove</span>(filePath);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> pixmap;<br>    &#125;<br>&#125;<br>...<br>...<br><span class="hljs-keyword">if</span> (cacheableDirIcon) &#123;<br>    <span class="hljs-function">QMutexLocker <span class="hljs-title">locker</span><span class="hljs-params">(&amp;mx)</span></span>;<br>    QPixmapCache::<span class="hljs-built_in">insert</span>(key, pixmap);<br>    dirIconEntryCache.<span class="hljs-built_in">insert</span>(filePath, FakePointer&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">create</span>(info.iIcon));<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里我们可以发现：</p><ul><li>只对文件夹（Directory）进行了缓存（cacheableDirIcon），没有缓存文件（file）； &#x2F;&#x2F; Why?</li><li>使用了<code>QPixmapCache</code>进行缓存，而且是<code>::insert</code>静态方法</li></ul><p>静态方法说明是全局状态</p><div class="note note-info">            <p>[<strong>现在可以公开的情报</strong>]</p><p>！！因此，可以使用<code>QPixmapCache::clear()</code>来清除<code>QFileIconProvider</code>的缓存</p>          </div><p>😑还得是源码</p><h4 id="深入虎穴"><a href="#深入虎穴" class="headerlink" title="深入虎穴"></a>深入虎穴</h4><p>Okay，都到这里了，让我们看看<code>Qt</code>到底用了什么方法来获取图标吧</p><p><code>filePixmap()</code>中调用了以下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">shGetFileInfoBackground</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;fileName, DWORD attributes,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    SHFILEINFO *info, UINT flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    qint64 timeOutMSecs = <span class="hljs-number">5000</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> QShGetFileInfoThread *getFileInfoThread = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (!getFileInfoThread) &#123;<br>        getFileInfoThread = <span class="hljs-keyword">new</span> QShGetFileInfoThread;<br>        getFileInfoThread-&gt;<span class="hljs-built_in">start</span>(); <span class="hljs-comment">//启动线程，调用run()函数</span><br>    &#125;<br><br>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function">QShGetFileInfoParams <span class="hljs-title">params</span><span class="hljs-params">(fileName, attributes, info, flags, &amp;result)</span></span>;<br>    <span class="hljs-keyword">if</span> (!getFileInfoThread-&gt;<span class="hljs-built_in">runWithParams</span>(&amp;params, timeOutMSecs)) &#123;<br>        <span class="hljs-comment">// Cancel and reset getFileInfoThread. It&#x27;ll</span><br>        <span class="hljs-comment">// be reinitialized the next time we get called.</span><br>        getFileInfoThread-&gt;<span class="hljs-built_in">cancel</span>();<br>        getFileInfoThread = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-built_in">qWarning</span>().<span class="hljs-built_in">noquote</span>() &lt;&lt; <span class="hljs-string">&quot;SHGetFileInfo() timed out for &quot;</span> &lt;&lt; fileName;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先这个命名非常有意思，为什么是<strong>Background</strong>呢，难道是多线程？（第一行代码就结束了比赛</p><p>好吧，关注点难道不应该是<code>shGetFileInfoBackground</code>把<code>SHGetFileInfo</code>API写脸上了吗</p><p>这里有一点比较疑惑：为什么<code>Qt</code>在这里要使用多线程呢？</p><p>首先，这是一个<code>filePixmap()</code>是一个同步函数，也没法异步返回</p><p>其次，在主线程中调用了<code>m_doneCondition.wait</code>进行等待，等待被子线程唤醒或超时（5s），意味着还是会阻塞主线程，所以子线程有什么意义</p><p>其实最主要的意义就是这个<strong>超时</strong>机制，由于前面说的<code>SHGetFileInfo</code>可能非常耗时，我们不能无限期等待下去（GUI会卡死）</p><p>所以利用<strong>多线程 + 条件变量</strong>的方式实现<strong>超时机制</strong></p><p>仅单线程的话，控制权会陷入API调用<code>SHGetFileInfo</code>，无法退出</p><p>下面附上<code>QShGetFileInfoThread</code>的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QShGetFileInfoThread</span> : <span class="hljs-keyword">public</span> QThread &#123;<br>...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        m_init = <span class="hljs-built_in">CoInitializeEx</span>(<span class="hljs-literal">nullptr</span>, COINIT_MULTITHREADED);<br><br>        <span class="hljs-function">QMutexLocker <span class="hljs-title">readyLocker</span><span class="hljs-params">(&amp;m_readyMutex)</span></span>;<br>        <span class="hljs-keyword">while</span> (!m_cancelled.<span class="hljs-built_in">loadRelaxed</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (!m_params &amp;&amp; !m_cancelled.<span class="hljs-built_in">loadRelaxed</span>()<br>                &amp;&amp; !m_readyCondition.<span class="hljs-built_in">wait</span>(&amp;m_readyMutex, <span class="hljs-built_in">QDeadlineTimer</span>(<span class="hljs-number">1000ll</span>)))<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span> (m_params) &#123;<br>                <span class="hljs-type">const</span> QString fileName = m_params-&gt;fileName;<br>                SHFILEINFO info;<br>                <span class="hljs-type">const</span> <span class="hljs-type">bool</span> result = <span class="hljs-built_in">SHGetFileInfo</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *&gt;(fileName.<span class="hljs-built_in">utf16</span>()),<br>                                                  m_params-&gt;attributes, &amp;info, <span class="hljs-built_in">sizeof</span>(SHFILEINFO),<br>                                                  m_params-&gt;flags);<br>                m_doneMutex.<span class="hljs-built_in">lock</span>();<br>                <span class="hljs-keyword">if</span> (!m_cancelled.<span class="hljs-built_in">loadRelaxed</span>()) &#123;<br>                    *m_params-&gt;result = result;<br>                    <span class="hljs-built_in">memcpy</span>(m_params-&gt;info, &amp;info, <span class="hljs-built_in">sizeof</span>(SHFILEINFO));<br>                &#125;<br>                m_params = <span class="hljs-literal">nullptr</span>;<br><br>                m_doneCondition.<span class="hljs-built_in">wakeAll</span>();<br>                m_doneMutex.<span class="hljs-built_in">unlock</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (m_init != S_FALSE)<br>            <span class="hljs-built_in">CoUninitialize</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">runWithParams</span><span class="hljs-params">(QShGetFileInfoParams *params, qint64 timeOutMSecs)</span> </span>&#123;<br>        <span class="hljs-function">QMutexLocker <span class="hljs-title">doneLocker</span><span class="hljs-params">(&amp;m_doneMutex)</span></span>;<br><br>        m_readyMutex.<span class="hljs-built_in">lock</span>();<br>        m_params = params;<br>        m_readyCondition.<span class="hljs-built_in">wakeAll</span>();<br>        m_readyMutex.<span class="hljs-built_in">unlock</span>();<br><br>        <span class="hljs-keyword">return</span> m_doneCondition.<span class="hljs-built_in">wait</span>(&amp;m_doneMutex, <span class="hljs-built_in">QDeadlineTimer</span>(timeOutMSecs));<br>    &#125;<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Why-QFileIconProvider-Fast"><a href="#Why-QFileIconProvider-Fast" class="headerlink" title="Why QFileIconProvider Fast"></a>Why QFileIconProvider Fast</h2><p>好的，接下来还剩下一个问题，为什么用<code>QFileIconProvider</code> 比直接用<code>SHGetFileInfo</code>更快（在加载大量图标的时候）</p><p>首先就是内部缓存机制，其次是延迟获取机制（先返回QIcon + Engine，在合适的时候再调用<code>filePixmap</code>）</p><p>这样可以结合Qt的绘制机制进行一些奇怪的优化（多线程、局部重绘之类的）</p><p>以上，我猜的</p><p>好的，Peace</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/MrBeanCpp/Dr-Folder">MrBeanCpp&#x2F;Dr-Folder: Select icons for your software folders automatically. (github.com)</a></p><p><a href="https://blog.cls.ink/2024/07/27/Set-Folder-Icon-and-Refresh-Cache-Immediately">更改文件夹图标 &amp; 使其立即生效 - MrBeanC-Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
      <tag>Icon</tag>
      
      <tag>QFileIconProvider</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更改文件夹图标 &amp; 使其立即生效</title>
    <link href="/2024/07/27/Set-Folder-Icon-and-Refresh-Cache-Immediately/"/>
    <url>/2024/07/27/Set-Folder-Icon-and-Refresh-Cache-Immediately/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，人类更倾向于看图而非文字</p><p>图片所包含的信息量更大，也更容易接受</p><p>（这就是大家不喜欢读书的原因ba）</p><p>言归正传，（这就是大家喜欢<code>GUI</code>的原因ba）</p><p>图像固然重要，但文字也不可或缺</p><p>于是乎，本着我都要的心态，现代图形界面中的 文件 &amp; 文件夹 都被设计为：<strong>图标 + 文字描述</strong> 的形式</p><p><img src="https://www.folderico.com/images/screenshot-1.png" alt="from folderico.com"></p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>系统原生的文件夹图标是个黄色的“文件夹”（物理）</p><p>如果所有文件夹的图标长得都一样，那么也就失去了传递特异信息的能力</p><p>由于文字的解读要更加困难（后天能力），因此在众多千篇一律的文件夹中快速定位目标则成了一件烦人事</p><h3 id="人云"><a href="#人云" class="headerlink" title="人云"></a>人云</h3><p>这时候，有的同学要说了：要什么<code>GUI</code>，我都是直接<code>CLI</code>的…</p><p>打住打住，下一位</p><p>同学B：对于<code>Windows</code>，可以直接在<strong>资源管理器</strong>中（需要焦点）直接输入想要文件（夹）名称（支持输入法）即可定位</p><p>这位同学说得好，不过有了更差异化的图标便更能锦上添花 (๑¯ω¯๑)</p><h2 id="设置文件夹图标"><a href="#设置文件夹图标" class="headerlink" title="设置文件夹图标"></a>设置文件夹图标</h2><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>属性-自定义-更改图标<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[在 Windows 11 上更改文件夹图标的 5 种方法（和 3 个提示）-云东方 (yundongfang.com)](https://www.yundongfang.com/Yun147646.html)">[1]</span></a></sup></p><p>相信大家早就知道了，跳过跳过（skip）</p><p><img src="https://www.yundongfang.com/wp-content/uploads/2022/04/004-49.png" alt="属性-自定义-更改图标"></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>咳咳，身为<strong>Programmer</strong>，我们还是来讨论一下更深入♂♀的内容吧</p><p>そもそも，说到底，<code>Windows</code>设置文件夹图标的原理究竟是什么</p><p>本质上就是在这个文件夹内新建了一个<code>desktop.ini</code>（之前的文章也提到过：<a href="https://blog.cls.ink/2024/04/02/Windows-%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%80%E6%9E%90/#%E6%89%8B%E5%8A%A8%E6%96%B0%E5%BB%BA">Windows 系统级个人文件夹 vs OneDrive简析</a>）</p><p>这个文件的属性比较特殊：<code>SH</code>，aka.<code>System + Hide</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[.ShellClassInfo]</span><br><span class="hljs-attr">IconResource</span>=xxx.ico,<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这里除了<code>.ico</code>文件，还可以是<code>exe</code>，<code>dll</code>等</p><p>我们可以通过以下代码来创建<code>desktop.ini</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">QString iniPath = folderPath + <span class="hljs-string">&quot;/desktop.ini&quot;</span>;<br><span class="hljs-function">QFile <span class="hljs-title">iniFile</span><span class="hljs-params">(iniPath)</span></span>;<br><span class="hljs-keyword">if</span> (iniFile.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text)) &#123;<br>    <span class="hljs-function">QTextStream <span class="hljs-title">out</span><span class="hljs-params">(&amp;iniFile)</span></span>;<br>    out &lt;&lt; <span class="hljs-string">&quot;[.ShellClassInfo]&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    out &lt;&lt; <span class="hljs-string">&quot;IconResource=&quot;</span> &lt;&lt; iconPath &lt;&lt; <span class="hljs-string">&quot;,0&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    iniFile.<span class="hljs-built_in">close</span>();<br><br>    <span class="hljs-comment">// Set desktop.ini file attributes：隐藏和系统文件</span><br>    <span class="hljs-built_in">SetFileAttributesW</span>(iniPath.<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>(), FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);<br>&#125;<br></code></pre></td></tr></table></figure><p>当你满怀欣喜地盯着文件夹时，—— 文件夹也在盯着你</p><blockquote><p>Nothing happened.</p></blockquote><p>事情并没有这么简单，也许还缺了什么</p><p>请看<code>Windows</code>官方文档：<a href="https://learn.microsoft.com/zh-cn/windows/win32/shell/how-to-customize-folders-with-desktop-ini">如何使用 Desktop.ini 自定义文件夹</a></p><blockquote><p><strong>使用以下步骤通过 Desktop.ini 自定义文件夹的样式：</strong></p><ol><li>使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/Shlwapi/nf-shlwapi-pathmakesystemfoldera"><strong>PathMakeSystemFolder</strong></a> 使文件夹成为系统文件夹。 这将设置文件夹上的<strong>只读</strong>位，以指示应启用为 <code>Desktop.ini</code> 保留的特殊行为。 也可以使用 <strong>attrib +s</strong> <em>FolderName</em> 命令行将文件夹设为系统文件夹。</li><li>为文件夹创建一个 <code>Desktop.ini</code> 文件。 应将其标记为<em>隐藏</em>和<em>系统</em>，以确保对普通用户隐藏。</li><li>确保创建的 <code>Desktop.ini</code> 文件为 Unicode 格式。 这是存储可显示给用户的本地化字符串所必需的。</li></ol></blockquote><p>再看<code>FolderIco</code>的教程：<a href="https://www.folderico.com/what-if-custom-folder-icon-does-not-show.html">如果自定义文件夹图标不显示怎么办？ — What If the Custom Folder Icon Does Not Show?</a></p><blockquote><p>To keep folder icon changed must be met following conditions:</p><ul><li>Folder must have <strong>“Read Only”</strong> or <strong>“System”</strong> attribute, only these attributes allows to show customized folder icon.</li><li>Folder must contain “desktop.ini” file (This file contain path to the customized icon).</li></ul></blockquote><p>综上，我们还缺少一个条件：</p><ul><li>文件夹必须拥有 <strong>只读（R）</strong>或 <strong>系统（S）</strong>属性</li></ul><h4 id="Continue"><a href="#Continue" class="headerlink" title="Continue"></a>Continue</h4><p>我们可以在<code>cmd</code>中通过<code>attrib +R Folder</code>命令为其添加只读属性</p><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SetFileAttributesW</span>(folderPath.<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>(), FILE_ATTRIBUTE_READONLY);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Make this a system folder, so that we look for desktop.ini when we navigate to this folder.</span><br><span class="hljs-built_in">PathMakeSystemFolder</span>(folderPath.<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><p>大家看到这里可能一头雾水，别急</p><ul><li>首先，这可能很反直觉，但是文件夹上的<strong>只读（R）</strong>属性与文件不同，并不是“只读”的本意。”This attribute is not honored on directories. “ –  <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileattributesw#:~:text=FILE_ATTRIBUTE_READONLY">SetFileAttributesW - READONLY</a>. 在文件夹上，该属性和<code>S</code>属性一样，更多的这是一个标记，指示系统去进行一些特殊操作，例如：查找并加载<code>desktop.ini</code></li><li><code>PathMakeSystemFolder</code>，这个函数看起来是给文件夹赋予<code>System</code>属性，但实际上他会视情况，给予<code>R</code>或<code>S</code>属性，一般情况下是<code>Read-Only</code>属性。由于<code>Windows</code>是闭源系统，所以这里给出一个不知道是不是源码的<a href="https://github.com/selfrender/Windows-Server-2003/blob/5c6fe3db626b63a384230a1aa6b92ac416b0765f/shell/shlwapi/path.c#L3408">源码</a> （我看到了两份不同的实现，所以不确定代码是否可靠）</li></ul><p>好的，不管怎么样，到目前为止，我们已经达成了为文件夹自定义图标的所有条件。</p><h2 id="正片叠底"><a href="#正片叠底" class="headerlink" title="正片叠底"></a>正片叠底</h2><p>以上都是洒洒水，相信大家噼里啪啦、叽里呱啦就查出来了</p><h3 id="图标缓存"><a href="#图标缓存" class="headerlink" title="图标缓存"></a>图标缓存</h3><p>主要问题在于：为什么上述条件都达成之后，文件夹图标还是没有变化，或者说，<strong>延迟</strong>更新</p><h3 id="传统功夫（無駄）"><a href="#传统功夫（無駄）" class="headerlink" title="传统功夫（無駄）"></a>传统功夫（無駄）</h3><p>可能有聪明的同学会说了：这题我会，用这个函数通知系统更改即可，<code>SHChangeNotify(SHCNE_ATTRIBUTES, ...）</code></p><p>很遗憾，起码对于<code>Windows 11</code>的文件夹来说，该函数没有任何鸟用</p><p>无论是：<code>SHCNE_ATTRIBUTES</code>、<code>SHCNE_UPDATEITEM</code> 或是 <code>SHCNE_ASSOCCHANGED</code>，甚至是<code>SHCNE_ALLEVENTS</code></p><p>Even：<code>SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM)&quot;Environment&quot;, SMTO_ABORTIFHUNG, 5000, NULL)</code></p><p>都无济于事…</p><p>还有一些無駄的方法我也罗列一下：</p><ul><li><strong>ie4uinit.exe -show</strong></li><li><strong>nircmd.exe sysrefresh</strong> （第三方）</li></ul><p>参见：<a href="https://stackoverflow.com/questions/68941080/update-folder-icon-with-desktop-ini-instantly-change-c">windows - Update folder icon with desktop.ini &amp; instantly change (C++) - Stack Overflow</a></p><blockquote><p>NO it doesn’t work at all. 5 hour in computer during the night works as mirage ——  <a href="https://stackoverflow.com/questions/6464147/how-can-i-immediately-reload-a-folder-icon-when-desktop-ini-is-changed#:~:text=1-,NO,-it%20doesn%27t%20work">Piotr Sydow</a></p></blockquote><p>以上方法都无法<strong>立即</strong>刷新图标缓存（通常在几分钟后刷新）</p><h3 id="暴力美学（保底）"><a href="#暴力美学（保底）" class="headerlink" title="暴力美学（保底）"></a>暴力美学（保底）</h3><p>当然，我们都知道，重启能解决90%问题</p><p>是的没错，重启<strong>资源管理器（explorer.exe）</strong>可以解决这个问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill /f /im explorer.exe<br>start explorer<br></code></pre></td></tr></table></figure><p>BUT：</p><ol><li>重启并不能算立即</li><li>用户体验，非常非常非常非常，<strong>BAD</strong>，納得できない</li></ol><p>从人机交互和产品设计角度来说，非常失败，无法接受，仅此一项就会让用户流失</p><p>更不用说已经有软件能够做到不重启的情况下立即刷新 - <a href="https://www.folderico.com/">FolderIco</a></p><p>ta 能做到，就说明：理论存在，实践开始</p><h4 id="毁灭"><a href="#毁灭" class="headerlink" title="毁灭"></a>毁灭</h4><p>还有一种方法在民间广为流传，实属暴力楷模：<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[windows清理图标缓存并重新加载_windows 图标缓存刷新-CSDN博客](https://blog.csdn.net/luoyayun361/article/details/79228390)">[2]</span></a></sup></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">rem 关闭Windows外壳程序explorer<br>taskkill /f /im explorer.exe<br>rem 清理系统图标缓存数据库<br>attrib -h -s -r <span class="hljs-string">&quot;%userprofile%\AppData\Local\IconCache.db&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\IconCache.db&quot;</span><br>attrib /s /d -h -s -r <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\*&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_32.db&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_96.db&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_102.db&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_256.db&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_1024.db&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_idx.db&quot;</span><br>del /f <span class="hljs-string">&quot;%userprofile%\AppData\Local\Microsoft\Windows\Explorer\thumbcache_sr.db&quot;</span><br>rem 清理 系统托盘记忆的图标<br><span class="hljs-built_in">echo</span> y|reg delete <span class="hljs-string">&quot;HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify&quot;</span> /v IconStreams<br><span class="hljs-built_in">echo</span> y|reg delete <span class="hljs-string">&quot;HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\TrayNotify&quot;</span> /v PastIconsStream<br>rem 重启Windows外壳程序explorer<br>start explorer<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>直接删掉所有缓存文件和注册表项（逼<code>Windows</code>重建），并重启资源管理器</p>          </div><p>哦，我的老天爷啊</p><p>杀鸡焉用牛刀，太不优雅了吧，不到万不得已并不建议使用 -_-||</p><h3 id="优雅而精准"><a href="#优雅而精准" class="headerlink" title="优雅而精准"></a>优雅而精准</h3><p><strong>FolderIco</strong>已经向我们证明了，存在一种方案，既不需要删除文件，也不需要重启资源管理器，就能刷新图标缓存的方案</p><p>虽然问题在于这是闭源软件，看不到源码呜呜</p><p>&#x2F;&#x2F; 难道要反编译嘛，aaa</p><p>不，不可能！</p><p>要不发个邮件好了，啊，在那之前，一定有办法，o(╥﹏╥)o</p><h4 id="SHGetSetFolderCustomSettings"><a href="#SHGetSetFolderCustomSettings" class="headerlink" title="SHGetSetFolderCustomSettings"></a>SHGetSetFolderCustomSettings</h4><p>经过了七七八十一天的搜索，在见识到了<code>GPT-4o</code>和<code>Claude 3.5</code>对于<code>Windows API</code>的无力之后</p><p>我终于找到了，那本真经：<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlobj_core/nf-shlobj_core-shgetsetfoldercustomsettings"><code>SHGetSetFolderCustomSettings</code></a></p><p>还得是：<a href="https://stackoverflow.com/questions/45921769/how-to-refresh-the-folder-icon-instantly-in-windows#:~:text=2-,I%20did%20some%20further,-tests%20where%20I">Stackoverflow</a></p><p>节选评论：</p><blockquote><p>I did some further tests where I found that the supposed “catch all” <code>SHCNE_ASSOCCHANGED</code> is unreliable aswell. But <a href="https://stackoverflow.com/a/19440996/7571258">SHGetSetFolderCustomSettings()</a> always updates the icon immediately (despite being a deprecated API since Win XP SP3)!</p></blockquote><blockquote><p>I also used <code>SHChangeNotify()</code> and it’s not reliable in Win10. Sometimes it works, sometimes not. It doesn’t change it immediately but takes 1 minutes or so.</p></blockquote><blockquote><p>Yesterday I played around with <code>SHCNE_UPDATEITEM</code> but couldn’t get consistent results. Sometimes it would update the folder icon, sometimes not. I also tried to add <code>SHCNF_FLUSH</code> and <code>SHCNE_UPDATEDIR</code> but the result was still unreliable.</p></blockquote><p><code>SHGetSetFolderCustomSettings</code>是专门用于读取和写入<code>desktop.ini</code>的函数</p><p>（不过为什么<code>GPT</code>不告诉我，aaaaa）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFolderIcon</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;folderPath, <span class="hljs-type">const</span> QString &amp;iconPath, <span class="hljs-type">int</span> iconIndex = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    SHFOLDERCUSTOMSETTINGS fcs = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 初始化所有成员为0</span><br>    fcs.dwSize = <span class="hljs-built_in">sizeof</span>(SHFOLDERCUSTOMSETTINGS);<br>    fcs.dwMask = FCSM_ICONFILE;<br>    <span class="hljs-keyword">auto</span> iconWStr = iconPath.<span class="hljs-built_in">toStdWString</span>(); <span class="hljs-comment">// IMPORTANT: 不能写为 iconPath.toStdWString().c_str()，因为返回的是临时对象，导致指针无效</span><br>    fcs.pszIconFile = <span class="hljs-built_in">LPWSTR</span>(iconWStr.<span class="hljs-built_in">c_str</span>());<br>    fcs.cchIconFile = <span class="hljs-number">0</span>;<br>    fcs.iIconIndex = iconIndex;<br><br>    <span class="hljs-comment">// 这里返回临时对象指针没事，因为语句没结束不会被释放</span><br>    HRESULT hr = <span class="hljs-built_in">SHGetSetFolderCustomSettings</span>(&amp;fcs, folderPath.<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>(), FCS_FORCEWRITE);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FAILED</span>(hr)) &#123;<br>        <span class="hljs-built_in">qWarning</span>() &lt;&lt; <span class="hljs-string">&quot;Failed to set folder icon&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>游戏结束，根本不需要自行新建<code>desktop.ini</code>巴拉的，直接包办</p><h4 id="语法小细节"><a href="#语法小细节" class="headerlink" title="语法小细节"></a>语法小细节</h4><p>这里有个细节坑了我一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> iconWStr = iconPath.<span class="hljs-built_in">toStdWString</span>();<br>fcs.pszIconFile = <span class="hljs-built_in">LPWSTR</span>(iconWStr.<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><p>这里不能缩写为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">fcs.pszIconFile = <span class="hljs-built_in">LPWSTR</span>(iconPath.<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><p>否则，最终写入<code>desktop.ini</code>中的路径会变得很奇怪</p><p>因为<code>.toStdWString()</code>返回的是一个临时对象，那么<code>.toStdWString().c_str()</code>也就是一个临时对象的指针</p><p>随时会被销毁（语句结束后）</p><p>所以最终就会造成野指针问题，变成随机字符串，bomb（快用<code>Rust</code>）</p><p>那么又有小盆友要问了，为什么这句没事</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SHGetSetFolderCustomSettings</span>(&amp;fcs, folderPath.<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>(), FCS_FORCEWRITE);<br></code></pre></td></tr></table></figure><p>因为临时对象在语句结束后销毁，所以在<code>SHGetSetFolderCustomSettings</code>执行过程中都万事大吉</p><h4 id="Why-SHGetSetFolderCustomSettings"><a href="#Why-SHGetSetFolderCustomSettings" class="headerlink" title="Why SHGetSetFolderCustomSettings"></a>Why SHGetSetFolderCustomSettings</h4><p>好的，那么，凭什么，为什么<code>SHGetSetFolderCustomSettings</code>可以做到立即刷新，他调用了什么<code>API</code>，做了什么操作呢？</p><p>什么，你说你不想知道，诶，别走啊</p><p>咳咳，留下来的都是好饱饱</p><p>好吧，答案是：很遗憾，<code>Windows</code>是闭源操作系统，hhhhhhhhhh</p><p>o(╥﹏╥)o</p><p>真滴米有办法了吗，不行，我去<code>GitHub</code>上搜一搜</p><p>你别说，还真有：<a href="https://github.com/tongzx/nt5src/blob/master/Source/XPSP1/NT/shell/shell32/fldsets.c#L492">nt5src&#x2F;Source&#x2F;XPSP1&#x2F;NT&#x2F;shell&#x2F;shell32&#x2F;fldsets.c at master · tongzx&#x2F;nt5src (github.com)</a></p><p>听说是<code>XP</code>代码泄露</p><p>不过呢，不知道是版本太老，还是可信度太低</p><p>我在代码里并没有看到什么特殊操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">...<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">SUCCEEDED</span>(hret) &amp;&amp; (dwReadWrite &amp; FCS_FORCEWRITE))<br>&#123;<br>    <span class="hljs-comment">// Make desktop.ini hidden</span><br>    <span class="hljs-built_in">SetFileAttributes</span>(szIniFile, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);<br>    <span class="hljs-comment">// Make this a system folder, so that we look for desktop.ini when we navigate to this folder.</span><br>    <span class="hljs-built_in">PathMakeSystemFolder</span>(pszPath);<br>&#125;<br>....<br></code></pre></td></tr></table></figure><p>都是我们的基操</p><p>所以到底为啥啊，aaaaaa</p><p><code>Windows</code>十大未解之谜，看来只能入职微软了</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://cloud.tencent.com/developer/ask/sof/107609033">用desktop.ini更新文件夹图标&amp;立即更改(C++)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://stackoverflow.com/questions/33309382/changing-desktop-ini-doesnt-update-folder-icon-automatically-in-windows">batch file - Changing desktop.ini doesn’t update folder icon automatically in Windows - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/68941080/update-folder-icon-with-desktop-ini-instantly-change-c">windows - Update folder icon with desktop.ini &amp; instantly change (C++) - Stack Overflow</a></p><p><a href="https://superuser.com/questions/499078/refresh-icon-cache-without-rebooting/499083">windows - Refresh Icon Cache Without Rebooting - Super User</a></p><p><a href="https://stackoverflow.com/questions/45921769/how-to-refresh-the-folder-icon-instantly-in-windows">c++ - How to refresh the folder icon instantly in Windows - Stack Overflow</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/shell/how-to-customize-folders-with-desktop-ini">如何使用 Desktop.ini 自定义文件夹 - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlwapi/nf-shlwapi-pathmakesystemfolderw">pathMakeSystemFolderW 函数 (shlwapi.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlobj_core/nf-shlobj_core-shchangenotify">SHChangeNotify 函数 (shlobj_core.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://www.folderico.com/what-if-custom-folder-icon-does-not-show.html">What If the Custom Folder Icon Does Not Show?</a></p><p><a href="https://github.com/tongzx/nt5src/tree/master">tongzx&#x2F;nt5src: Source code of Windows XP (NT5). Leaks are not from me. I just extracted the archive and cabinet files. (github.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlobj_core/nf-shlobj_core-shgetsetfoldercustomsettings">SHGetSetFolderCustomSettings 函数 (shlobj_core.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://blog.csdn.net/bankpan/article/details/17759633">如何改变文件夹的图标（未完成。。。。。。）-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/6464147/how-can-i-immediately-reload-a-folder-icon-when-desktop-ini-is-changed">windows - How can I immediately reload a folder icon when desktop.ini is changed - Stack Overflow</a></p><p><a href="https://github.com/selfrender/Windows-Server-2003/blob/5c6fe3db626b63a384230a1aa6b92ac416b0765f/shell/shlwapi/path.c#L3408">Windows-Server-2003&#x2F;shell&#x2F;shlwapi&#x2F;path.c at 5c6fe3db626b63a384230a1aa6b92ac416b0765f · selfrender&#x2F;Windows-Server-2003 (github.com)</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.yundongfang.com/Yun147646.html">在 Windows 11 上更改文件夹图标的 5 种方法（和 3 个提示）-云东方 (yundongfang.com)</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/luoyayun361/article/details/79228390">windows清理图标缓存并重新加载_windows 图标缓存刷新-CSDN博客</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
      <tag>Win11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMware虚拟机在后台运行时性能下降</title>
    <link href="/2024/07/16/VMware-Background-Performance-Down/"/>
    <url>/2024/07/16/VMware-Background-Performance-Down/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，World needs <code>Windows</code>. But <code>Linux</code> even matters. (Especially for developers)</p><p>鱼和熊掌能否兼得，也许可以小火慢煎</p><p>有的同学要说了：WSL！</p><p><code>WSL（Windows Subsystem for Linux）</code>，一听名字就感觉性能爆表</p><p>但是如果需要<strong>图形界面</strong>的话，WSL貌似不是特别方便</p><p>此时就需要经典虚拟机出场了，like <code>VMware</code></p><h2 id="主诉（性能下降）"><a href="#主诉（性能下降）" class="headerlink" title="主诉（性能下降）"></a>主诉（性能下降）</h2><p>一个经典的方案是：VSCode（Remote SSH）+ VMWare（Ubuntu）</p><p>我从没有发现其<strong>性能不佳</strong>，直到我开始怀念<code>RustRover (Jetbrains)</code>，但被<code>Jetbrains Gateway</code>的远程开发体验击溃后，我在虚拟机里安装了<code>Jetbrains for Linux</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">cargo clean<br>cargo build<br></code></pre></td></tr></table></figure><p>看着缩短了5倍的编译时长，我陷入了沉思</p><p>都是<code>Terminal</code>，都是<code>fish</code>，难不成<code>Jetbrains</code>有魔法，还是<code>Remote SSH</code>有大坑</p><p>&#x2F;&#x2F; 经测试：原生终端和<code>Jetbrains</code>终端性能一致 啊哈哈（尬）</p><p>我不经脊背发凉，没有了<code>VSCode Remote SSH</code>，我很难想象出一个替代方案进行远程开发</p><p>为此，我请到了著名<code>Linux</code>专家 - 侯同学，为大家进行<code>WSL + Remote SSH</code>的测试</p><p>Result：<code>WSL</code>原生终端与<code>Remote SSH</code>终端性能并无二异</p><p>看来<code>VSCode</code>不背这个锅，呼呼呼</p><h2 id="先做个检查吧"><a href="#先做个检查吧" class="headerlink" title="先做个检查吧"></a>先做个检查吧</h2><p>盯——（望闻问切）</p><p>好的，请问，<code>Jetbrains</code>终端和<code>VSCode Remote SSH</code>终端有什么不同</p><p>即答：后者是Windows物理机应用，此时，虚拟机运行于后台</p><p>这点其实非常重要，后台进程的优先级显然是低于前台的，（被调度到小核上之类的，CPU片减少之类的）</p><h2 id="切片（Test）"><a href="#切片（Test）" class="headerlink" title="切片（Test）"></a>切片（Test）</h2><p>Okay，我们在Remote SSH终端中输入<code>cargo build</code>，然后回到虚拟机，使其时刻保持在前台</p><p>Result：编译时长大大缩短，与原生终端无异</p><h2 id="破案"><a href="#破案" class="headerlink" title="破案"></a>破案</h2><p>正如我们所猜想的，在后台时，进程优先级下降，导致性能下降（5倍）</p><h2 id="药方"><a href="#药方" class="headerlink" title="药方"></a>药方</h2><p>能否设置虚拟机的进程优先级呢？答案是（薛定谔的）</p><p><img src="/img/image-20240716162912923.png" alt="优先级"></p><p>我们可以看到，右侧可以设置两种情况下的优先级：</p><ul><li>抓取的输入内容</li><li>取消抓取的输入内容</li></ul><p>好的，作为一个the local，我只能告诉你，我每个字都看得懂，But…</p><p>好吧，我们还是看看官方文档吧：</p><p><img src="/img/image-20240716163106655.png" alt="官方文档"></p><p>这个就好理解多了</p><p>I Guess：</p><ul><li>已抓取输入时：前台，获取焦点时</li><li>未抓取输入时：后台，无焦点时</li></ul><p>前者默认是<strong>正常</strong>，设置为<strong>高</strong>后，前台使用虚拟机的性能会提升</p><p>But，后者居然无法设置为<strong>高</strong>！</p><p>只有，<strong>正常</strong>和<strong>低</strong>两个选项，寄</p><p>&#x2F;&#x2F; 可能是为了不抢占物理机，但是居然不给个选项</p><p>有办法吗？也许可以强制设置进程优先级（Windows API）</p><p>参见：<a href="https://www.bilibili.com/read/cv21154645/">还在为大小核调度困扰？教你如何优化性能！ - 哔哩哔哩 (bilibili.com)</a></p><p>あの，我还是用<code>Linux Jetbrains</code>吧，（孩子们，我回来了）</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.bilibili.com/read/cv21154645/">还在为大小核调度困扰？教你如何优化性能！ - 哔哩哔哩 (bilibili.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VMware</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QSettings 无法正确处理包含斜杠的key</title>
    <link href="/2024/06/22/QSettings-%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%8C%85%E5%90%AB%E6%96%9C%E6%9D%A0%E7%9A%84key/"/>
    <url>/2024/06/22/QSettings-%E6%97%A0%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%8C%85%E5%90%AB%E6%96%9C%E6%9D%A0%E7%9A%84key/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>um，这次长话短说好吧</p><p>在<code>Qt</code>中，我们经常会用<code>QSettings</code>来读写配置文件，注册表等</p><h2 id="‘-‘：二义性"><a href="#‘-‘：二义性" class="headerlink" title="‘\‘：二义性"></a>‘\‘：二义性</h2><p>一般情况下没有什么问题，但是当key中包含反斜杠（<code>&#39;\&#39;</code>） or 斜杠（ <code>&#39;/&#39;</code>）的时候，就寄了</p><blockquote><p>文档：不要在节名或键名中使用斜杠（“&#x2F;”和“\”）；反斜杠字符用于分隔子键（见下文）。在 Windows 上，“\”被 QSettings 转换为“&#x2F;”，这使得它们相同</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">settings.<span class="hljs-built_in">setValue</span>(<span class="hljs-string">&quot;mainwindow/size&quot;</span>, win-&gt;<span class="hljs-built_in">size</span>());<br></code></pre></td></tr></table></figure><p>斜杠被用于分割子键，所以当<code>key</code>本身含有斜杠时（如：<code>&quot;C:\App\test.exe&quot;</code> in <code>MuiCache</code>），<code>QSettings</code>无法处理</p><ul><li>可能被认为是分割符</li><li>或者被转换为<code>&quot;C:/App/test.exe&quot;</code>（我遇到了）（找了好久bug 哭）</li></ul><p><em>（这其中的逻辑还没有非常搞清楚：为什么路径不会被认为是分割符 而是产生了一个<code>&quot;C:/App/test.exe&quot;</code>这样的<code>key</code>）</em></p><blockquote><p><strong>文档：</strong></p><p>请注意，如前所述，<code>QSettings</code> 使用反斜杠字符来分隔子项。因此，您无法读取或写入包含斜杠或反斜杠的 <code>Windows</code> 注册表项；</p><p>如果需要，您应该使用本机 <code>Windows API</code></p></blockquote><p>文档中说分割使用反斜杠（<code>&#39;\&#39;</code>），但是代码例子中用的是斜杠（ <code>&#39;/&#39;</code>），有点迷糊</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>分割子键使用：斜杠（ <code>&#39;/&#39;</code>）</li><li><code>key</code>中包含<code>&#39;\&#39;</code> or <code>&#39;/&#39;</code>（如 路径），就不要用<code>QSettings</code>了，改用<code>Windows API - RegOpenKeyEx</code></li><li>注意，我说的是<code>key</code>，not <code>value</code>，值中包含斜杠没有问题</li></ul><h3 id="peace"><a href="#peace" class="headerlink" title="peace"></a>peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://runebook.dev/zh/docs/qt/qsettings">Qt - QSettings (class) zh (runebook.dev)</a></p><p><a href="https://www.cnblogs.com/LyShark/p/17850186.html">C&#x2F;C++ 实现Windows注册表操作 - lyshark - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows窗口 相对置顶 技术简析</title>
    <link href="/2024/06/16/Windows%E7%AA%97%E5%8F%A3-%E7%9B%B8%E5%AF%B9%E7%BD%AE%E9%A1%B6-%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/"/>
    <url>/2024/06/16/Windows%E7%AA%97%E5%8F%A3-%E7%9B%B8%E5%AF%B9%E7%BD%AE%E9%A1%B6-%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Windows</code> &#x3D; <code>Window</code> * n</p><p>可见<code>Window（窗口）</code>这一概念在<code>Windows</code>操作系统中的核心地位</p><p>每个进程可以拥有多个窗口，而窗口间又可构成父子关系</p><p>如何管理<strong>图形用户界面（GUI）</strong>中这些纷繁复杂的窗口成了<code>Windows</code>绕不开的难题</p><p>管中窥豹，可见一斑</p><p>本文将讨论一个与窗口层级（Z-order）相关的经典问题：<strong>置顶</strong></p><h2 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h2><p>这是一个很常见的需求，<strong>置顶</strong>通常意味着将窗口Z序提升到最高</p><h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><p>mini模式网易云：</p><p><img src="/img/image-20240616143613946.png" alt="mini模式的网易云"></p><p>搜狗输入法：</p><p><img src="/img/image-20240616143935658.png" alt="搜狗输入法"></p><p><code>Windows</code>任务栏：</p><p><img src="/img/image-20240616144205063.png" alt="任务栏"></p><p>他们通常不会轻易被其他窗口覆盖，除非对方也是同样置顶的窗口（此时后来居上）</p><h3 id="Z-order"><a href="#Z-order" class="headerlink" title="Z-order"></a>Z-order</h3><p>其实，置顶并不仅仅是将Z序提升那么简单</p><p>从<code>Windows API</code>的视角来看，Z序可以大致分为两种：</p><ul><li><code>non-topmost</code>：非最顶层窗口（普通窗口）</li><li><code>topmost</code>：最顶层窗口，<em>The topmost window receives the highest rank and is the first window in the Z order.</em></li></ul><p>这两类层级存在阶级的隔阂，就算是普通窗口中的<code>TOP</code>，也永远在<code>TOPMOST</code>之下</p><p>当一个窗口获得焦点，成为活动窗口，例如用<strong>鼠标点击</strong>，那么该窗口会被设置为<code>TOP</code>（普通窗口中的最高层）</p><p>当你再次点击另一个窗口，原先的窗口就会被覆盖</p><p>而我们平时说的<code>置顶</code>，指的就是<code>TOPMOST</code>，这样可以确保在所有普通窗口之上，不被覆盖</p><h3 id="SetWindowPos-函数"><a href="#SetWindowPos-函数" class="headerlink" title="SetWindowPos  函数"></a>SetWindowPos  函数</h3><p>为了改变窗口Z序，我们需要用到<a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowpos"><code>SetWindowPos</code>函数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">BOOL <span class="hljs-title">SetWindowPos</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]           HWND hWnd,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] HWND hWndInsertAfter,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]           <span class="hljs-type">int</span>  X,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]           <span class="hljs-type">int</span>  Y,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]           <span class="hljs-type">int</span>  cx,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]           <span class="hljs-type">int</span>  cy,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]           UINT uFlags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数可以修改窗口的位置、大小和Z序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SetWindowPos</span>(hwnd, HWND_TOPMOST, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SWP_NOMOVE | SWP_NOSIZE);<br></code></pre></td></tr></table></figure><p>由于我们只想改变Z序，所以需要在最后一个<code>flags</code>参数写上<code>SWP_NOMOVE | SWP_NOSIZE</code>，表示忽略<code>X Y cx cy</code>四个参数</p><p>第二个参数<code>hWndInsertAfter</code>是我们要关注的重点，取值如下：</p><ul><li><strong>HWND_BOTTOM</strong>：将窗口放置在 Z 序的底部</li><li><strong>HWND_NOTOPMOST</strong>：将窗口放置在所有非最顶层窗口上方（即所有最顶层窗口后面），如果窗口已经是非最顶层窗口，则此标志无效</li><li><strong>HWND_TOP</strong>：将窗口放置在 Z 序的顶部 （指普通窗口）</li><li><strong>HWND_TOPMOST</strong>：将窗口放置在所有非最顶层窗口之上（高于TOP）</li></ul><p><strong>注意：</strong></p><ul><li><p><code>HWND_NOTOPMOST</code>比较特殊，他的作用貌似是把<code>TOPMOST</code>窗口拉下神坛，从贵族打为平民，不过瘦死的骆驼比马大，仍然是在普通窗口的TOP层级（但是可以被覆盖）</p></li><li><p>由于<code>TOPMOST</code>高人一等，所以有且只有<code>HWND_NOTOPMOST</code>能取消他们的特权层级，<code>HWND_TOP</code>和<code>HWND_BOTTOM</code>对<code>TOPMOST</code>窗口都不起作用</p></li><li><p>还有一点就是：<code>SetWindowPos</code>修改Z序不会对<strong>最小化</strong>的窗口生效，即便加上<code>SWP_SHOWWINDOW</code>也无效</p></li></ul><h3 id="置顶-vs-焦点"><a href="#置顶-vs-焦点" class="headerlink" title="置顶 vs 焦点"></a>置顶 vs 焦点</h3><p>刚刚说到，窗口被点击，获得焦点之后，会被设置为<code>TOP</code>，置顶于普通窗口之上</p><p>但是反过来，置顶并不意味着获取焦点，即便是<code>TOPMOST</code></p><p>同时，如果一个窗口没有焦点（非活动窗口），就无法被设置为<code>HWND_TOP</code>或<code>HWND_BOTTOM</code></p><p>官方文档中写道:</p><blockquote><p>若要使用 <strong>SetWindowPos</strong> 将窗口置于顶部，拥有该窗口的进程必须具有 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> 权限</p></blockquote><p>那么，<code>SetForegroundWindow</code>权限又是什么呢，我们可以查看官方文档：</p><p><img src="/img/image-20240616154207040.png" alt="SetForegroundWindow注解"></p><p>是不是眼花缭乱，总之呢，<code>Windows</code>严格限制了将窗口置顶或设为前台窗口（获取焦点）的权利</p><p>这是为了防止打扰用户的正常工作</p><p>经过实验，结论大致如下：</p><ul><li>当调用进程是前台进程时，可以使用<code>SetForegroundWindow</code>将其他窗口设置为前台窗口，即便前台锁没有过期（200s）</li><li>如果调用线程不是前台进程，大概率失败</li><li>当调用线程是前台进程，一般也不能使用<code>SetWindowPos</code>将窗口A设置为<code>TOP</code>，除非窗口A是活动窗口，类似于<code>BringWindowToTop</code>函数</li><li><code>TOPMOST</code>比较特殊，一般不需要特殊条件就可以设置（不愧是贵族）</li></ul><p>注意：文档中写道，即使进程满足这些条件，也有可能拒绝设置前台窗口的权利 \哭</p><h4 id="临时置顶"><a href="#临时置顶" class="headerlink" title="临时置顶"></a>临时置顶</h4><p>如果我们想要将一个窗口临时置顶，提升到用户面前，一般情况下<code>SetForegroundWindow</code>和<code>HWND_TOP</code>都不好使</p><p>此时我们可以采用一点<code>trick</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SetWindowPos</span>(hwnd, HWND_TOPMOST, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SWP_NOMOVE | SWP_NOSIZE);<br><span class="hljs-built_in">SetWindowPos</span>(hwnd, HWND_NOTOPMOST, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SWP_NOMOVE | SWP_NOSIZE);<br></code></pre></td></tr></table></figure><p>将窗口设置为<code>HWND_TOPMOST</code>再<code>HWND_NOTOPMOST</code>，完美实现了<code>TOP</code>的效果，hhhh，置顶之后也能被其他窗口覆盖</p><p>这里需要<strong>注意</strong>一点，窗口的Z序只有在焦点窗口改变时才会变化</p><p>也就是说：如果焦点在A窗口上，然后对B窗口采用<code>trick</code>（置顶并取消），此时B并没有获取焦点，所以无论如何点击A窗口，B还是在A之上，因为焦点没有变化，Z序也不会变化</p><p>不过只要你点击另外一个窗口，改变焦点，再点击A，B就会正常被A覆盖</p><h4 id="检测TOPMOST状态"><a href="#检测TOPMOST状态" class="headerlink" title="检测TOPMOST状态"></a>检测TOPMOST状态</h4><p>可以通过检测窗口的拓展样式中是否包含<code>WS_EX_TOPMOST</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isTopMost</span><span class="hljs-params">(HWND hwnd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (hwnd == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LONG_PTR style = <span class="hljs-built_in">GetWindowLongPtrW</span>(hwnd, GWL_EXSTYLE);<br>    <span class="hljs-keyword">return</span> style &amp; WS_EX_TOPMOST;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="设置前台窗口（置顶-焦点）"><a href="#设置前台窗口（置顶-焦点）" class="headerlink" title="设置前台窗口（置顶 + 焦点）"></a>设置前台窗口（置顶 + 焦点）</h4><p>刚刚说到，使用<code>SetForegroundWindow</code>设置前台窗口有很多限制，那么如何绕过这个限制，强行将某窗口（例如自身）设为前台窗口，然后吓用户一跳呢?</p><h5 id="最简单的办法莫过于：先最小化再显示"><a href="#最简单的办法莫过于：先最小化再显示" class="headerlink" title="最简单的办法莫过于：先最小化再显示"></a>最简单的办法莫过于：先最小化再显示</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">miniAndShow</span><span class="hljs-params">(HWND hwnd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">ShowWindow</span>(hwnd, SW_MINIMIZE); <span class="hljs-comment">//组合操作不要异步(ShowWindowAsync) 要等前一步完成</span><br>    <span class="hljs-built_in">ShowWindow</span>(hwnd, SW_NORMAL);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种方法的视觉体验不是很好（会突然消失再出现），不过可以作为保底（肯定能成）</p><h5 id="SwitchToThisWindow"><a href="#SwitchToThisWindow" class="headerlink" title="SwitchToThisWindow"></a>SwitchToThisWindow</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">SwitchToThisWindow</span>(hwnd, <span class="hljs-literal">false</span>); <span class="hljs-comment">//将自己的focus转移很easy 获取很困难//不能用于获取focus //该函数会造成任务栏闪烁不太好</span><br></code></pre></td></tr></table></figure><p>这个方法有时候能成 有时候不能 很玄学只能说</p><p>如果自身拥有焦点是可以easy转移出去的</p><h5 id="SetForegroundWindow-AttachThreadInput"><a href="#SetForegroundWindow-AttachThreadInput" class="headerlink" title="SetForegroundWindow + AttachThreadInput"></a>SetForegroundWindow + AttachThreadInput</h5><p>那么有没有更好的办法呢，那必然是有的，让我们再次把目光向<code>SetForegroundWindow</code>看齐</p><p>虽然在当前进程不是前台进程时，无法使用<code>SetForegroundWindow</code></p><p>但是通过使用 <code>AttachThreadInput</code> 函数，线程可以与另一个线程共享其输入状态 (例如键盘状态，当前焦点窗口)</p><p>例如将自身线程附加在前台线程上，假装自己也获取了焦点，就可以使用 <code>SetForegroundWindow</code>辣，嘿嘿</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getInputFocus</span><span class="hljs-params">(HWND hwnd)</span></span><br><span class="hljs-function"></span>&#123;<br>    HWND foreHwnd = <span class="hljs-built_in">GetForegroundWindow</span>(); <span class="hljs-comment">//获取前台窗口</span><br>    DWORD foreTID = <span class="hljs-built_in">GetWindowThreadProcessId</span>(foreHwnd, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取线程ID</span><br>    DWORD threadId = <span class="hljs-built_in">GetWindowThreadProcessId</span>(hwnd, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (foreHwnd == hwnd)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">bool</span> res = <span class="hljs-built_in">AttachThreadInput</span>(threadId, foreTID, TRUE); <span class="hljs-comment">//附加</span><br>    <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">false</span>) &#123; <span class="hljs-comment">//如果遇到系统窗口而失败 只能最小化再激活获取焦点</span><br>        <span class="hljs-built_in">miniAndShow</span>(hwnd); <span class="hljs-comment">//保底</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//SetForegroundWindow(foreHwnd); //刷新任务栏图标状态 防止保持焦点状态 不更新 导致点击后 最小化 而非获取焦点</span><br>        <span class="hljs-built_in">SetForegroundWindow</span>(hwnd);<br>        <span class="hljs-built_in">SetFocus</span>(hwnd); <span class="hljs-comment">//冗余操作</span><br>        <span class="hljs-built_in">AttachThreadInput</span>(threadId, foreTID, FALSE); <span class="hljs-comment">//解除附加</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大功告成</p><blockquote><p> 嘛，我只能说，<code>Windows API</code>之事，没有绝对逻辑，只有诶、啊、这、嘶、嘛</p></blockquote><h2 id="相对置顶"><a href="#相对置顶" class="headerlink" title="相对置顶"></a>相对置顶</h2><p>其实说了这么多，都是前置知识hhh，现在才是正片呜</p><p>说完了置顶（全局），我们来说说<strong>相对置顶</strong></p><p>所谓<strong>相对置顶</strong>，就是仅对于某个窗口保持置顶状态，而能被其他窗口正常覆盖</p><p>例如：窗口A始终在窗口B之上，但是窗口A和其他窗口的层级关系是正常的，不存在<code>TOPMOST</code>关系</p><p>有点像是：父窗口中的弹窗（子窗口）的那种感觉，或者是右键菜单</p><p><em>&#x2F;&#x2F; 什么，你问我相对置顶有什么用，试想一下你对着一张参考图在<code>blender</code>里建模，或是参考用户需求在<code>coding</code></em></p><p><img src="/img/image-20240616171554626.png" alt="对话框相对置顶"></p><p>对于从属同一个进程的子窗口来说，这固然很容易实现</p><p>那么对于跨进程的窗口，怎么办呢？</p><p>有人要说了：用<code>SetParent</code>函数将两个窗口建立父子关系不就好了</p><h3 id="SetParent"><a href="#SetParent" class="headerlink" title="SetParent"></a>SetParent</h3><p>想法是好的，但是<code>SetParent</code>跨进程设置父子关系貌似并不简单，直接调用没有任何效果</p><p>即便成功了之后，也会因为消息循环同步等问题出现各种bug</p><p>参见：</p><p><a href="https://blog.csdn.net/qq_59075481/article/details/133581281">SetParent 函数修改父窗口的误区-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_39636857/article/details/117270299">c语言跨进程回调函数,使用 SetParent 跨进程设置父子窗口时的一些问题（小心卡死）…-CSDN博客</a></p><p>所以最终并没有采用这种方案</p><h3 id="Dynamic-Z-order"><a href="#Dynamic-Z-order" class="headerlink" title="Dynamic Z-order"></a>Dynamic Z-order</h3><p>那么我们只能在保持窗口独立性的情况下，动态地去更新Z序了</p><p>这里有两种方案：</p><p><em>假定想要让自身窗口（me）相对置顶于目标窗口（target），设其他窗口为 others</em></p><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><ul><li>若前台窗口是<code>target</code>，则让<code>me</code><strong>临时置顶</strong></li><li>若前台窗口是<code>others</code>或<code>me</code>，无需任何操作，因为<strong>临时置顶</strong>后会恢复为普通层级</li></ul><p>这种方案存在一些问题，例如<code>target</code>最大化和取消最大化时，以及其他一些操作时，可能导致Z序变化，导致<code>me</code>被<code>target</code>覆盖</p><p>pass</p><h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><ul><li>若前台窗口是<code>target</code>，则让<code>me</code><strong>全局置顶</strong>（<code>TOPMOST</code>）</li><li>若前台窗口是<code>others</code>，则让<code>me</code><strong>取消置顶</strong>（<code>NOTOPMOST</code>），使其可以正常被<code>others</code>覆盖；<br>注意，由于检测时机的问题，取消置顶之后<code>me</code>被设置为<code>TOP</code>，仍然在<code>others</code>之上；<br>此时需要设置<code>others</code>的层级为<code>TOP</code>（<code>others</code>是活动窗口，所以可以成功）</li><li>若前台窗口是<code>me</code>，不执行任何操作</li></ul><p>当然，更进一步，我们需要监视<code>target</code>的最小化、显示、移动、销毁等事件来执行<code>me</code>的相应操作，使其更像一个子窗口</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>好的，Z序调整的算法解决了，那么如何检测各种窗口的状态呢？例如，前台窗口的变化</p><p><code>Windows</code>是基于消息的操作系统，我们可以使用<code>Hook</code>技术监听或拦截消息（事件）</p><p>常用的有：<code>SetWindowsHookEx</code> 和 <code>SetWinEventHook</code> </p><p>区别大致在于：</p><ul><li><code>SetWindowsHookEx</code>更为底层，功能更强大（例如拦截或修改消息），但可能需要dll<br>参见我的另一篇blog：<a href="https://blog.cls.ink/2022/04/07/Windows-Hook-%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/">Windows Hook 技术浅析 - MrBeanC-Blog (cls.ink)</a></li><li><code>SetWinEventHook</code>更高级，监听的是事件（不是消息），而且不能修改，但无需dll</li></ul><p>所以为了方便起见，我们采用<code>SetWinEventHook</code></p><h4 id="SetWinEventHook"><a href="#SetWinEventHook" class="headerlink" title="SetWinEventHook"></a>SetWinEventHook</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HWINEVENTHOOK <span class="hljs-title">SetWinEventHook</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD        eventMin,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD        eventMax,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] HMODULE      hmodWinEventProc,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] WINEVENTPROC pfnWinEventProc,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD        idProcess,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD        idThread,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD        dwFlags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> CALLBACK <span class="hljs-title">WinEventProc</span><span class="hljs-params">(HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD dwEventThread, DWORD dwmsEventTime)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (idObject != OBJID_WINDOW) <span class="hljs-comment">//确保对象是窗口</span><br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span> (event == EVENT_SYSTEM_FOREGROUND &amp;&amp; hwnd == xxx)<br>        ...<br>&#125;<br><br><span class="hljs-comment">// WINEVENT_OUTOFCONTEXT：表示回调函数是在调用线程的上下文中调用的，而不是在生成事件的线程的上下文中。这种方式不需要DLL模块句柄（hmodWinEventProc 设置为 NULL）</span><br>hHookFocus = <span class="hljs-built_in">SetWinEventHook</span>(EVENT_SYSTEM_FOREGROUND, EVENT_SYSTEM_FOREGROUND, <span class="hljs-literal">NULL</span>, WinEventProc, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, WINEVENT_OUTOFCONTEXT);<br><span class="hljs-comment">// START就是最小化，END就是恢复</span><br><span class="hljs-comment">//hHookHideShow = SetWinEventHook(EVENT_SYSTEM_MINIMIZESTART, EVENT_SYSTEM_MINIMIZEEND, NULL, WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);</span><br><span class="hljs-comment">//hHookDestory = SetWinEventHook(EVENT_OBJECT_DESTROY, EVENT_OBJECT_DESTROY, NULL, WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);</span><br><span class="hljs-comment">//hHookLocation = SetWinEventHook(EVENT_OBJECT_LOCATIONCHANGE , EVENT_OBJECT_LOCATIONCHANGE , NULL, WinEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);</span><br></code></pre></td></tr></table></figure><p>用法非常简单，一行Set + 一个回调函数即可</p><p>同时多个<code>EventHook</code>可以指向同一个回调函数（内部判断event即可）</p><p>具体事件枚举可以查看<a href="https://learn.microsoft.com/zh-cn/windows/win32/winauto/event-constants">事件常量 (Winuser.h) - Win32 apps | Microsoft Learn</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UnhookWinEvent</span>(hHookFocus); <span class="hljs-comment">//用完记得卸载钩子</span><br></code></pre></td></tr></table></figure><p>我们只需要关注以下事件并做出相应操作即可：</p><ul><li><code>EVENT_SYSTEM_FOREGROUND</code>：前台窗口改变</li><li><code>EVENT_SYSTEM_MINIMIZESTART</code> &amp; <code>EVENT_SYSTEM_MINIMIZEEND</code>：最小化和恢复</li><li><code>EVENT_OBJECT_DESTROY</code>：窗口关闭（此时应取消监听）</li><li><code>EVENT_OBJECT_LOCATIONCHANGE</code>：窗口移动</li></ul><p>对于窗口移动的监听要注意一点，窗口最小化也会触发移动，坐标为：<code>(-32000 -32000)</code>，需要通过<code>IsIconic</code>过滤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event == EVENT_OBJECT_LOCATIONCHANGE &amp;&amp; hwnd == targetWindow) &#123; <span class="hljs-comment">// 窗口位置改变</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsIconic</span>(hwnd)) &#123; <span class="hljs-comment">// 最小化时 位置为(-32000 -32000)，需要过滤</span><br>        RECT currentRect;<br>        <span class="hljs-built_in">GetWindowRect</span>(hwnd, &amp;currentRect);<br>        <span class="hljs-keyword">auto</span> pos = <span class="hljs-built_in">QPoint</span>(currentRect.left, currentRect.top);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，其他的部分我相信大家都dddd了，きっと大丈夫ね</p><p>源码实现可以参考：<a href="https://github.com/MrBeanCpp/ImageViewer2.0">MrBeanCpp&#x2F;ImageViewer2.0: 旨在以最简洁、轻量的方式呈现图像 (github.com)</a></p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>创意来源：<a href="https://www.pureref.com/index.php">PureRef</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-attachthreadinput">AttachThreadInput 函数 (winuser.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://www.cnblogs.com/ziwuge/archive/2012/01/06/2315342.html">SetForegroundWindow的正确用法 - 子坞 - 博客园 (cnblogs.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setparent">SetParent 函数 (winuser.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://blog.csdn.net/weixin_39636857/article/details/117270299">c语言跨进程回调函数,使用 SetParent 跨进程设置父子窗口时的一些问题（小心卡死）…-CSDN博客</a></p><p><a href="https://walterlv.blog.csdn.net/article/details/102775111">使用 SetParent 跨进程设置父子窗口时的一些问题（小心卡死）_vb中setparent作用死机-CSDN博客</a></p><p><a href="http://www.cppblog.com/zaccheo/archive/2012/08/24/188156.aspx">SetWindowPos 使用注意事项 - 小步慢跑 - C++博客 (cppblog.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowpos">SetWindowPos 函数 (winuser.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow 函数 (winuser.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://stackoverflow.com/questions/22025592/setwindowshookex-vs-setwinhookeventex">c# - SetWindowsHookEx 与 SetWinHookEventEx - 堆栈溢出 (stackoverflow.com)</a></p><p><a href="https://blog.csdn.net/stone5555/article/details/81953062">SetWinEventHook和SetWindowsHookEx的异同_delphi setwineventhook-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Windows</tag>
      
      <tag>Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 系统级个人文件夹 vs OneDrive简析</title>
    <link href="/2024/04/02/Windows-%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%80%E6%9E%90/"/>
    <url>/2024/04/02/Windows-%E7%B3%BB%E7%BB%9F%E7%BA%A7%E4%B8%AA%E4%BA%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Windows</code>的系统级个人文件夹包括：<code>Documents</code>, <code>Music</code>, <code>Desktop</code>, <code>Pictures</code> 等等</p><p>这些文件夹默认情况下，是在<code>C:\Users\&#123;name&#125;\</code>下</p><p>那么由于一些妇孺皆知的原因，C盘空间是永远捉襟见肘的</p><p>有没有办法将这些文件夹移动到其他驱动器上呢？</p><h2 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h2><p>伟大的巨硬已经帮我们想到了</p><p>打开个人文件夹（如：音乐）的属性-位置标签，我们就可以看到<strong>移动</strong>按钮</p><blockquote><p> Tip: 不知道大家有没有发现，这个“位置”标签只有这些个人文件夹才有，普通文件夹是没有的</p></blockquote><p><img src="/img/image-20240402234703570.png" alt="属性"></p><p>例如选择新位置为：<strong>E:\Music</strong>，移动，大功告成</p><p>有的人可能会说了，直接<code>Ctrl+X</code>剪切不行吗？</p><p>听起来有点粗暴，其实经过我的实验，也是可以的，操作系统仍然能够跟踪这些文件夹的位置</p><blockquote><p> ：等等，什么叫跟踪，为什么要跟踪</p></blockquote><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><p>这次我们拿<strong>文档</strong>（<code>Documents</code>）来举例吧</p><p><code>QQ</code>都知道吧，默认情况下，<code>QQ</code>的消息记录默认是保存在“<strong>我的文档</strong>”下的</p><p><img src="/img/image-20240403000034283.png" alt="QQ个人文件夹"></p><p>那么问题来了，“<strong>我的文档</strong>”是可以被移动的（如前文所述），那么<code>QQ</code>如何准确查找“<strong>我的文档</strong>”</p><p>总不能是<code>User</code>目录（<code>C:\Users\&#123;name&#125;\</code>） + <code>Documents</code>吧</p><p><em>&#x2F;&#x2F; 那也太捞了，不会有人这么写吧，不会吧不会吧</em></p><p>用半月板想都知道，那肯定是有系统<code>API</code>的ya</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath"><code>SHGetKnownFolderPath</code></a>(更现代) or <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpatha"><code>SHGetFolderPath</code></a>（前者的包装器）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shlobj.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;knownfolders.h&gt;</span> </span><br><br>PWSTR path = <span class="hljs-literal">nullptr</span>;<br>HRESULT hr = <span class="hljs-built_in">SHGetKnownFolderPath</span>(FOLDERID_Documents, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, &amp;path);<br><span class="hljs-keyword">if</span> (hr == S_OK) &#123;<br>    std::wcout &lt;&lt; path &lt;&lt; std::endl;<br>&#125; <span class="hljs-comment">// 若文件夹不存在（被删除），则Fail</span><br><br><span class="hljs-built_in">CoTaskMemFree</span>(path);<span class="hljs-comment">// 释放内存, 无论是否成功</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shlobj.h&gt;</span></span><br><span class="hljs-comment">// #define CSIDL_MYDOCUMENTS  CSIDL_PERSONAL //  Personal was just a silly name for My Documents</span><br><br>TCHAR szPath[MAX_PATH]; <span class="hljs-comment">// 文档里说用 MAX_PATH (260)</span><br><span class="hljs-built_in">SHGetFolderPath</span>(<span class="hljs-literal">nullptr</span>, CSIDL_PERSONAL, <span class="hljs-literal">nullptr</span>, SHGFP_TYPE_CURRENT, szPath);<br><span class="hljs-comment">// szPath: &quot;E:\Documents&quot;</span><br></code></pre></td></tr></table></figure><p>在<code>Qt</code>中，可以用<code>QStandardPaths</code>获取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QStandardPaths::<span class="hljs-built_in">writableLocation</span>(QStandardPaths::DocumentsLocation);<br></code></pre></td></tr></table></figure><p>话说这些<code>API</code>是如何知道“<strong>我的文档</strong>”的当前位置的？</p><p>当然是记在注册表啊，见<a href="https://support.microsoft.com/zh-cn/topic/-%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3-%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%85%8D%E7%BD%AE-dfd9a90d-8f80-18d6-e7cc-f1566fc3b10b">微软文档</a></p><blockquote><p>“我的文档”文件夹的路径存储在以下注册表项中，其中的 &lt;存储位置的完整路径&gt; 是存储位置的路径：</p><p>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</p><p>数值名称：Personal<br>数值类型：REG_SZ<br>数值数据：存储位置的完整路径</p></blockquote><p>也就是说，<code>Windows</code>会通过注册表来跟踪个人文件夹的当前位置</p><p>同时，我们也可以通过查看注册表 来 判断个人文件夹是否移动成功</p><p>如果移动后注册表没有更新 或者 “位置”标签消失，说明寄了</p><h3 id="坑：编码"><a href="#坑：编码" class="headerlink" title="坑：编码"></a>坑：编码</h3><p>这里其实有一个非常大的坑，和<code>Windows API</code>交互经常会有这种问题</p><p>就是如何输出<code>TCHAR</code>数组，和<code>PWSTR</code>指针</p><p>如果直接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; szPath &lt;&lt; std::end; <span class="hljs-comment">// TCHAR // SHGetFolderPath</span><br>std::wcout &lt;&lt; path &lt;&lt; std::endl; <span class="hljs-comment">// PWSTR // SHGetKnownFolderPath</span><br></code></pre></td></tr></table></figure><p>那么估计会死得很惨</p><p>看起来用<code>wcout</code>输出<code>PWSTR</code>非常正确（W代表宽字符）</p><p>事实也确实如此，但是结果却是：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">E:</span>\OneDrive\附件\音乐<br><span class="hljs-symbol">E:</span>\OneDrive\<br></code></pre></td></tr></table></figure><p>？为什么<code>PWSTR</code>的结果不正确，是<code>SHGetKnownFolderPath</code>出bug了吗，是OneDrive重定向了吗</p><p>在阅读了大量文档和Qt源码后（Qt API正确输出，且内部使用了<code>SHGetKnownFolderPath</code>）</p><p>我发现：居然是打印过程出现了问题！中文没有正常显示（通过调试模式打断点可以看到内存里显示是正常的）</p><p>aaaaa，这谁想得到啊，编码不正确不应该是乱码吗，怎么会直接没了！</p><p>其实说实话，好好读<a href="https://learn.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath#parameters">SHGetKnownFolderPath文档</a>的程序员应该一眼就初见端倪了</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">The returned <span class="hljs-type">path</span> does <span class="hljs-keyword">not</span> <span class="hljs-keyword">include</span> a <span class="hljs-keyword">trailing</span> backslash. <span class="hljs-keyword">For</span> example, &quot;C:\Users&quot; <span class="hljs-keyword">is</span> returned rather than &quot;C:\Users\&quot;.<br></code></pre></td></tr></table></figure><p>人家都说了，返回的路径不会以<code>&#39;\&#39;</code>结尾的</p><p>你看看<code>E:\OneDrive\</code>正常吗？！盯————</p><p><strong>为了正常显示中文，需要加入这一行：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// &quot;&quot; == 使用客户环境中缺省的locale (&quot;chs&quot;)</span><br><span class="hljs-comment">// setlocale(LC_ALL, &quot;chs&quot;);</span><br></code></pre></td></tr></table></figure><p>然后就正常了</p><p>因为默认情况下，<code>locale</code>是”C”（听说是为了可移植性，所以不支持中文）</p><p>可通过以下代码获取默认<code>locale</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* currentLocale = <span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-literal">nullptr</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Current locale: &quot;</span> &lt;&lt; currentLocale &lt;&lt; std::endl; <span class="hljs-comment">// &quot;C&quot;</span><br></code></pre></td></tr></table></figure><p>你以为这就完了？太年轻了兄弟</p><h4 id="TCHAR怎么办呢"><a href="#TCHAR怎么办呢" class="headerlink" title="TCHAR怎么办呢"></a><code>TCHAR</code>怎么办呢</h4><p>难道你想说你看了眼<code>TCAHR</code>的定义：<code>typedef char TCHAR</code>，然后发现很合理，很正常</p><p>随便用个<code>cout</code>、 <code>printf</code>都能正常输出中文</p><p>那你有没有想过<code>TCHAR</code>的<strong>T</strong>是什么意思，<code>_T</code>有什么用，<code>L</code>有什么用</p><p><code>T</code>可以理解为<code>TEXT</code>，意为文本，也就是会根据<code>UNICODE</code>宏定义自动处理宽窄字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>  UNICODE </span><br><span class="hljs-keyword">typedef</span> WCHAR TCHAR;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> TCHAR;<br></code></pre></td></tr></table></figure><p><code>_T</code> 也是如此</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _T(x)       __T(x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _TEXT(x)    __T(x)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __T(x)      L ## x <span class="hljs-comment">// if UNICODE</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __T(x)      x</span><br></code></pre></td></tr></table></figure><p>那么<code>L</code>前缀呢，就是把字面量标记为宽字符</p><p>だから，我们需要同时考虑宽窄字符（<code>UNICODE</code>宏是否定义）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tchar.h&quot;</span></span><br><br>_tprintf(_T(<span class="hljs-string">&quot;%s\n&quot;</span>), szPath); <span class="hljs-comment">// TCHAR</span><br></code></pre></td></tr></table></figure><p>可以用<code>_tprintf</code>宏来自动选择<code>printf</code>和<code>wprintf</code>&#x2F;&#x2F; 宏真神奇</p><p><em>&#x2F;&#x2F; 顺便说一下，Windows API也常会提供两个版本，以A结尾（ANSI，单字节字符）和以W结尾（宽字符），同时还会提供一个宏（不带后缀）来自动选择</em></p><p>啊，我不得不吐槽一下，原生C++的编码太离谱了，不会真有人用得来吧</p><p><strong>看看远方的<code>Qt</code>吧，家人们，<code>QString</code>直接就是<code>Unicode</code>编码，舒服</strong></p><p>你以为这就完了？仍旧年轻了兄弟</p><p>如果你用的是<code>Windows Clion + MSVC</code>，此时你只要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;测试&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 娴嬭瘯</span><br></code></pre></td></tr></table></figure><p>就会得到这一坨，还有一个Waring：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">warning C4819: 该文件包含不能在当前代码页(<span class="hljs-number">936</span>)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失<br></code></pre></td></tr></table></figure><p>乍一看，文件编码明明就是<code>UTF-8</code>呀，怎么不是<code>Unicode</code>了</p><p>不会有人不知道<code>UTF-8</code>分为两个版本吧：<code>UTF-8</code> &amp; <code>UTF-8 with BOM</code></p><blockquote><p>BOM（byte order mark）：用于标记字节序，微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开</p><p>两个版本的区别就是：文件开头有没有 U+FEFF</p></blockquote><p><code>MSVC</code>编译器默认编码是<code>UTF-8 with BOM</code>，如果没有<code>BOM</code>，<code>MSVC</code>编译器就不会认为这是<code>Unicode</code>编码，导致编译后打印乱码</p><p><strong>Solution：</strong></p><ul><li>在IDE的文件编码设置中改为<code>UTF-8 with BOM</code></li><li>或在<code>cmake</code>中强制采用<code>UTF</code>-8编译：<code>add_compile_options(/utf-8)</code></li></ul><h4 id="还有个坑："><a href="#还有个坑：" class="headerlink" title="还有个坑："></a>还有个坑：</h4><p><code>Clion</code>正常运行没问题，但是调试模式 还是会乱码，寄</p><h2 id="OneDrive"><a href="#OneDrive" class="headerlink" title="OneDrive"></a>OneDrive</h2><p>事情到这里就结束了吗，其实才刚刚开始</p><p>我发现，当个人文件夹遇上OneDrive，问题就大发了</p><p>OneDrive有一个备份个人文件夹的功能</p><p><img src="/img/image-20240403003339684.png" alt="OneDrive备份"></p><p>如果我们打开某文件夹的备份按钮</p><p>那么该文件夹就会被<strong>移动</strong>到OneDrive文件夹中</p><p>这个移动同样会被注册表跟踪，和手动剪切进来没有什么两样</p><p><em>&#x2F;&#x2F; 有时候你可能会发现，OneDrive自动备份导致文件夹移动后，缺少了“位置”标签页，别慌，重启一下资源管理器就好了</em></p><h3 id="异变"><a href="#异变" class="headerlink" title="异变"></a>异变</h3><p>不过，一旦个人文件夹进入了OneDrive，性质就发生了改变</p><p>此时如果我们移动这个 个人文件夹（如：音乐）（通过“位置”标签），就会报错</p><p><img src="/img/image-20240403004331783.png" alt="无法移动"></p><p>如果此时强行用<code>Ctrl+X</code>剪切该文件夹，是可以成功的</p><p>但是，该文件夹（如：音乐）就会<strong>退化</strong>为一个普通文件夹，且名称从”Music”变为了“音乐”</p><p><em>&#x2F;&#x2F; 原本的“音乐文件夹”虽然看起来叫”音乐“，其实地址栏名称是Music（什么中英混合体）</em></p><p>此时你会发现，注册表中的音乐文件夹依然指向<code>OneDrive\Music</code></p><p>过了一会儿（等资源管理器反应过来），就会在下重新生成一个新的“音乐”文件夹来取代之</p><p><em>&#x2F;&#x2F; 可能会看到两个一样的“音乐”文件夹，别担心，重启一下资源管理器</em></p><p>这种情况下，你原来的音乐文件夹就废了，只能手动剪切内容了</p><h3 id="异变-2"><a href="#异变-2" class="headerlink" title="异变-2"></a>异变-2</h3><p>第二种情况，如果你没有手动将OneDrive下的个人文件夹移动走，而是通过刚刚OneDrive的备份开关（关闭备份）</p><p>那么，令人震惊的事情发生了，OneDrive中的“音乐”文件夹没有任何变化（甚至图标还在）</p><p>而<code>C:\Users\&#123;name&#125;\</code>下生成了一个新的“音乐”文件夹（正宫），且内置快捷方式指向OneDrive中的“音乐”文件夹</p><p>这波操作，陈独秀你坐下</p><p>&#x2F;&#x2F; 因此，一旦将个人文件夹移动至OneDrive，将很难正常移出去</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>如果你在OneDrive文件夹内部移动个人文件夹（如：音乐），那么情况将大不相同</p><h4 id="情况1：通过“位置”标签页将-OneDrive-Music-移动到-OneDrive-Other-Music"><a href="#情况1：通过“位置”标签页将-OneDrive-Music-移动到-OneDrive-Other-Music" class="headerlink" title="情况1：通过“位置”标签页将 OneDrive\Music 移动到 OneDrive\Other\Music"></a>情况1：通过“位置”标签页将 OneDrive\Music 移动到 OneDrive\Other\Music</h4><p>那么神奇的事情将会发生，<code>OneDrive\Music</code> 文件夹依然存在，且内容完好，但是缺少了图标</p><p>而<code>OneDrive\Other\Music</code> 空有图标（正宫标志），却没有内容</p><p>啊这——，分裂了是吧</p><h4 id="情况2：直接Ctrl-X剪切"><a href="#情况2：直接Ctrl-X剪切" class="headerlink" title="情况2：直接Ctrl+X剪切"></a>情况2：直接Ctrl+X剪切</h4><p>那么一切都很正常</p><h3 id="移动OneDrive"><a href="#移动OneDrive" class="headerlink" title="移动OneDrive"></a>移动OneDrive</h3><p>你以为这又又完了，太年轻了兄弟</p><p>有没有想过，OneDrive也是在C盘的，很占空间的</p><p>那假如我要移动OneDrive文件夹，其中的“音乐”文件夹会怎么样？</p><p>首先，我们要解决一个问题，要如何移动OneDrive（这玩意儿是个网盘啊，可不是一般的文件夹）</p><p>需要参考一下官方文档：<a href="https://support.microsoft.com/zh-cn/office/%E6%9B%B4%E6%94%B9-onedrive-%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%8D%E7%BD%AE-f386fb81-1461-40a7-be2c-712676b2c4ae">更改 OneDrive 文件夹的位置 - Microsoft 支持</a></p><ol><li>取消此电脑链接</li><li>移动（剪切）OneDrive文件夹</li><li>重新初始化OneDrive，并选择OneDrive文件夹位置（移动后）</li></ol><p>好的，那么OneDrive中的Music文件夹会怎么样，能保持正宫位置吗</p><p>请看一段广告，我们稍后回来——</p><p>好的，没有赞助商，揭晓答案：<code>OneDrive\Music</code>守住了宝座，非常正常，甚至注册表也同步更新了</p><p>为什么呢，究竟是被包装在OneDrive中的原因，还是OneDrive取消链接，从网盘退化为普通文件夹的原因！</p><p>为了验证，我们先取消OneDrive链接，使其退化为普通文件夹，然后剪切<code>Music</code>文件夹</p><p>发现：还是没有卵用，<code>Music</code>文件夹依旧退化</p><p>寄，OneDrive文件夹真神奇</p><h2 id="Rebuild"><a href="#Rebuild" class="headerlink" title="Rebuild"></a>Rebuild</h2><p>如果我们把<code>OneDrive\Music</code>删除会怎么样呢？</p><p>此时在<code>user</code>文件夹下生成了一个新的<strong>Music</strong>文件夹</p><p>那么假如我们把这个<code>C:\Users\&#123;name&#125;\Music</code>继续删除呢</p><p>emmm，那就没了</p><p>此时，<code>SHGetKnownFolderPath</code>的返回<code>Error</code>（<code>hr != S_OK</code>），但是注册表中记录的还是默认位置 &#x2F;&#x2F;看来会判断是否存在</p><p>如何找回呢？</p><h3 id="OneDrive备份"><a href="#OneDrive备份" class="headerlink" title="OneDrive备份"></a>OneDrive备份</h3><p>如果我们直接打开OneDrive同步与备份中的<strong>Music</strong>开关</p><p>那么OneDrive中会奇迹般地出现“音乐”文件夹，同时注册表也更新了</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>其实我们也可以通过<code>SHGetKnownFolderPath</code>手动新建系统文件夹</p><p>只要将<code>dwFlags</code>设置为该值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">KF_FLAG_CREATE<br>值： <span class="hljs-number">0x00008000</span><br>指定强制创建指定文件夹（如果该文件夹尚不存在）。 应用为该文件夹预定义的安全预配。 如果文件夹不存在且无法创建，则该函数将返回失败代码，并且不会返回任何路径<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SHGetKnownFolderPath</span>(FOLDERID_Music, KF_FLAG_CREATE, <span class="hljs-literal">nullptr</span>, &amp;path);<br></code></pre></td></tr></table></figure><p>这样，<code>Music</code>文件夹就会在默认位置重新被创建了（Brand-New）！</p><p>&#x2F;&#x2F; 如果想要获取某文件夹的默认存储位置（移动前的）可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SHGetKnownFolderPath</span>(FOLDERID_Music, KF_FLAG_DONT_VERIFY | KF_FLAG_DEFAULT_PATH, <span class="hljs-literal">nullptr</span>, &amp;path);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">KF_FLAG_DEFAULT_PATH<br>值： <span class="hljs-number">0x00000400</span><br>指定检索已知文件夹的默认路径。 如果未设置此标志，则该函数将检索文件夹的当前路径（可能重定向）。 除非设置了 KF_FLAG_DONT_VERIFY ，否则此标志的执行包括验证文件夹是否存在。<br></code></pre></td></tr></table></figure><h3 id="静观其变"><a href="#静观其变" class="headerlink" title="静观其变"></a>静观其变</h3><p>既然我们可以通过API去创建个人文件夹，那么同理，其他软件如果需要往这些文件夹写入数据但是发现<strong>Not Found</strong>，可能大概应该会重新帮我们创建</p><p>所以，放几天大概就好了吧，啊哈哈</p><p>&#x2F;&#x2F; 例如：打开网易云音乐就会自动创建</p><h3 id="手动新建"><a href="#手动新建" class="headerlink" title="手动新建"></a>手动新建</h3><p>或者，我们可以观察一下注册表中对应文件夹的位置，然后手动新建一个一毛一样的文件夹，然后重启资源管理器，大概就会被认为是正宫了</p><p>Just没有图标，那么文件夹图标是哪来的呢？</p><p>其实是文件夹下的一个隐藏文件（且被系统保护）：<code>desktop.ini</code></p><p><img src="/img/image-20240403182634322.png" alt="显示隐藏文件"></p><p>对于<code>Music</code>文件夹，<code>desktop.ini</code>内容如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[.ShellClassInfo]</span><br><span class="hljs-attr">LocalizedResourceName</span>=@%SystemRoot%\system32\windows.storage.dll,-<span class="hljs-number">21790</span><br><span class="hljs-attr">InfoTip</span>=@%SystemRoot%\system32\shell32.dll,-<span class="hljs-number">12689</span><br><span class="hljs-attr">IconResource</span>=%SystemRoot%\system32\imageres.dll,-<span class="hljs-number">108</span><br><span class="hljs-attr">IconFile</span>=%SystemRoot%\system32\shell32.dll<br><span class="hljs-attr">IconIndex</span>=-<span class="hljs-number">237</span><br></code></pre></td></tr></table></figure><p>第一行设置了文件夹的本地化名称，即在不同语言环境下显示的名称</p><p>这也就解释了为什么<strong>音乐文件夹</strong>显示为”<strong>音乐</strong>“，但实际路径中是”<strong>Music</strong>“</p><p>仔细看可以发现，实际上是从<code>windows.storage.dll</code>中提取ID为21790的资源（字符串）</p><p>我们可以验证一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">HMODULE hModule = <span class="hljs-built_in">LoadLibrary</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;C:\\Windows\\System32\\windows.storage.dll&quot;</span>));<br><span class="hljs-keyword">if</span> (hModule == <span class="hljs-literal">nullptr</span>) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to load DLL.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> resourceID = <span class="hljs-number">21790</span>; <span class="hljs-comment">// 资源标识符</span><br><br>WCHAR buffer[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> length = <span class="hljs-built_in">LoadStringW</span>(hModule, resourceID, buffer, <span class="hljs-built_in">sizeof</span>(buffer) / <span class="hljs-built_in">sizeof</span>(WCHAR));<br><span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>) &#123;<br>    std::wcout &lt;&lt; <span class="hljs-string">L&quot;Resource string: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;Failed to load string resource.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">FreeLibrary</span>(hModule); <span class="hljs-comment">// 释放 DLL 文件</span><br></code></pre></td></tr></table></figure><p>输出为：<code>Resource string: 音乐</code></p><ul><li><code>iconTip</code>设置了当你将鼠标悬停在文件夹图标上时显示的提示信息</li><li><code>IconResource</code>是图标资源，和<code>IconFile &amp; IconIndex</code>应该是重复的，大概是为了兼容性考虑</li></ul><p>所以其实都是不是很重要的信息，如果我们自己新建<code>Music</code>文件的话，大概可能把这个<code>desktop.ini</code>建出来，外表就大差不大了</p><h2 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h2><p>现在还剩下一个最大的疑点，为什么个人文件夹（如：音乐）一旦进入OneDrive，再移动（剪切）出来，就会失去系统属性，堕落为普通文件夹呢</p><p>是因为<code>desktop.ini</code>吗？</p><p>一般情况下，我们移动文件夹，<code>desktop.ini</code>作为文件夹内的一个文件肯定也会被移动的</p><p>不过在OneDrive中的Music比较特殊，如果在文件夹选项中勾选了“<code>隐藏受保护的操作系统文件（推荐）</code>”</p><p>那么<code>desktop.ini</code>会被隐藏，此时剪切Music文件夹，移出OneDrive，会发现，<code>desktop.ini</code>的内容发生了变化</p><p>只剩下更改文件夹名称的这一行了（但其实真是文件名也变成了”音乐”）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">LocalizedResourceName</span>=@%SystemRoot%\system32\windows.storage.dll,-<span class="hljs-number">21790</span><br></code></pre></td></tr></table></figure><p>这就很奇怪了，一般文件夹的剪切应该保留<code>desktop.ini</code>才对</p><p>第二种情况，如果我们没有勾选“<code>隐藏受保护的操作系统文件（推荐）</code>”，那就能看到<code>desktop.ini</code></p><p>此时会有几个警告，问你要不要转移和覆盖<code>desktop.ini</code></p><p>会弹出很多次警告，还有一次覆盖4个文件？挺奇怪的（里面总共就俩<code>desktop.ini</code>）</p><p>然后呢，转移成功，会发现，图标什么的都保留了，<code>desktop.ini</code>也是正确的</p><p>但是，一看注册表，哎呀，又<strong>fallback</strong>到了<code>C:\Users\&#123;name&#125;\</code>下，而且还生成了一个新的正宫</p><p>寄</p><p><strong>世界十大未解之谜：计算机中的幽灵</strong></p><h2 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h2><p>我不干了，等我入职微软再说吧</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath">SHGetKnownFolderPath 函数 (shlobj_core.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">SHGetFolderPathA 函数 (shlobj_core.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://support.microsoft.com/zh-cn/topic/-%E6%88%91%E7%9A%84%E6%96%87%E6%A1%A3-%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E9%85%8D%E7%BD%AE-dfd9a90d-8f80-18d6-e7cc-f1566fc3b10b">“我的文档”文件夹的配置 - Microsoft 支持</a></p><p><a href="https://blog.csdn.net/yao_hou/article/details/122333819">Qt获取windows文档、下载、图片等目录路径_qt获取download目录-CSDN博客</a></p><p><a href="https://segmentfault.com/q/1010000042734462">c++ - 获取我的文档的路径 - SegmentFault 思否</a></p><p><a href="https://support.microsoft.com/zh-cn/office/%E6%9B%B4%E6%94%B9-onedrive-%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%8D%E7%BD%AE-f386fb81-1461-40a7-be2c-712676b2c4ae">更改 OneDrive 文件夹的位置 - Microsoft 支持</a></p><p><a href="https://zhuanlan.zhihu.com/p/36950695">移动Onedrive文件夹至D盘目录 - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/20167122">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/tscaxx/article/details/108390520">ANSI是什么编码？-CSDN博客</a></p><p><a href="https://blog.csdn.net/maxsky/article/details/41546029">解决 C++ printf 汉字问号。含 _tprintf(), printf(), wprintf() 详解_c++汉字变成问号-CSDN博客</a></p><p><a href="https://www.cnblogs.com/zyl910/archive/2013/01/20/wchar_crtbug_01.html">[C++] cout、wcout无法正常输出中文字符问题的深入调查（1）：各种编译器测试 - zyl910 - 博客园 (cnblogs.com)</a></p><p><a href="https://support.microsoft.com/zh-cn/office/%E6%9B%B4%E6%94%B9-onedrive-%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E4%BD%8D%E7%BD%AE-f386fb81-1461-40a7-be2c-712676b2c4ae">更改 OneDrive 文件夹的位置 - Microsoft 支持</a></p><p><a href="https://zhuanlan.zhihu.com/p/36950695">移动Onedrive文件夹至D盘目录 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>OneDrive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot @Scheduled 定时原理简析</title>
    <link href="/2024/03/18/Springboot-Scheduled-%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/"/>
    <url>/2024/03/18/Springboot-Scheduled-%E5%AE%9A%E6%97%B6%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Springboot</code>中可以用<code>@Scheduled</code>开启定时任务</p><p>这个时候有人就说了：定时任务有什么好讲的，不就是定时の任务嘛</p><p>有点道理，干讲没有什么意思，我们来试想这样一种场景：</p><ul><li><strong>假如有一个定时任务，每小时触发一次，但是系统（<code>Windows</code>）休眠了6个小时</strong></li></ul><p>那么：这个定时任务会在开机后立刻被触发吗，触发几次呢？</p><h2 id="正片叠底"><a href="#正片叠底" class="headerlink" title="正片叠底"></a>正片叠底</h2><p>好的，希望这个问题让你提起了一点点兴趣</p><p><code>@Scheduled</code>一共有三种定时方式：</p><ul><li><p><a href="https://www.cnblogs.com/qianjinyan/p/10415140.html">cron</a>：定义了一个如何循环的时间模式，比如“每天凌晨1点执行”，当然也可以定义为“每个小时的0分执行”；</p><p><code>cron</code>表达式由六个字段组成：[秒 分 时 日 月 周]</p><p>这么说可能比较抽象，我们来看个例子：</p><ul><li>“0 * * * * *”：每分钟的0秒都执行一次</li><li>“0 0 9 * * *”：每天9点0分0秒执行一次</li><li>“0 0 9 * * MON”：每周一的上午9点整执行</li><li>“0 0 9 1 * *”：每月的第一天上午9点整执行</li></ul><p>总之就很强大，可以去了解一下</p></li><li><p><code>fixedRate</code>：是指从每次执行开始到下一次执行开始的固定间隔</p></li><li><p><code>fixedDelay</code>：是指一次执行完成到下一次执行开始之间的固定等待时间（会算上执行时间）</p></li></ul><p>那么他们在面对系统休眠而错过下次执行时间的情况，会怎么处理呢？</p><ul><li><p><code>corn</code>：当系统唤醒后，<code>cron</code> 调度的任务会在下一个符合表达式的时间点执行。它不会因为错过了预定时间而尝试“补偿”执行</p></li><li><p><code>fixedRate</code>：根据实验，系统唤醒后，并不会立即执行任务，而是<strong>继续等待</strong>，几十分钟后，几乎同时执行了<strong>多次</strong>任务（休眠中错过的那几次），补偿了失去的过去（可能是按照预计的时间计算了下一次的时间，没有根据实际系统时间校正）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">#ScheduledTask.Clean <span class="hljs-number">00</span>:<span class="hljs-number">44</span>:<span class="hljs-number">40.224923500</span><br>... <span class="hljs-comment">//休眠中</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.292055800</span> <span class="hljs-comment">//11点多唤醒的，过了一会儿才执行</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">25</span>:<span class="hljs-number">07.293056400</span><br>#ScheduledTask.Clean <span class="hljs-number">12</span>:<span class="hljs-number">44</span>:<span class="hljs-number">10.973081</span><br></code></pre></td></tr></table></figure></li><li><p><code>fixedDelay</code>：推测，也是继续等待攒满<code>Interval</code>，但是不会补偿执行，因为间隔是从上一次任务结束后开始计算的</p></li></ul><p><code>fixedRate</code>和<code>fixedDelay</code>的执行机制应该大差不大</p><p>让我们从<code>fixedRate</code>管中窥豹，看看其底层定时机制</p><h2 id="定时机制"><a href="#定时机制" class="headerlink" title="定时机制"></a>定时机制</h2><p><code>@Scheduled</code>可以实现定时任务，这无可厚非，不必质疑，看起来理所当然，理应如此</p><blockquote><p>从来如此，便接受了吗？</p></blockquote><p>为什么呢，你有没有想过，<strong>定时</strong>，是如何实现的</p><p>有两种可能，固定时间点 &amp; 固定时间间隔</p><p>第一种，假如我们要在每天的23:00提醒用户睡觉</p><p>那么，我们怎么才能在23:00执行特定任务</p><p>谁来通知我们，现在已经是23:00了</p><ul><li>一个简单的想法是：每秒轮询一次时间，如果正好是23时，0分，则执行任务</li></ul><p>那么问题就是，任务会被多次触发（60次 maybe）</p><ul><li>那可以增加一个变量来记录是否执行过，</li><li>或者把每秒轮询改为每分钟轮询（延迟大），</li><li>或者检测23时0分0秒（可能错过，定时不一定精准）</li><li>或者改为每毫秒执行（开销大），</li><li>或者判断两次执行的间隔中包不包含特定时间点（23:00:00.0000）（最保险）</li></ul><p>好的，好的，先别纠结这个了</p><p>你刚刚是不是说：<strong>每秒轮询</strong>一次时间</p><p>每秒，轮询，这不又是定时吗，你怎么又绕回来了，自依赖是吧（定时依赖定时）</p><p>我们怎么实现每秒轮询？</p><ul><li>一个简单的想法是：While循环 + Sleep(1000)</li></ul><p>好的好的，很完美，就是有点简陋</p><p>其实，操作系统提供了定时器，例如linux的cron，Windows的定时任务</p><blockquote><p>硬件时钟和时钟中断（by GPT-4）</p><ul><li><strong>基础</strong>：大多数计算机系统都有一种硬件时钟（通常是实时时钟RTC和高精度事件定时器HPET），它们可以生成中断。这些时钟以固定频率运行，当达到预定时间时，它们会向CPU发送中断信号。</li><li><strong>工作原理</strong>：操作系统内核通过处理这些中断来维持系统时间和调度定时任务。当时钟中断发生时，操作系统的调度器会检查是否有需要执行的任务。</li></ul></blockquote><p>如此依赖，我们便可以实现每秒轮询了，固定点执行任务 GET</p><p>对于固定间隔，我们只要根据现在的时间计算出下一次预计执行的时间点即可，完美</p><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p>就是有个问题哦，每秒轮询一次貌似有点非常不那么精确</p><p>还有一个问题，假如我需要每小时执行一次任务，那么每秒的这些轮询就极大地浪费了CPU</p><p><em>&#x2F;&#x2F;好吧 其实对CPU来讲是小case啦，但是听着就很不优雅好吧</em></p><p>当然，我们也可以计算出距离时间点的间隔，然后使用系统的定时器，使其一小时后通知我们</p><h3 id="Scheduled定时机制"><a href="#Scheduled定时机制" class="headerlink" title="@Scheduled定时机制"></a>@Scheduled定时机制</h3><p>说了那么多，我们还是来看看<code>@Scheduled</code>的定时机制是怎么样的</p><p>的</p><p>的</p><p>…</p><p>呆——</p><p>没错你卡了</p><p>经过一下午的搜索和源码阅读（反编译的.class）</p><p>我觉得，我们还是抓重点吧，毕竟讲那么细也没什么用，对啊，啊hahaha</p><p>&gt; &lt;</p><p>借一下<a href="https://www.cnblogs.com/throwable/p/12616945.html">大佬</a>的图吧</p><p><img src="/img/s-b-s-f-2.jpg" alt="Scheduling模块的工作流程"></p><p>反正就是</p><ul><li><code>ScheduledAnnotationBeanPostProcessor</code>会解析<code>@Scheduled</code>注解，并且把方法（任务）封装为不同类型的<code>Task</code>实例，缓存在<code>ScheduledTaskRegistrar</code>中</li><li>其钩子方法<code>afterSingletonsInstantiated()</code>在所有单例初始化完成之后回调触发，在此方法中设置了<code>ScheduledTaskRegistrar</code>中的任务调度器（<code>TaskScheduler</code>或者<code>ScheduledExecutorService</code>类型）实例，并且调用<code>ScheduledTaskRegistrar#afterPropertiesSet()</code>方法添加所有缓存的<code>Task</code>实例到任务调度器中执行</li></ul><h4 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h4><p><code>Scheduling</code>模块支持<code>TaskScheduler</code>或者<code>ScheduledExecutorService</code>类型的任务调度器，而<code>ScheduledExecutorService</code>其实是<code>java.util.concurrent</code>的接口，一般实现类就是调度线程池<code>ScheduledThreadPoolExecutor</code></p><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>好的好的，其实这里讲了一大堆，我看那源码真的是跳来跳去，云里雾里，还都是反编译的，还都没有索引，还都找不到被谁调用了</p><p>好好好</p><p>总之呢，任务被放到了一个特殊的数据结构（<a href="https://www.cnblogs.com/dwlsxj/p/delayedQueue.html">延迟队列 <code>DelayQueue</code></a>）里</p><p>内部是一个优先队列，按照预计执行时间排列，头部是最先执行的，<code>take</code>获取头部时，如果时间还没到，就会休眠等待</p><p>不过呢，看源码的话，貌似是自己实现了一个类似的结构，而不是直接用<code>DelayQueue</code></p><p><em>&#x2F;&#x2F; 内部的<code>RunnableScheduledFuture</code>继承了<code>Delayed</code></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedWorkQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;Runnable&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;Runnable&gt;<br></code></pre></td></tr></table></figure><p>是<code>ScheduledThreadPoolExecutor</code>中的一个静态内部类</p><p>来看一下核心的<code>take</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                RunnableScheduledFuture&lt;?&gt; first = <span class="hljs-built_in">this</span>.queue[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(TimeUnit.NANOSECONDS);<br>                    <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0L</span>) &#123;<br>                        <span class="hljs-type">RunnableScheduledFuture</span> <span class="hljs-variable">var14</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.finishPoll(first);<br>                        <span class="hljs-keyword">return</span> var14;<br>                    &#125;<br><br>                    first = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.leader != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-built_in">this</span>.available.await();<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                        <span class="hljs-built_in">this</span>.leader = thisThread;<br><br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-built_in">this</span>.available.awaitNanos(delay); <span class="hljs-comment">//</span><br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.leader == thisThread) &#123;<br>                                <span class="hljs-built_in">this</span>.leader = <span class="hljs-literal">null</span>;<br>                            &#125;<br><br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">this</span>.available.await();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.leader == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>.queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.available.signal();<br>        &#125;<br><br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用了<code>Leader-Follower</code>模式</p><p>比较复杂，先不管那个，我们的目的是搞明白为什么系统休眠唤醒后，超时不会立即执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.available.awaitNanos(delay);<br></code></pre></td></tr></table></figure><p>如果第一个任务的时间还没到的话，就会等待，采用<code>Condition</code>的<code>awaitNanos</code>方法，进入休眠</p><p>而这个方法的实现内部又调用了<code>LockSupport.parkNanos(this, nanos);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>) &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        setBlocker(t, blocker);<br>        U.park(<span class="hljs-literal">false</span>, nanos); <span class="hljs-comment">//</span><br>        setBlocker(t, (Object)<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是调用了<code>Unsafe</code>的<code>park</code>方法</p><p>这是一个<code>native</code>方法，从Java层面无法继续往下了，应该是在虚拟机中调用了C++代码，然后进行系统调用</p><p>那么，这个<code>Unsafe.park</code>所等待的时间在Windows上，有可能，在休眠时暂停计时，唤醒时继续计时，休眠时间不计入</p><p>这是推测</p><p>不过<code>@Scheduled-fixedRate</code>确实在休眠时暂停了计时，这是实验结果</p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>好的，以上都是乱查查乱看看 + 推测</p><p>仅做抛砖引玉，不保证正确性，因为这代码也太绕了，而且还是反编译的！</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/309822935">Thread.sleep、synchronized、LockSupport.park的线程阻塞区别 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_39687783/article/details/85058686">LockSupport中的park与unpark原理_locksupport park-CSDN博客</a></p><p><a href="https://blog.csdn.net/gaodebao1/article/details/51789225">springBoot中@Scheduled执行原理解析_在springboot中执行定时任务有先后顺序-CSDN博客</a></p><p><a href="https://www.cnblogs.com/throwable/p/12616945.html">通过源码理解Spring中@Scheduled的实现原理并且实现调度任务动态装载 - throwable - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/aeb391e4edb0">Java定时调度机制 - ScheduledExecutorService - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/dwlsxj/p/delayedQueue.html">DelayQueue延迟队列原理剖析 - BattleHeart - 博客园 (cnblogs.com)</a></p><p><a href="https://javaguide.cn/java/collection/delayqueue-source-code.html#delayqueue-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B">DelayQueue 源码分析 | JavaGuide</a></p><p><a href="https://juejin.cn/post/7127110677214429221">Java 延迟队列 DelayQueue 的原理 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Springboot</tag>
      
      <tag>@Scheduled</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt源码解析: QCursor::pos()</title>
    <link href="/2024/03/13/Qt%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-QCursor-pos/"/>
    <url>/2024/03/13/Qt%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-QCursor-pos/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p><code>QCursor::pos()</code>看起来简单，返回鼠标坐标</p><p>其实在高DPI缩放下，返回的确是逻辑坐标，我们可以通过这个函数，管中窥豹</p><p>理解Qt是如何在逻辑坐标系与物理坐标系之间转换的</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QPoint <span class="hljs-title">QCursor::pos</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> QCursor::<span class="hljs-built_in">pos</span>(QGuiApplication::<span class="hljs-built_in">primaryScreen</span>());<br>&#125;<br><br><span class="hljs-function">QPoint <span class="hljs-title">QCursor::pos</span><span class="hljs-params">(<span class="hljs-type">const</span> QScreen *screen)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (screen) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> QPlatformCursor *cursor = screen-&gt;<span class="hljs-built_in">handle</span>()-&gt;<span class="hljs-built_in">cursor</span>()) &#123;<br>            <span class="hljs-type">const</span> QPlatformScreen *ps = screen-&gt;<span class="hljs-built_in">handle</span>();<br>            QPoint nativePos = cursor-&gt;<span class="hljs-built_in">pos</span>(); <span class="hljs-comment">//原生物理坐标</span><br>            ps = ps-&gt;<span class="hljs-built_in">screenForPosition</span>(nativePos); <span class="hljs-comment">//寻找nativePos所在Screen</span><br>            <span class="hljs-keyword">return</span> QHighDpi::<span class="hljs-built_in">fromNativePixels</span>(nativePos, ps-&gt;<span class="hljs-built_in">screen</span>()); <span class="hljs-comment">//</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QGuiApplicationPrivate::lastCursorPosition.<span class="hljs-built_in">toPoint</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看一下<code>QCursor::pos()</code>的逻辑啊</p><p>有两个重载，无参版本默认把主显示器传给了有参版本</p><p>这里，我们可能会疑惑，诶，为什么需要<code>QScreen</code>参数呢，光标坐标和屏幕有关吗</p><p>别急，接着往下看</p><p>首先，获取了原生屏幕指针（<code>QPlatformScreen</code>），然后通过<code>QPlatformCursor</code>获取到了光标的原生物理坐标（<code>nativePos</code>）</p><p>接着通过<code>ps = ps-&gt;screenForPosition(nativePos)</code>更新了屏幕指针，这是为什么呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*!</span><br><span class="hljs-comment">  Find the sibling screen corresponding to \a globalPos.</span><br><span class="hljs-comment">  Returns this screen if no suitable screen is found at the position.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> QPlatformScreen *<span class="hljs-title">QPlatformScreen::screenForPosition</span><span class="hljs-params">(<span class="hljs-type">const</span> QPoint &amp;point)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">contains</span>(point)) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> screens = <span class="hljs-built_in">virtualSiblings</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> QPlatformScreen *screen : screens) &#123;<br>            <span class="hljs-keyword">if</span> (screen-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">contains</span>(point))<br>                <span class="hljs-keyword">return</span> screen;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，注释和代码里都提到了一个词：<code>sibling</code></p><p>来看一下Qt文档的解释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QList&lt;QScreen *&gt; <span class="hljs-title">QScreen::virtualSiblings</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"><span class="hljs-comment">//Get the screen&#x27;s virtual siblings.</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//The virtual siblings are the screen instances sharing the same virtual desktop. They share a common coordinate system, and windows can //freely be moved or positioned across them without having to be re-created.</span></span><br></code></pre></td></tr></table></figure><p>所以，<code>sibling screens</code>也就是一个虚拟桌面内的所有相邻显示器，一般情况下与<code>qApp-&gt;screens()</code>相等</p><p>因此，<code>screenForPosition()</code>会遍历屏幕，找到鼠标光标所在的那一块</p><p>所以我们不必纠结，为什么一开始传入的是<code>primaryScreen()</code>，会不会不准确</p><p>其实传入什么<code>screen</code>都可以，只要在同一个虚拟桌面内，会自行定位</p><p>这里传入一个指针，是为了定位虚拟桌面而已</p><h4 id="more-more-more：QHighDpi-fromNativePixels"><a href="#more-more-more：QHighDpi-fromNativePixels" class="headerlink" title="more more more：QHighDpi::fromNativePixels"></a>more more more：QHighDpi::fromNativePixels</h4><p>顾名思义，我们已经知道了他可以从物理坐标（原生像素）转化为逻辑坐标</p><p>那么稍微看一下源码吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> C&gt;<br><span class="hljs-function">T <span class="hljs-title">fromNativePixels</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value, <span class="hljs-type">const</span> C *context)</span></span><br><span class="hljs-function"></span>&#123;<br>    QPoint nativePosition = <span class="hljs-built_in">position</span>(value); <span class="hljs-comment">//转换为QPoint</span><br>    QHighDpiScaling::ScaleAndOrigin so = QHighDpiScaling::<span class="hljs-built_in">scaleAndOrigin</span>(context, &amp;nativePosition);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">scale</span>(value, <span class="hljs-built_in">qreal</span>(<span class="hljs-number">1</span>) / so.factor, so.origin);<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，很短，就三行，我们先来看看<code>QHighDpiScaling::scaleAndOrigin</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QHighDpiScaling::ScaleAndOrigin <span class="hljs-title">QHighDpiScaling::scaleAndOrigin</span><span class="hljs-params">(<span class="hljs-type">const</span> QPlatformScreen *platformScreen, QPoint *nativePosition)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!m_active)<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-built_in">qreal</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">QPoint</span>() &#125;;<br>    <span class="hljs-keyword">if</span> (!platformScreen)<br>        <span class="hljs-keyword">return</span> &#123; m_factor, <span class="hljs-built_in">QPoint</span>() &#125;; <span class="hljs-comment">// the global factor</span><br>    <span class="hljs-type">const</span> QPlatformScreen *actualScreen = nativePosition ?<br>        platformScreen-&gt;<span class="hljs-built_in">screenForPosition</span>(*nativePosition) : platformScreen;<br>    <span class="hljs-keyword">return</span> &#123; m_factor * <span class="hljs-built_in">screenSubfactor</span>(actualScreen), actualScreen-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">topLeft</span>() &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里再次调用<code>screenForPosition()</code>定位了光标所在屏幕，非常严谨</p><p>返回值有俩：</p><ul><li>计算缩放比：<code>m_factor * screenSubfactor(actualScreen)</code>，巴拉巴拉bomb，可能是内部缩放比 * 外部缩放比？不管了</li><li>计算光标所在屏幕的左上角物理坐标：<code>actualScreen-&gt;geometry().topLeft()</code></li></ul><p>这第二个就是重点了，跟我们自行计算的方法有异曲同工之妙，不过他这里获取到的是真真正正的物理坐标</p><p>然后调用<code>scale(value, qreal(1) / so.factor, so.origin)</code>进行最后的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> QPoint <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">const</span> QPoint &amp;pos, qreal scaleFactor, QPoint origin = QPoint(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-keyword">return</span> (pos - origin) * scaleFactor + origin;<br>&#125;<br></code></pre></td></tr></table></figure><p>先减去左上角的坐标，归一化为（0,0），然后直接乘除缩放比，再把左上角加回来 hhhhhh</p><p>啊，哈，啊哈哈哈</p><h2 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://codebrowser.dev/qt5/qtbase/src/gui/kernel/qhighdpiscaling_p.h.html#_ZN8QHighDpi16fromNativePixelsERKT_PKT0_">qtbase&#x2F;src&#x2F;gui&#x2F;kernel&#x2F;qhighdpiscaling_p.h] - Codebrowser</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>源码解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt 高DPI缩放（高分屏适配）技术简析</title>
    <link href="/2024/03/12/Qt-%E9%AB%98DPI%E7%BC%A9%E6%94%BE%EF%BC%88%E9%AB%98%E5%88%86%E5%B1%8F%E9%80%82%E9%85%8D%EF%BC%89%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/"/>
    <url>/2024/03/12/Qt-%E9%AB%98DPI%E7%BC%A9%E6%94%BE%EF%BC%88%E9%AB%98%E5%88%86%E5%B1%8F%E9%80%82%E9%85%8D%EF%BC%89%E6%8A%80%E6%9C%AF%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，都已经2024年了，不会还有人在用<code>1080P</code>显示屏吧（没错就是我）</p><p>在很长一段时间里，<code>1080P</code>显示屏（1920 px * 1080 px）是业内设计UI的参考标准与目标</p><p>但是，当高分辨率屏幕（2K、4K）逐渐普及之后，人们发现，原先的UI设计在这些屏幕上显得很小</p><p>不难理解，这是因为高分屏在保持尺寸相当的情况下，塞下了更多的像素，增加了像素密度，或者说高DPI（Dot Per Inch）</p><p>每英寸的像素数量增加了，相同像素所占面积减小了，那么以像素为单位的UI设计，自然显得“更小”</p><p><img src="/img/image-20240312163134690.png" alt="1080P正常显示效果"></p><p><img src="/img/image-20240312162917916.png" alt="4K显示器效果"></p><p>可以看到4K显示器下，我们原本完美的UI设计比例全部被打乱，显得又小，又挤，又丑</p><p>这，这谁家的软件啊，我，我不认识你</p><h2 id="怎办"><a href="#怎办" class="headerlink" title="怎办"></a>怎办</h2><p>那怎么办呢，最容易想到的办法是对UI进行等比缩放</p><p><strong>标准显示密度</strong>：<code>96 DPI</code>已经被Windows操作系统作为传统的显示标准采用。这意味着，在默认的100%缩放设置下，系统预期显示器能够在每英寸的长度上显示96个像素点。这一标准确保了在开发和设计软件应用时，界面元素（如文字、图标）的大小能够在不同的显示器上保持相对一致性。</p><p>所以Windows系统的<strong>逻辑DPI</strong>一般都是96（缩放100%情况下），但是<strong>物理DPI</strong>通常比这个要大，例如我手上的这台1080P显示器的<strong>物理DPI</strong>是：127.628</p><p>在DPI恒定的情况下，增加分辨率，那么屏幕尺寸会发生变化，但是所有软件UI物理尺寸不变</p><p>但是对于现代显示器而言，通常是增加像素密度，例如我手头这台4K显示器的<strong>物理DPI</strong>是：161.962</p><p>那么在相同长度上，他会比一般的96 DPI低分辨屏，显示更多像素</p><h3 id="逻辑DPI-vs-物理DPI"><a href="#逻辑DPI-vs-物理DPI" class="headerlink" title="逻辑DPI vs 物理DPI"></a>逻辑DPI vs 物理DPI</h3><p>我们刚刚谈到了Windows中的<strong>逻辑DPI</strong>与<strong>物理DPI</strong>，那么这俩究竟有什么区别呢</p><p>物理DPI好理解，就是屏幕设备真实的DPI（屏幕像素数 &#x2F; 屏幕尺寸），对于一台特定设备，不会发生变化</p><p>逻辑DPI听起来比较迷惑，但是我们可以把它理解为Windows按照什么样的比例来绘制UI</p><p>或者希望软件按照什么样的DPI来规划自己的UI</p><p>这个数值与物理DPI无关，在Windows缩放100%情况下，逻辑DPI通常恒等于96</p><p><strong>而且这个值（逻辑DPI）与 96 的比值就等于Windows缩放比</strong>：<code>Scale = 逻辑DPI / 96</code></p><p>如果缩放比为150%，那么逻辑DPI为144，Windows以1.5倍的像素数来渲染UI</p><p>通过模拟一个虚假的DPI，Windows就可以欺骗软件，伪造外界的DPI，以实现控制第三方软件的UI缩放</p><p>其实这里有三种情况：</p><ul><li>第一种，软件什么都不做，也不管外界的DPI，那么不管Windows缩放比如何变化，软件窗口的大小保持恒定（但是如果字体的单位是pt，则字体会变化）</li><li>第二种，软件什么都不做，但是委托给Windows进行缩放管理（配置<code>dpiAwareness</code>），那么Windows就会接管，进行缩放</li><li>第三种，软件读取外部逻辑DPI（如果是物理DPI的话，也行，就是恒定大小了），通过其与96的比值，自行缩放UI，例如 <code>width *= scale;</code>，那么显示效果最好，但是灰常麻烦</li></ul><p>对于第二和第三种情况，被Windows缩放比所影响的逻辑DPI就可以发挥作用，这样也最符合用户需要</p><p>所以其实对于软件开发者，如果要自行缩放UI的话，不用单独考虑逻辑DPI的实际含义，只要关注其与96的比值（缩放比）即可</p><h2 id="Windows原生DPI感知-vs-Qt高DPI缩放"><a href="#Windows原生DPI感知-vs-Qt高DPI缩放" class="headerlink" title="Windows原生DPI感知 vs Qt高DPI缩放"></a>Windows原生DPI感知 vs Qt高DPI缩放</h2><h3 id="Windows-DPI感知"><a href="#Windows-DPI感知" class="headerlink" title="Windows DPI感知"></a>Windows DPI感知</h3><p>最简单的方法是委托给Windows进行处理</p><p>可以调用以下API</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ShellScalingAPI.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Shcore.lib&quot;</span>)</span><br><br>HRESULT hr = <span class="hljs-built_in">SetProcessDpiAwareness</span>(PROCESS_SYSTEM_DPI_AWARE);<br></code></pre></td></tr></table></figure><p>或者使用qt.conf，在资源qrc里添加，<code>:/qt/etc/qt.conf</code>, qt.conf文件内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[Platforms]<br>WindowsArguments = dpiawareness=1<br></code></pre></td></tr></table></figure><p>4K显示器效果如图：（边缘的灰色是桌面背景）</p><p><img src="/img/image-20240312162452700.png" alt="Windows原生DPI感知"></p><p>看起来有点模糊，但是各种功能都正常，懒人福利！</p><h3 id="Qt高DPI缩放"><a href="#Qt高DPI缩放" class="headerlink" title="Qt高DPI缩放"></a>Qt高DPI缩放</h3><p>Qt作为一个跨平台的桌面框架，自然不可避免要解决高分屏适配的问题</p><p>近几年来，特别是Qt5.15版本之后，对高分屏的支持变得更加能用了</p><p>比如，这一行可以让Qt支持非整倍数的缩放比，1.25 1.5等，（以前只能1x 2x地缩放）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">QApplication::<span class="hljs-built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);<br></code></pre></td></tr></table></figure><p>Qt开启高DPI缩放只需要一行：(但是为了更加好用，请加上上面那行↑)，（听说在Qt6中是默认开启的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">QCoreApplication::<span class="hljs-built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>注意，所以针对高DPI缩放策略的调整请在<code>QApplication</code>构造之前完成</p><p>当开启缩放时，图片和图标可能会变得模糊，为了解决这个问题，我们需要开启Qt对<strong>高分辨率版本pixmap</strong>（High resolution versions of pixmaps）的支持，然后按照特定策略提供图片资源（类似于<code>logo@2x.png</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">QCoreApplication::<span class="hljs-built_in">setAttribute</span>(Qt::AA_UseHighDpiPixmaps, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>Qt 将在运行时自动选择目标显示的最佳表示形式。有关更多详细信息，请参阅 <a href="https://doc.qt.io/qt-6/qicon.html#high-dpi-icons">High-DPI-Icons</a></p><p>所以综合起来就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">QCoreApplication::<span class="hljs-built_in">setAttribute</span>(Qt::AA_EnableHighDpiScaling, <span class="hljs-literal">true</span>);<br>QCoreApplication::<span class="hljs-built_in">setAttribute</span>(Qt::AA_UseHighDpiPixmaps, <span class="hljs-literal">true</span>);<br>QApplication::<span class="hljs-built_in">setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);<br></code></pre></td></tr></table></figure><p><img src="/img/image-20240312174416634.png" alt="Qt高DPI缩放"></p><p>可以看到字体更加锐利</p><h3 id="Who-is-better"><a href="#Who-is-better" class="headerlink" title="Who is better"></a>Who is better</h3><p>那么到底选哪个呢？</p><p>只能说各有千秋</p><ul><li>Windows DPI感知发生在系统层，故兼容性最好，Bug比较少，但是显示效果不够好，因为是直接拉伸（类似于图片缩放）</li><li>而Qt本身就是UI框架，缩放是在渲染层面上进行的，图像和文本可以保持其清晰度，不会出现像素化或模糊（但是边缘可能出现奇怪的线，不知道Qt6解决没）</li></ul><p>那么，Qt胜出？</p><p>不，事情远远没有这么简单</p><h3 id="Qt-高DPI缩放的原理"><a href="#Qt-高DPI缩放的原理" class="headerlink" title="Qt 高DPI缩放的原理"></a>Qt 高DPI缩放的原理</h3><p>Qt内部采用了<strong>逻辑坐标系统</strong>：使用逻辑坐标来描述界面元素，这些坐标是相对单位，与屏幕的实际物理像素点数独立，而在渲染时自动缩放转换为物理坐标</p><p>也就是说，我们针对96 DPI，1080P显示器设计的以<code>px</code>为单位的UI布局无需更改，我们还是假设程序运行在这样一块标准显示器上，Qt会自动处理缩放</p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>想法很美好，但是结果呢</p><p>结果是<code>Windows API</code>采用的是物理坐标（设备相关坐标），而Qt内部采用的是逻辑坐标（设备无关坐标）（所有公开函数都返回逻辑坐标，如<code>QCursor::pos()</code>）</p><p>这反而增加了复杂性，我们调用<code>Windows API</code>获得的坐标要先转换为Qt内部的逻辑坐标才能进行下一步操作，否则就全乱了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Widget::nativeEvent</span><span class="hljs-params">(<span class="hljs-type">const</span> QByteArray&amp; eventType, <span class="hljs-type">void</span>* message, <span class="hljs-type">long</span>* result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_UNUSED</span>(eventType);<br>    MSG* msg = (MSG*)message;<br>    <span class="hljs-keyword">switch</span> (msg-&gt;message) &#123;<br>    <span class="hljs-keyword">case</span> WM_NCHITTEST:<br>        <span class="hljs-type">int</span> winX = <span class="hljs-built_in">GET_X_LPARAM</span>(msg-&gt;lParam);<br>        <span class="hljs-type">int</span> winY = <span class="hljs-built_in">GET_Y_LPARAM</span>(msg-&gt;lParam);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，在原生事件中，我们会接收到<code>Windows</code>传递来的参数</p><p>这些参数中的坐标，一定是物理坐标</p><p>我们需要将其转换为<code>Qt</code>内部逻辑坐标，才能继续使用</p><p>这里也有两种情况</p><ol><li>如果你只有一块显示器，那么很简单，缩放中心就是左上角（0,0），直接<code>winX / scale</code>即可</li><li>如果你有多块显示器，而且<code>DPI</code>还不一样，那么问题就大发了</li></ol><p>假如你的窗口又正好不在主显示器上，那么该显示器的左上角就不是（0,0）了，因为显示器上的坐标是唯一的</p><p>这个时候的转换稍微麻烦一点</p><p>首先，我们要获取Qt物理像素和逻辑像素的比值，也就是<code>devicePixelRatio</code>，一般等于<code>Windows</code>缩放比</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">qreal <span class="hljs-title">Util::devicePixelRatio</span><span class="hljs-params">(QWidget* widget)</span></span><br><span class="hljs-function"></span>&#123;<br>    qreal dprScale = <span class="hljs-number">1.0</span>;<br>    QScreen *screen = QGuiApplication::<span class="hljs-built_in">screenAt</span>(widget-&gt;<span class="hljs-built_in">pos</span>());<br>    <span class="hljs-keyword">if</span> (screen != <span class="hljs-literal">nullptr</span>) &#123;<br>        dprScale = screen-&gt;<span class="hljs-built_in">devicePixelRatio</span>(); <span class="hljs-comment">//物理像素/逻辑像素，也就是Windows缩放比</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 在屏幕之间拖动时，会有短暂的nullptr的情况！</span><br>        dprScale = QGuiApplication::<span class="hljs-built_in">primaryScreen</span>()-&gt;<span class="hljs-built_in">devicePixelRatio</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> dprScale;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意，在屏幕之间拖动时，会有短暂的<code>nullptr</code>的情况，我们要处理这种情况，赋予默认值，否则就会空指针异常，然后崩溃（C++基操）</p><p>然后，我们要基于缩放比进行计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">float</span> DPR = Util::<span class="hljs-built_in">devicePixelRatio</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//like 1.25 1.5 1.75 2.0</span><br><span class="hljs-comment">// 获取屏幕的几何信息</span><br>QScreen *screen = QGuiApplication::<span class="hljs-built_in">screenAt</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pos</span>());<br>QRect screenGeometry = screen-&gt;<span class="hljs-built_in">geometry</span>(); <span class="hljs-comment">//logical!</span><br><span class="hljs-comment">// 转换物理坐标为Qt的逻辑坐标</span><br>QPoint logicalPos;<br>logicalPos = (<span class="hljs-built_in">QPoint</span>(winX, winY) - screenGeometry.<span class="hljs-built_in">topLeft</span>()) / DPR;<br>logicalPos += screenGeometry.<span class="hljs-built_in">topLeft</span>();<br></code></pre></td></tr></table></figure><p>大致思想就是，将物理坐标减去该显示器左上角坐标，假装自己是主显示器，左上角为（0,0），这样就可以进行简单乘除缩放了</p><p>缩放完毕后，再把刚刚减去的偏移量加回来即可得到Qt的逻辑坐标</p><h4 id="真的是这样吗？"><a href="#真的是这样吗？" class="headerlink" title="真的是这样吗？"></a>真的是这样吗？</h4><p>还记得我说过什么吗</p><blockquote><p>Qt内部采用的是逻辑坐标</p></blockquote><p>那么，<code>screen-&gt;geometry()</code>不也就是逻辑坐标吗？</p><p>在多显示器情况下，假设现在的<code>screen</code>不是主屏幕，那么<code>screenGeometry.topLeft()</code>就有可能与物理坐标不想等</p><p>那么一个物理坐标（<code>QPoint(winX, winY)</code>）减去一个逻辑坐标（<code>screenGeometry.topLeft()</code>），结果是显而易见的</p><p>假如主屏幕（或前几块屏幕）的<code>Windows</code>缩放不是<code>100%</code>，就会爆炸（假如逻辑坐标连续）</p><h4 id="僵局"><a href="#僵局" class="headerlink" title="僵局"></a>僵局</h4><p>那么既然Qt内部函数返回的都是逻辑坐标，自然不可能找到一个能将逻辑坐标转换物理坐标的函数了</p><p>那么不是死锁了嘛</p><p>要不我们再看一眼<a href="https://doc.qt.io/qt-6/highdpi.html#dprgadget">官方文档</a>吧</p><p><img src="/img/image-20240313093044936.png" alt="DprGadget"></p><p>诶，<code>Qt6</code>居然比<code>Qt5</code>多出个小工具（<a href="https://github.com/qt/qtbase/blob/885aba7ffdfaf410f16364f315411cf8d77da38a/tests/manual/highdpi/dprgadget/main.cpp#L172">DprGadget</a>），貌似是用于高DPI Debug用的，看到几个Native字样，让我扒一扒你用了什么神奇函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">QPlatformWindow *platformWindow = <span class="hljs-built_in">windowHandle</span>()-&gt;<span class="hljs-built_in">handle</span>();<br>nativeSizeLabel-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;native size %1 %2&quot;</span>).<span class="hljs-built_in">arg</span>(platformWindow-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">width</span>())<br>                         .<span class="hljs-built_in">arg</span>(platformWindow-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">height</span>()));<br></code></pre></td></tr></table></figure><p>什么！等一下，<code>QPlatformWindow</code>，这个名字一听就很物理坐标啊（而且<code>label</code>的名字也包含<code>native</code>），快让我康康！</p><p>原来是用了<code>#include &lt;QtGui/qpa/qplatformwindow.h&gt;</code>头文件，よし</p><p>诶不过，为什么提示<code>Not Found</code></p><p>有经验的小伙伴应该敏锐地察觉到了，这种情况要么是版本不对，要么是缺少模块</p><p>很快啊，我反手就打开了他的<a href="https://github.com/qt/qtbase/blob/885aba7ffdfaf410f16364f315411cf8d77da38a/tests/manual/highdpi/dprgadget/dprgadget.pro"><code>.pro</code>文件</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pro">QT += widgets gui_private<br></code></pre></td></tr></table></figure><p>好家伙，<code>gui_private</code>模块，藏着掖着，好好好，这么玩是吧</p><p>果然可以用了！</p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>不过别急，来都来了，我们深挖一下</p><p>首先，<code>#include &lt;QtGui/qpa/qplatformwindow.h&gt;</code>中的<code>qpa</code>指的是什么</p><p>全称为：<a href="https://doc.qt.io/qt-5/qpa.html">Qt Platform Abstraction</a>，一听就很不跨平台啊</p><p>但是很接地气，显然是我们想要的</p><p>让我看看都有<a href="https://doc.qt.io/qt-5/qpa.html#class-overview">什么类</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">QAbstractEventDispatcher<br>QPlatformAccessibility<br>QPlatformBackingStore<br>QPlatformClipboard<br>QPlatformCursor<br>QPlatformDrag<br>QPlatformFontDatabase<br>QPlatformGraphicsBuffer<br>QPlatformInputContext<br>QPlatformNativeInterface<br>QPlatformOffscreenSurface<br>QPlatformOpenGLContext<br>QPlatformScreen<br>QPlatformServices<br>QPlatformSharedGraphicsCache<br>QPlatformSurface<br>QPlatformWindow<br></code></pre></td></tr></table></figure><p>这个<code>QPlatformScreen</code>一听就很香啊，依葫芦画瓢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//QScreen::handle() -&gt; QPlatformScreen*</span><br>QScreen::<span class="hljs-built_in">handle</span>()-&gt;<span class="hljs-built_in">geometry</span>()<br></code></pre></td></tr></table></figure><p>这样就得到了真真正正的物理坐标！！哭辽</p><h4 id="more-more"><a href="#more-more" class="headerlink" title="more more"></a>more more</h4><p>事情到这里就结束了吗，大概也许</p><p>但是你不觉得，获取屏幕左上角物理坐标，然后再四则运算一下，有点冗余吗</p><p>你想想，<code>Qt</code>内部采用逻辑坐标，渲染采用物理坐标，那么肯定有转换函数存在呀！</p><p>说时迟那时快（？），你想想：<code>QCursor::pos()</code></p><p><code>QCursor::pos()</code>返回的是逻辑坐标，但是要在<code>Windows</code>上获取鼠标坐标，肯定调用了<code>Windows API</code>（物理坐标）啊</p><p>那么其内部必然有转换函数</p><p>很快啊，我直接打开Qt5 <a href="https://codebrowser.dev/qt5/qtbase/src/gui/kernel/qcursor.cpp.html#_ZN7QCursor3posEPK7QScreen">QCurosr::pos()</a>源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QPoint <span class="hljs-title">QCursor::pos</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> QCursor::<span class="hljs-built_in">pos</span>(QGuiApplication::<span class="hljs-built_in">primaryScreen</span>());<br>&#125;<br><br><span class="hljs-function">QPoint <span class="hljs-title">QCursor::pos</span><span class="hljs-params">(<span class="hljs-type">const</span> QScreen *screen)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (screen) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> QPlatformCursor *cursor = screen-&gt;<span class="hljs-built_in">handle</span>()-&gt;<span class="hljs-built_in">cursor</span>()) &#123;<br>            <span class="hljs-type">const</span> QPlatformScreen *ps = screen-&gt;<span class="hljs-built_in">handle</span>();<br>            QPoint nativePos = cursor-&gt;<span class="hljs-built_in">pos</span>(); <span class="hljs-comment">//原生物理坐标</span><br>            ps = ps-&gt;<span class="hljs-built_in">screenForPosition</span>(nativePos); <span class="hljs-comment">//寻找nativePos所在Screen</span><br>            <span class="hljs-keyword">return</span> QHighDpi::<span class="hljs-built_in">fromNativePixels</span>(nativePos, ps-&gt;<span class="hljs-built_in">screen</span>()); <span class="hljs-comment">//</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> QGuiApplicationPrivate::lastCursorPosition.<span class="hljs-built_in">toPoint</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这不看不得了啊，一看就留口水啊</p><p><code>QHighDpi::fromNativePixels</code>，这么好用的函数你不拿出来给大家伙用！</p><h4 id="QCursor-pos"><a href="#QCursor-pos" class="headerlink" title="QCursor::pos()"></a>QCursor::pos()</h4><p>我们先来看一下<code>QCursor::pos()</code>的逻辑啊</p><p>有两个重载，无参版本默认把主显示器传给了有参版本</p><p>这里，我们可能会疑惑，诶，为什么需要QScreen参数呢，光标坐标和屏幕有关吗</p><p>别急，接着往下看</p><p>首先，获取了原生屏幕指针（<code>QPlatformScreen</code>），然后通过<code>QPlatformCursor</code>获取到了光标的原生物理坐标（<code>nativePos</code>）</p><p>接着通过<code>ps = ps-&gt;screenForPosition(nativePos)</code>更新了屏幕指针，这是为什么呢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*!</span><br><span class="hljs-comment">  Find the sibling screen corresponding to \a globalPos.</span><br><span class="hljs-comment">  Returns this screen if no suitable screen is found at the position.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> QPlatformScreen *<span class="hljs-title">QPlatformScreen::screenForPosition</span><span class="hljs-params">(<span class="hljs-type">const</span> QPoint &amp;point)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">contains</span>(point)) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> screens = <span class="hljs-built_in">virtualSiblings</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> QPlatformScreen *screen : screens) &#123;<br>            <span class="hljs-keyword">if</span> (screen-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">contains</span>(point))<br>                <span class="hljs-keyword">return</span> screen;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，注释和代码里都提到了一个词：<code>sibling</code></p><p>来看一下Qt文档的解释</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QList&lt;QScreen *&gt; <span class="hljs-title">QScreen::virtualSiblings</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"><span class="hljs-comment">//Get the screen&#x27;s virtual siblings.</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//The virtual siblings are the screen instances sharing the same virtual desktop. They share a common coordinate system, and windows can //freely be moved or positioned across them without having to be re-created.</span></span><br></code></pre></td></tr></table></figure><p>所以，<code>sibling screens</code>也就是一个虚拟桌面内的所有相邻显示器，一般情况下与<code>qApp-&gt;screens()</code>相等</p><p>因此，<code>screenForPosition()</code>会遍历屏幕，找到鼠标光标所在的那一块</p><p>所以我们不必纠结，为什么一开始传入的是<code>primaryScreen()</code>，会不会不准确</p><p>其实传入什么<code>screen</code>都可以，只要在同一个虚拟桌面内，会自行定位</p><p>这里传入一个指针，是为了定位虚拟桌面而已</p><h4 id="more-more-more：QHighDpi-fromNativePixels"><a href="#more-more-more：QHighDpi-fromNativePixels" class="headerlink" title="more more more：QHighDpi::fromNativePixels"></a>more more more：QHighDpi::fromNativePixels</h4><p>顾名思义，我们已经知道了他可以从物理坐标（原生像素）转化为逻辑坐标</p><p>那么稍微看一下源码吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> C&gt;<br><span class="hljs-function">T <span class="hljs-title">fromNativePixels</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value, <span class="hljs-type">const</span> C *context)</span></span><br><span class="hljs-function"></span>&#123;<br>    QPoint nativePosition = <span class="hljs-built_in">position</span>(value); <span class="hljs-comment">//转换为QPoint</span><br>    QHighDpiScaling::ScaleAndOrigin so = QHighDpiScaling::<span class="hljs-built_in">scaleAndOrigin</span>(context, &amp;nativePosition);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">scale</span>(value, <span class="hljs-built_in">qreal</span>(<span class="hljs-number">1</span>) / so.factor, so.origin);<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，很短，就三行，我们先来看看<code>QHighDpiScaling::scaleAndOrigin</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QHighDpiScaling::ScaleAndOrigin <span class="hljs-title">QHighDpiScaling::scaleAndOrigin</span><span class="hljs-params">(<span class="hljs-type">const</span> QPlatformScreen *platformScreen, QPoint *nativePosition)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!m_active)<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-built_in">qreal</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">QPoint</span>() &#125;;<br>    <span class="hljs-keyword">if</span> (!platformScreen)<br>        <span class="hljs-keyword">return</span> &#123; m_factor, <span class="hljs-built_in">QPoint</span>() &#125;; <span class="hljs-comment">// the global factor</span><br>    <span class="hljs-type">const</span> QPlatformScreen *actualScreen = nativePosition ?<br>        platformScreen-&gt;<span class="hljs-built_in">screenForPosition</span>(*nativePosition) : platformScreen;<br>    <span class="hljs-keyword">return</span> &#123; m_factor * <span class="hljs-built_in">screenSubfactor</span>(actualScreen), actualScreen-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">topLeft</span>() &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里再次调用<code>screenForPosition()</code>定位了光标所在屏幕，非常严谨</p><p>返回值有俩：</p><ul><li>计算缩放比：<code>m_factor * screenSubfactor(actualScreen)</code>，巴拉巴拉bomb，可能是内部缩放比 * 外部缩放比？不管了</li><li>计算光标所在屏幕的左上角物理坐标：<code>actualScreen-&gt;geometry().topLeft()</code></li></ul><p>这第二个就是重点了，跟我们自行计算的方法有异曲同工之妙，不过他这里获取到的是真真正正的物理坐标</p><p>然后调用<code>scale(value, qreal(1) / so.factor, so.origin)</code>进行最后的计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> QPoint <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">const</span> QPoint &amp;pos, qreal scaleFactor, QPoint origin = QPoint(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-keyword">return</span> (pos - origin) * scaleFactor + origin;<br>&#125;<br></code></pre></td></tr></table></figure><p>哎呀，这不就是我们的计算公式吗</p><p>先减去左上角的坐标，归一化为（0,0），然后直接乘除缩放比，再把左上角加回来 hhhhhh</p><p>啊，哈，啊哈哈哈</p><h4 id="and-MORE"><a href="#and-MORE" class="headerlink" title="and MORE!"></a>and MORE!</h4><p>事情远远没有这么简单（已经很复杂了好嘛喂）</p><p>如图，经过测试，每一块屏幕的虚拟坐标系（黄色区域）是单独计算的，其左上角坐标就是<strong>物理坐标</strong>，（虽然Size是缩放过的）</p><ul><li>测试设备为：4K显示器（150%缩放） + 1080P显示器（100%缩放）</li></ul><p><img src="/img/image-20240313122842885.png" alt="物理坐标系 &amp; 逻辑坐标系（黄）"></p><p>惊天大发现，也就是说，虚拟坐标系中的每一块屏幕是<strong>不连续</strong>的！</p><p>鼠标从右边屏幕的左侧边缘，移动到左侧显示器的右边缘，在Qt内部，逻辑坐标是会发生突变的</p><p><code>(3840,1071) -&gt; (2559,720)</code></p><p>所以，如图所示，每一块显示器的<code>QScreen::geometry().topLeft()</code>其实是准确的<strong>物理坐标</strong>，（虽然其Size是逻辑值）</p><p>因此，第一种转换方案其实也没问题，但是<code>QHighDpi::fromNativePixels</code>显然更简单hhhh</p><p><strong>如果不想引入<code>private</code>模块，直接用第一种方式四则运算自行转换也行</strong></p><h3 id="Other-Problem"><a href="#Other-Problem" class="headerlink" title="Other Problem"></a>Other Problem</h3><p>在多显示器中，我们还可能遇到别的坑</p><p>比如：<code>QListWidget</code>的<code>item</code>的布局没有刷新 &amp; 比例不正确</p><p><strong>更新：</strong>如果不启用<code>QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough)</code>才会出现这个问题</p><p><strong>加上之后，貌似就没问题了~</strong> Over</p><p>此时可以用<code>QListWidget::doItemsLayout</code>进行强制刷新（这个函数居然文档里没有！<code>GPT-4</code>告诉我的）</p><p>不过什么时机用呢？</p><p>貌似没有找到一个<code>signal</code>可以指示窗口从一个显示器到另一个显示器</p><p>那么可以在<code>moveEvent()</code>中，自行检测当前显示器是否发生变化（<code>QScreen</code>）</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>其实如果与Windows 原生API交互不是太多的话，<code>Qt</code>自带的高DPI适配已经足够优秀了，毕竟是跨平台的，推荐使用</p><p>如果有少量Windows API话，可以手动缩放一下坐标，问题不大</p><h2 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h2><p>嘛，反正Qt作为一个看似是前端（传统前端还有浏览器屏蔽细节呢）其实比全栈还要麻烦（要考虑底层系统交互）的技术点</p><p>只能说坑是踩不完的，而且国内用户其实不是很多，资料也不好找</p><p>不说了，都是泪，且看且珍惜，我午饭还没吃呢</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://doc.qt.io/qt-6/qicon.html#high-dpi-icons">QIcon 类 | Qt 图形用户界面 6.6.2 — QIcon Class | Qt GUI 6.6.2</a></p><p><a href="https://doc.qt.io/qt-6/highdpi.html">高DPI | Qt 6.6 — High DPI | Qt 6.6</a></p><p><a href="https://zhuanlan.zhihu.com/p/595553974">Qt之高DPI显示器 - 解决方案整理 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_34305316/article/details/132970047">关于Qt适配不同分辨率和缩放率时可能遇到的问题和解决方案_qt 屏幕分辨率-CSDN博客</a></p><p><a href="https://blog.csdn.net/yinyuchen1/article/details/99607722">Qt高清DPI下的显示，自适应分辨率 qt-CSDN博客</a></p><p><a href="https://blog.csdn.net/startl/article/details/105862817">Qt Windows高清DPI自适应分辨率缩放，比较完美的解决方案-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/451021591">目前Qt有没有比较好解决高分屏下缩放显示的方案？ - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>High-DPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot多环境配置</title>
    <link href="/2024/01/12/Springboot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/12/Springboot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>本文是从[<strong>如何优雅地部署Springboot in Ubuntu</strong>]一文中摘录的，为了便于检索</p><h2 id="正片"><a href="#正片" class="headerlink" title="正片"></a>正片</h2><p>为什么需要<code>Springboot</code>多环境配置呢</p><p>主要原因是我们在开发环境和生产环境（or 测试环境）中对于同一个配置属性可能需要不同的值</p><p>例如：数据库密码、日志存放路径、静态资源服务器地址等等</p><p>所以最方便的方式是写两套配置文件，然后再不同场景进行切换，如：</p><ul><li>application.yml</li><li>application-dev.yml</li><li>application-prod.yml</li></ul><p>注：命名规则：<code>application-&#123;profile&#125;.yml</code><br>注：同名属性优先级：具体配置文件 &gt; 通用配置文件（application.yml）<br>注：其实你想把不同环境配置文件写在一个文件里也可以，用<code>---</code>分割，但是别吧，大哥</p><p>诶等等，怎么有三个配置文件</p><blockquote><p>你傻啊，通用的配置放<code>application.yml</code>就好了难道你要写两遍啊</p></blockquote><p>好的，那要怎么切换配置呢</p><p>默认情况下，也就是<code>default</code>环境，只启用<code>application.yml</code> or properties（这俩一样的，不多赘述）</p><p>有三种方式可以切换</p><ul><li>在<code>application.properties</code>中写上：<code>spring.profiles.active=dev</code> or prod等等</li><li>在<code>java -jar</code>的时候传入命令行参数<code>--spring.profiles.active=prod</code>来激活生产环境配置</li><li>在<code>IDEA</code>中配置：编辑运行&#x2F;调试配置-&gt;活动&#x2F;有效配置（可以找找，这个简单，主要不想放图了）</li></ul><p>怎么知道<code>Springboot</code>现在是什么环境呢？在程序启动的时候会输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">2024-01-12 19:41:19.130 INFO [main] - com.mrbean.test.TestApplication  :  The following 1 profile is active: <span class="hljs-string">&quot;dev&quot;</span><br></code></pre></td></tr></table></figure><p>好的，酱紫就可以完美切换配置文件了，要是还有什么需要修改的，只要在生成环境新建一个<code>application-prod.yml</code>，就可以覆盖对应的属性了，这个大家应该很懂的，我就不说了</p><h3 id="配置文件协作最佳实践"><a href="#配置文件协作最佳实践" class="headerlink" title="配置文件协作最佳实践"></a>配置文件协作最佳实践</h3><p>我们刚刚说了，有三个配置文件，但是一旦进入<code>Git</code>多人协作，就会直接爆炸</p><p>因为每个人的本地环境是不一样的，所以<code>application-dev.yml</code>势必会被改来改去，然后还上传<code>Git</code></p><p>然后<code>pull</code>的时候就会直接覆盖你的开发配置，就会想要 * 队友了</p><h4 id="辣怎么办"><a href="#辣怎么办" class="headerlink" title="辣怎么办"></a>辣怎么办</h4><p>要么就是不上传<code>application-dev.yml</code></p><p>那不成啊，那想新增&#x2F;修改配置，其他成员完全阿巴怎么办</p><p>其实我们可以建立<code>application-dev-template.yml</code>文件，作为模板，非必要不修改这个文件</p><p>然后每个成员自己根据模板新建<code>application-dev.yml</code>，且加入<code>.gitignore</code>不上传<code>Git</code></p><h2 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/qq_44885775/article/details/123471021">31 SpringBoot多环境的切换(生产环境、开发环境、测试环境)_spring boot生产和开发环境-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot Util工具类如何读取配置文件(yml)</title>
    <link href="/2024/01/08/Springboot-Util%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-yml/"/>
    <url>/2024/01/08/Springboot-Util%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-yml/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，没有<code>Util</code>工具类的<code>Java</code>程序是不完整的</p><p>这天，我们打开了一个<code>Springboot</code>项目，并打算加入一个通用方法（用来拼接静态资源请求路径），那就写一个<code>Util</code>类吧</p><blockquote><p> <strong>GPT-4:</strong><br>在Java中，一个典型的工具（Util）类通常包含一些静态方法，这些方法用于提供通用的、非特定于对象的功能。这些类通常被设计成不可实例化和不可继承的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;staticServer&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String staticServer; <span class="hljs-comment">//静态资源服务器地址</span><br>    <br>    <span class="hljs-comment">// 私有构造函数，防止实例化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyUtils</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;No MyUtils instances for you!&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//拼接完整静态资源URL，如 https://static.server/images/cat.jpg</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getStaticResourceURI</span><span class="hljs-params">(String prefix, String filename)</span> &#123;<br>        <span class="hljs-keyword">return</span> staticServer + prefix + <span class="hljs-string">&#x27;/&#x27;</span> + encodeUri(filename);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encodeUri</span><span class="hljs-params">(String uri)</span> &#123;<br>        <span class="hljs-keyword">return</span> UriUtils.encode(uri, StandardCharsets.UTF_8);<br>    &#125;<br></code></pre></td></tr></table></figure><p>优雅，太优雅了</p><p>编译！</p><p>运行！</p><p>Bomb！</p><p>好的，完犊子了，你猜这怎么着，<code>staticServer == null</code></p><h2 id="可怜-弱小-又无助"><a href="#可怜-弱小-又无助" class="headerlink" title="可怜 弱小 又无助"></a>可怜 弱小 又无助</h2><p>这不核理，为什么会这样呢，对静态成员的注入从技术上应该是可以实现的</p><p>不过静态成员并不属于实例对象，可能与<code>IOC</code>容器 &amp; 依赖注入的理念不符，所以<code>Springboot</code>并不直接支持</p><h2 id="辣怎办"><a href="#辣怎办" class="headerlink" title="辣怎办"></a>辣怎办</h2><p>但是这个需求很合理好吧，在工具类中用到配置文件中的键值</p><h3 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a>Pre</h3><p>不过丑话说在前头，如果要想进行依赖注入，那么<code>Util</code>类必须是一个<code>Bean</code>，因为只有<code>Bean</code>才能被<code>IOC</code>容器管理</p><p>所以，<code>Util</code>的构造函数不能是私有的，还真就得开放给<code>Springboot</code>使用</p><p>总不能又要隐私，又要躺着把钱挣了吧（哪有这好事）</p><p>所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-comment">//private MyUtils() &#123; 公开啦！哭</span><br>    <span class="hljs-comment">//    throw new AssertionError(&quot;No MyUtils instances for you!&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-利用set方法注入"><a href="#1-利用set方法注入" class="headerlink" title="1. 利用set方法注入"></a>1. 利用set方法注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String staticServer; <span class="hljs-comment">//静态资源服务器地址</span><br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;staticServer&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStaticServer</span><span class="hljs-params">(String staticServer)</span> &#123; <span class="hljs-comment">//</span><br>        Util.staticServer = staticServer;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getStaticResourceURI</span><span class="hljs-params">(String prefix, String filename)</span> &#123;<br>        <span class="hljs-keyword">return</span> staticServer + prefix + <span class="hljs-string">&#x27;/&#x27;</span> + encodeUri(filename);<br>    &#125;<br>...<br>    &#125;<br></code></pre></td></tr></table></figure><p>把<code>@Value</code>写在非静态成员方法上，就可以正常被执行</p><p>然后在函数体里对<code>static</code>成员赋值，狸猫换太子</p><h3 id="2-利用-PostConstruct注解"><a href="#2-利用-PostConstruct注解" class="headerlink" title="2. 利用@PostConstruct注解"></a>2. 利用@PostConstruct注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;staticServer&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String staticServer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Util INS;<br><br>    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">// 在构造函数和依赖注入完成后执行；构造方法 &gt; @Autowired &gt; @PostConstruct，毕竟构造完成才能注入成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        INS = <span class="hljs-built_in">this</span>; <span class="hljs-comment">// 获取Bean实例，赋值给静态变量，方便static函数访问</span><br>    &#125; <span class="hljs-comment">// 容器管理的Bean默认是单例的，所以这里的INS是唯一的</span><br><br>    <span class="hljs-comment">// 拼接完整静态资源URL，只对filename进行编码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getStaticResourceURI</span><span class="hljs-params">(String prefix, String filename)</span> &#123;<br>        <span class="hljs-keyword">return</span> INS.staticServer + prefix + <span class="hljs-string">&#x27;/&#x27;</span> + encodeUri(filename);<br>    &#125;<br><br>    <span class="hljs-comment">// 对uri进行编码，注意&#x27;/&#x27;也会被编码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encodeUri</span><span class="hljs-params">(String uri)</span> &#123;<br>        <span class="hljs-keyword">return</span> UriUtils.encode(uri, StandardCharsets.UTF_8); <span class="hljs-comment">//URLEncoder会把&#x27; &#x27;编码为&#x27;+&#x27;而非&#x27;%20&#x27;造成错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这个名字（<code>@PostConstruct</code>），不知道大家有没有想起什么</p><p>二叉树的后序遍历：<strong>PostOrder</strong></p><p>诶，为什么都是<code>Post</code>，马萨卡</p><p>对喽，<code>PostConstruct</code>是在构造函数之后执行的，核理</p><p>由于执行顺序是：<code>构造方法 &gt; @Autowired &gt; @PostConstruct</code></p><p>所以，执行<code>@PostConstruct</code>的时候，<code>staticSever</code>已经注入完成，不用担心，一切就绪</p><p>我们只要把<code>IOC</code>容器中的<code>Util</code>实例的<code>this</code>指针赋值给<code>static</code>变量<code>INS</code>即可（指针的赋值啊，问题不大）</p><blockquote><p> 什么，你问我哪来的<code>this</code>？</p><p>你加了@Component注册为了Bean，IOC容器默认会构造单例对象的</p></blockquote><blockquote><p>什么，你问我<code>Util</code>开放了构造函数有多个实例怎么办？</p><p>@Component默认是单例的，问题不大，只要你不要自己构造一个出来</p></blockquote><blockquote><p>什么，你问我要是同事构造了<code>Util</code>怎么办？</p><p>砍了ta</p><p>问题不大，本来也没存什么状态</p></blockquote><h3 id="3-ConfigurationProperties"><a href="#3-ConfigurationProperties" class="headerlink" title="3. @ConfigurationProperties"></a>3. @ConfigurationProperties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Util</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String staticServer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStaticServer</span><span class="hljs-params">(String staticServer)</span> &#123;<br>        Util.staticServer = staticServer;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个其实本质上也是利用<code>set</code>方法进行注入的，所以并不违反规则</p><p>好的好的，下班</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/myli92/article/details/124183788">springboot注入静态变量的两种方式_springboot 注入静态变量-CSDN博客</a></p><p><a href="https://cloud.tencent.com/developer/article/1896241">SpringBoot中静态变量注入方案,一网打尽-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://www.jianshu.com/p/149c5a951ffc">@ConfigurationProperties与静态加载配置文件 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Nginx部署https网站（前后端）</title>
    <link href="/2024/01/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Nginx%E9%83%A8%E7%BD%B2https%E7%BD%91%E7%AB%99%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%EF%BC%89/"/>
    <url>/2024/01/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Nginx%E9%83%A8%E7%BD%B2https%E7%BD%91%E7%AB%99%EF%BC%88%E5%89%8D%E5%90%8E%E7%AB%AF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>别急 过几天写</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅地部署Springboot in Ubuntu</title>
    <link href="/2024/01/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%83%A8%E7%BD%B2Springboot-in-Ubuntu/"/>
    <url>/2024/01/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%83%A8%E7%BD%B2Springboot-in-Ubuntu/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Springboot</code>内置了<code>Tomcat</code>，默认打<code>jar</code>包，部署非常方便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java -jar test.jar<br>  .   ____          _            __ _ _<br> /\\ / ___<span class="hljs-string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="hljs-string">( ( )\___ | &#x27;</span>_ | <span class="hljs-string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \<br> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  <span class="hljs-string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="hljs-string"> =========|_|==============|___/=/_/_/_/</span><br><span class="hljs-string"> :: Spring Boot ::                (v3.2.1)</span><br></code></pre></td></tr></table></figure><p>好，舒服了，下班！</p><h3 id="别急"><a href="#别急" class="headerlink" title="别急"></a>别急</h3><p>在你关上电脑的那一瞬间，终端与服务器断开连接，<code>Springboot</code>后端直接<strong>BOMB</strong></p><p>好的，你可以加班了</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>SSH终端中开启的进程默认是终端的子进程，终端关闭后，子进程也会一并停止（收到<code>SIGHUP</code>信号）</p><h3 id="肿么办"><a href="#肿么办" class="headerlink" title="肿么办"></a>肿么办</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> java -jar test.jar &amp;<br></code></pre></td></tr></table></figure><p>问题不大，只要加上<code>nohup</code>和<code>&amp;</code>即可</p><ul><li><code>nohup</code>：No Hang UP，意为忽略挂断信号（<code>SIGHUP</code>）。即使SSH会话结束，这个进程仍会继续运行</li><li><code>&amp;</code>：将命令放入后台执行。当你在命令的末尾加上<code>&amp;</code>，这个命令会立即返回，而不会阻塞当前的终端</li></ul><p>完美，酱紫<code>Springboot</code>就可以在后台安稳运行了</p><p>下班！</p><h3 id="等一下"><a href="#等一下" class="headerlink" title="等一下"></a>等一下</h3><p>没五分钟，前端坐不住了：</p><blockquote><p>诶，你这个怎么<code>500 Internal Server Error</code></p></blockquote><h3 id="你又回到了工位上"><a href="#你又回到了工位上" class="headerlink" title="你又回到了工位上"></a>你又回到了工位上</h3><p>打开电脑，连上服务器，面对空白的终端，心想：</p><blockquote><p>诶，我日志呢</p></blockquote><p>尬住了</p><p>不过好在，<code>ls</code>一下，发现<code>test.jar</code>同目录多了一个<code>nohup.out</code>文件，还好里面就是日志，呼呼呼</p><h3 id="自定义日志路径"><a href="#自定义日志路径" class="headerlink" title="自定义日志路径"></a>自定义日志路径</h3><p>不过，有没有办法自定义一下日志文件名和目录呢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> java -jar test.jar &gt; test.log 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>可以使用<code>&gt;</code>符号，来重定向标准输出</p><ul><li><code>&gt; test.log</code>：重定向标准输出（标识为1）到<code>test.log</code>文件</li><li><code>2&gt;&amp;1</code>：将标准错误（2）重定向到标准输出（&amp;1）（取地址符！，<code>C++</code>人狂喜）</li></ul><p>好的，酱紫，标准输出，和错误输出，都到<code>test.log</code>文件了，完美</p><blockquote><p>太Perfect了，我就是命令行的神，下班！</p></blockquote><h3 id="坐下"><a href="#坐下" class="headerlink" title="坐下"></a>坐下</h3><p>前端说的<code>500 Internal Server Error</code>还没解决呢，下啥班</p><p>哦哦，那行吧</p><p>看了眼日志，在<code>IDEA</code>里吭哧吭哧一顿改，重新打包，拷贝到服务器上</p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>那么问题来了，如何重启<code>Springboot</code></p><p>这个简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -aux | grep java<br></code></pre></td></tr></table></figure><p>然后再根据进程ID，执行<code>kill</code></p><p>完美，接下来只要再依葫芦画瓢进行<code>java -jar</code>就好啦hhhhhhh</p><p>哦 又忘了 <code>nohup</code> 靠</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>话说，<code>Springboot</code>默认在工作目录下寻找<code>.yml | .properties</code>配置文件，而不是<code>.jar</code>同目录下哦</p><p>配置文件加载优先级：</p><ul><li><strong>当前工作目录</strong>（从中启动应用的目录）下的<code>/config</code>子目录。</li><li><strong>当前工作目录</strong>。</li><li><strong>classpath</strong>下的<code>/config</code>包。</li><li><strong>classpath</strong>的根路径。</li></ul><p>酱紫最好手动指定一下绝对路径哦</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> java -jar test.jar --spring.config.location=file:/www/Springboot/TestDir/ &gt; test.log 2&gt;&amp;1 &amp; <br></code></pre></td></tr></table></figure><p>好的，怎么好像手敲的压力开始增大了 &#x2F;汗</p><p><del>（小声：还有虚拟机参数 <code>-Xmx1024M -Xms256M</code> 巴拉巴拉的）</del></p><p><del>（小声：还有开机自启动巴拉的）</del></p><h2 id="Systemd-服务进程"><a href="#Systemd-服务进程" class="headerlink" title="Systemd 服务进程"></a>Systemd 服务进程</h2><p>不会吧，不会吧，不会还有人命令行裸敲<code>java -jar</code>，美其名曰<strong>部署</strong>吧</p><h3 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h3><blockquote><p>systemd 是 Linux 上的一种系统和服务管理器，用于管理系统上运行的进程和服务。systemd 服务是一种可以由 systemd 管理的后台进程或服务</p></blockquote><p>我们可以将<code>Springboot</code>程序制作为<code>systemd</code>服务，就可以方便地启动、停止、重启以及状态检测</p><h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><p>首先，我们需要将<code>Springboot</code>程序注册为Systemd服务</p><p>很简单，只要在<code>/etc/systemd/system/</code>目录下，创建<code>myapp.service</code>文件即可（服务单元文件，文件名即服务名）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=My Spring Boot Application<br><span class="hljs-comment"># 服务描述：这里描述了服务的功能或用途</span><br><span class="hljs-attr">After</span>=syslog.target network.target<br><span class="hljs-comment"># 依赖性和顺序：指定了该服务在哪些服务之后启动。这里指定了在syslog和网络服务（network.target）之后启动。</span><br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">User</span>=somebody     <br><span class="hljs-comment"># 运行服务的用户</span><br><span class="hljs-attr">WorkingDirectory</span>=/opt/Test/ <br><span class="hljs-comment"># 工作目录</span><br><span class="hljs-attr">ExecStart</span>=java -jar Test-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar --spring.profiles.active=prod<br><span class="hljs-comment"># 启动命令：指定启动服务时执行的命令</span><br><span class="hljs-attr">SuccessExitStatus</span>=<span class="hljs-number">143</span><br><span class="hljs-comment"># 成功退出状态码：当服务以这些状态码退出时，将被视为正常退出。143是Spring Boot应用在接收到SIGTERM信号时的标准退出代码</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><span class="hljs-comment"># 安装设置：指定当使用 &#x27;systemctl enable&#x27; 命令启用服务时，该服务应该被哪个目标所引用</span><br><span class="hljs-comment"># 这意味着，当系统达到multi-user.target时，你的服务会自动启动</span><br><span class="hljs-comment"># multi-user.target 适用于多用户的运行级别，这意味着服务将在系统达到多用户模式时启动</span><br></code></pre></td></tr></table></figure><p>有几点需要注意</p><ol><li>将<code>Springboot</code>配置为系统服务后，不需要再<code>nohup</code>，默认开启新后台进程</li><li>我们指定了工作目录，会自动寻找配置文件，不需要再指定</li><li>关于工作目录的选址，最好是放在<code>/opt/</code>下，而不是用户的<code>home</code>目录，这样方便之后<code>Nginx</code>访问静态资源，而且这个目录是专门用于第三方应用的</li><li>关于User，随便指定一个普通用户就行了（最好不要root）</li><li>一般只需要更改<code>WorkingDirectory</code> &amp; <code>ExecStart</code>，其他的无伤大雅</li></ol><p>完成之后，我们需要通知<code>systemd</code>服务重载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>然后启动<code>myapp</code>服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start myapp<br></code></pre></td></tr></table></figure><p>服务默认是没有开机自启动的，不过也可以方便地开启或关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> myapp<br>sudo systemctl <span class="hljs-built_in">disable</span> myapp<br></code></pre></td></tr></table></figure><p>停止 &amp; 重启也是信手拈来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl stop myapp<br>sudo systemctl restart myapp<br></code></pre></td></tr></table></figure><p>还可以使用<code>status</code>命令查看运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status myapp.service<br>● myapp.service - My Spring Boot Application<br>     Loaded: loaded (/etc/systemd/system/myapp.service; disabled; vendor preset: enabled)<br>     Active: active (running) since Sat 2024-01-06 20:45:56 CST; 5 days ago<br>   Main PID: 109708 (java)<br>      Tasks: 37 (<span class="hljs-built_in">limit</span>: 4150)<br>     Memory: 210.4M<br>        CPU: 7min 33.637s<br>     CGroup: /system.slice/myapp.service<br>             └─109708 java -jar Test-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod<br><br>Jan 06 20:45:58 ubuntu-HK java[109708]:   .   ____          _            __ _ _<br>Jan 06 20:45:58 ubuntu-HK java[109708]:  /\\ / ___<span class="hljs-string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="hljs-string">Jan 06 20:45:58 ubuntu-HK java[109708]: ( ( )\___ | &#x27;</span>_ | <span class="hljs-string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \<br>Jan 06 20:45:58 ubuntu-HK java[109708]:  \\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>Jan 06 20:45:58 ubuntu-HK java[109708]:   <span class="hljs-string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="hljs-string">Jan 06 20:45:58 ubuntu-HK java[109708]:  =========|_|==============|___/=/_/_/_/</span><br><span class="hljs-string">Jan 06 20:45:58 ubuntu-HK java[109708]:  :: Spring Boot ::                (v3.0.1)</span><br></code></pre></td></tr></table></figure><p>我们可以看到<code>.service</code>文件的位置，是否开机自启，以及当前的状态（active (running)）</p><p>同时，我们还能看到程序的部分日志</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>对了，应用程序变成一个系统服务之后，日志是如何管理的呢</p><h3 id="Default"><a href="#Default" class="headerlink" title="Default"></a>Default</h3><p>默认情况下，应用的所有标准输出（stdout）和标准错误（stderr）日志都会被<code>systemd</code>捕获</p><p><code>systemd</code>使用<code>journald</code>服务来管理这些日志，可以通过<code>journalctl</code>命令来查看和管理这些日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo journalctl -u myapp<br></code></pre></td></tr></table></figure><p>看似很方便，但是失去了对日志的控制权</p><p>如何分割日志，如何清理日志，都变得不太可控</p><h3 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h3><p><code>Springboot</code>默认支持了<code>Logback</code>日志框架（实现了<code>Slf4j</code>日志门面）</p><p>所以只需要修改一下配置文件，即可输出日志到文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">logging.file.name</span>=<span class="hljs-string">myapp.log</span><br><span class="hljs-attr">logging.file.path</span>=<span class="hljs-string">/var/log</span><br></code></pre></td></tr></table></figure><p>好的，现在日志已经以文件的形式保存下来了</p><p>但是为什么<code>journalctl -u myapp</code>还是可以看到日志呢？</p><p>这是因为日志同时输出到了控制台（标准输出、错误输出） &amp; 文件</p><p>所以日志输出到了两个目的地，控制台的输出被<code>journalctl</code>捕获，这样势必会造成空间浪费</p><p>所以我们需要关闭控制台输出，并且为了更精细地控制日志策略（滚动分割等），我们最好还是自己写<code>Logback</code>的配置文件</p><h4 id="Logback配置文件"><a href="#Logback配置文件" class="headerlink" title="Logback配置文件"></a>Logback配置文件</h4><p>我们可以在工程的<code>Resources</code>文件夹下新建<code>logback-spring.xml</code>文件</p><p>其实也可以是<code>logback.xml</code>，但是这么写是不能读取<code>Springboot</code>的配置文件的（听说有些版本不能）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--从 yml|properties 配置文件中读取键值 以方便修改日志路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_HOME&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;log.path&quot;</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;logs-default&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%p：级别 %msg：日志消息，%n是换行符--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %p [%t] - %logger&#123;50&#125;  :  %m%n&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PATTERN_COLOR&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight(%p) [%t] - %cyan(%logger&#123;50&#125;)  :  %m%n&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--高亮会输出多余字符，所以在FILE中不开启--&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--配置控制台输出--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN_COLOR&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--文件日志， 按照每天生成日志文件，优先级高于yml文件中的logging.file.path--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件输出的文件名--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; OFF--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- dev环境不输出到文件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- prod环境仅输出到文件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以在<code>.properties</code>配置文件里指定日志文件路径（自定义键）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">log.path</span>=<span class="hljs-string">/logs</span><br></code></pre></td></tr></table></figure><p>为了避免和内置的<code>logging.file.path</code>冲突，我们这里采用了自定义键</p><p>小贴士：其实我们在<code>logback-spring.xml</code>中自定义了输出的文件位置之后，<code>logging.file.path</code>会被覆盖，用户的<code>xml</code>配置文件优先级更高</p><p>但是为了语义更清晰，还是采用自定义键吧（ba）</p><h4 id="Logback多环境配置"><a href="#Logback多环境配置" class="headerlink" title="Logback多环境配置"></a>Logback多环境配置</h4><p>注意，我们采用了<code>&lt;springProfile name=&quot;dev&quot;&gt;</code>这样标签</p><p>ta可以根据<code>Springboot</code>当前激活的配置文件（环境），来动态得采取不同的日志策略，如：</p><ul><li>在<code>dev</code>开发环境中，仅输出日志到控制台</li><li>在<code>prod</code>生产环境中，仅输出日志到文件（防止输出到控制台被<code>journalctl</code>捕获，产生两份日志）</li></ul><h2 id="Springboot多环境配置"><a href="#Springboot多环境配置" class="headerlink" title="Springboot多环境配置"></a>Springboot多环境配置</h2><p>刚刚提到了根据<code>Springboot</code>当前环境来选择日志策略</p><p>那么<code>Springboot</code>环境配置是什么意思呢</p><p>主要原因是我们在开发环境和生产环境中对于同一个配置属性可能需要不同的值</p><p>例如：数据库密码、日志存放路径、静态资源服务器地址等等</p><p>所以最方便的方式是写两套配置文件，然后再不同场景进行切换，如：</p><ul><li>application.yml</li><li>application-dev.yml</li><li>application-prod.yml</li></ul><p>注：命名规则：<code>application-&#123;profile&#125;.yml</code><br>注：同名属性优先级：具体配置文件 &gt; 通用配置文件（application.yml）<br>注：其实你想把不同环境配置文件写在一个文件里也可以，用<code>---</code>分割，但是别吧，大哥</p><p>诶等等，怎么有三个配置文件</p><blockquote><p>你傻啊，通用的配置放<code>application.yml</code>就好了难道你要写两遍啊</p></blockquote><p>好的，那要怎么切换配置呢</p><p>默认情况下，也就是<code>default</code>环境，只启用<code>application.yml</code> or properties（这俩一样的，不多赘述）</p><p>有三种方式可以切换</p><ul><li>在<code>application.properties</code>中写上：<code>spring.profiles.active=dev</code> or prod等等</li><li>在<code>java -jar</code>的时候传入命令行参数<code>--spring.profiles.active=prod</code>来激活生产环境配置</li><li>在<code>IDEA</code>中配置：编辑运行&#x2F;调试配置-&gt;活动&#x2F;有效配置（可以找找，这个简单，主要不想放图了）</li></ul><p>怎么知道<code>Springboot</code>现在是什么环境呢？在程序启动的时候会输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">2024-01-12 19:41:19.130 INFO [main] - com.mrbean.test.TestApplication  :  The following 1 profile is active: <span class="hljs-string">&quot;dev&quot;</span><br></code></pre></td></tr></table></figure><p>好的，酱紫就可以完美切换配置文件了，要是还有什么需要修改的，只要在生成环境新建一个<code>application-prod.yml</code>，就可以覆盖对应的属性了，这个大家应该很懂的，我就不说了</p><h3 id="配置文件协作最佳实践"><a href="#配置文件协作最佳实践" class="headerlink" title="配置文件协作最佳实践"></a>配置文件协作最佳实践</h3><p>（这文就写不完了是吧！）</p><p>我们刚刚说了，有三个配置文件，但是一旦进入<code>Git</code>多人协作，就会直接爆炸</p><p>因为每个人的本地环境是不一样的，所以<code>application-dev.yml</code>势必会被改来改去，然后还上传<code>Git</code></p><p>然后<code>pull</code>的时候就会直接覆盖你的开发配置，就会想要 * 队友了</p><h4 id="辣怎么办"><a href="#辣怎么办" class="headerlink" title="辣怎么办"></a>辣怎么办</h4><p>要么就是不上传<code>application-dev.yml</code></p><p>那不成啊，那想新增&#x2F;修改配置，其他成员完全阿巴怎么办</p><p>其实我们可以建立<code>application-dev-template.yml</code>文件，作为模板，非必要不修改这个文件</p><p>然后每个成员自己根据模板新建<code>application-dev.yml</code>，且加入<code>.gitignore</code>不上传<code>Git</code></p><h2 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h2><p>完美，这下总可以下班了吧</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/chengmin123456789/article/details/108829987">Springboot 指定运行时配置文件的几种方式_dspring.config.location-CSDN博客</a></p><p><a href="https://juejin.cn/post/7230415879883276346">关于 springboot 服务制作成 systemd 服务 - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/106234119">Spring boot使用logback实现多环境配置 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_44885775/article/details/123471021">31 SpringBoot多环境的切换(生产环境、开发环境、测试环境)_spring boot生产和开发环境-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Ubuntu</tag>
      
      <tag>部署</tag>
      
      <tag>多环境</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git:如何将[仅源码(zip)]与远端仓库关联</title>
    <link href="/2023/12/15/Git-%E5%A6%82%E4%BD%95%E5%B0%86-%E4%BB%85%E6%BA%90%E7%A0%81-zip-%E4%B8%8E%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/"/>
    <url>/2023/12/15/Git-%E5%A6%82%E4%BD%95%E5%B0%86-%E4%BB%85%E6%BA%90%E7%A0%81-zip-%E4%B8%8E%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，大中华区信号不要太好，打不通<code>Github</code>是常态</p><p><code>git clone</code>也是时常<code>error</code></p><p>对于一个大仓库，还不如直接下载<code>源码zip</code>来得快</p><p>但是解压之后我们会发现，这个<code>zip</code>里没有<code>.git</code>文件夹，宛如一只离开蜂群的无人机，再也无法回家</p><p>没有<code>.git</code>文件夹就意味着没有加入版本控制，就无法与远端<code>Github</code>仓库产生联系，就是裸代码（<code>raw codes</code>），再也无法<code>fetch</code>和<code>push</code>了，哭</p><h2 id="辣怎么办"><a href="#辣怎么办" class="headerlink" title="辣怎么办"></a>辣怎么办</h2><blockquote><p>辣就喝牛奶</p></blockquote><p>不管怎么说，总得先创建一个本地<code>git</code>仓库吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br></code></pre></td></tr></table></figure><p>ok，那么怎么和远端<code>Github</code>仓库产生关联呢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin https://github.com/XXX/XXX.git<br></code></pre></td></tr></table></figure><p>酱紫就添加了一个名为<code>origin</code>的远程仓库了</p><p>反映在<code>.git\config</code>文件中就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs config">[remote &quot;origin&quot;]<br>url = https://github.com/XXX/XXX.git<br>fetch = +refs/heads/*:refs/remotes/origin/*<br></code></pre></td></tr></table></figure><p>这段表明：</p><ul><li>声明了一个远端仓库，名为<code>origin</code></li><li>其<code>url</code>为：<code>https://github.com/XXX/XXX.git</code></li><li>执行 <code>git fetch</code> 操作时，远程仓库的所有分支会被抓取并强制更新到本地的 <code>origin/*</code> 引用上（简而言之就是用远端更新本地）</li></ul><h3 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a>By the way</h3><p>其实一个远程仓库也可以对应两个<code>url</code>（如：同时推送到gitee和github）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote set-url --add origin git@github.com:XXX/XXX.git<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs config">[remote &quot;origin&quot;]<br>url = https://gitee.com/XXX/XXX.git<br>url = git@github.com:XXX/XXX.git    #这里用git或http协议都可以<br>fetch = +refs/heads/*:refs/remotes/origin/*<br></code></pre></td></tr></table></figure><p>类似酱，那么问题来了，从哪个url fetch呢</p><blockquote><p>答：默认是第一个url</p></blockquote><p>且<code>push</code>时会同时向两个<code>url</code>推送，可以用<code>git remote -v</code>查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">origin  https://gitee.com/XXX/XXX.git (fetch)<br>origin  https://gitee.com/XXX/XXX.git (push)<br>origin  git@github.com:XXX/XXX.git (push)<br></code></pre></td></tr></table></figure><h3 id="Okay-back"><a href="#Okay-back" class="headerlink" title="Okay back"></a>Okay back</h3><p>现在，我们有了一个远程仓库<code>origin</code>，但也仅此而已</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -a<br></code></pre></td></tr></table></figure><p>可以发现什么都没有输出，甚至连一个本地分支都没有（主分支也没有）</p><p>啥也没有了属于是，<code>no commit, no branch</code></p><p>那咋整啊，不管了，先<code>fetch</code>一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch <span class="hljs-comment">#默认从origin拉取 因为只有一个仓库</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -a<br>  remotes/origin/dev<br>  remotes/origin/master<br></code></pre></td></tr></table></figure><p>太好了，现在有了几个远程分支，但是仍然没有本地分支（<code>git branch</code>显示当前分支为空）</p><p>为什么没有本地分支，也没有当前分支呢？</p><p>因为没有<code>commit</code>，HEAD指针就不知道指向谁，也就没有分支了</p><p>所以这种情况下，我们其实还是没有和远端产生较好的关联（没有本地分支跟踪远程分支）</p><p>同时，由于没有活动分支，也无法进行<code>merge</code>（众所周知，<code>pull = fetch + merge</code>）</p><p>那么，我们要怎么让本地拥有和远端<code>master</code>一样的<code>commit</code>记录呢？</p><p>其实就是检出（<code>checkout</code>）到远程分支嘛</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b master origin/master<br><span class="hljs-comment"># git checkout -b [branch-name] origin/[branch-name]</span><br><span class="hljs-comment"># 这会创建一个名为 [branch-name] 的新本地分支，该分支跟踪远程的 origin/[branch-name] 分支。</span><br></code></pre></td></tr></table></figure><p>在较新Git版本中，如果本地不存在<code>master</code>分支，也可以简写为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br></code></pre></td></tr></table></figure><p>Git 会自动创建一个新的本地分支 <code>master</code> 并将其设置为跟踪远程的 <code>master</code> 分支，这在 Git 2.23 及以上版本中更常见</p><p>但是显然，无论是哪个命令，<code>checkout</code>都会失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master <br>error: The following untracked working tree files would be overwritten by checkout:<br>        README.md<br>        abc.txt<br>Please move or remove them before you switch branches.<br>Aborting<br></code></pre></td></tr></table></figure><p>这是因为：工作目录中存在一些未跟踪的文件，这些文件在远程<code>master</code> 分支中也存在，因此Git 阻止了分支切换以避免这些未跟踪文件被覆盖</p><h4 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h4><ol><li>删除所有未跟踪文件：<code>git clean -f</code></li><li>暂存：<code>git stash --include-untracked</code></li><li>提交：<code>git add . &amp; git commit -m &quot;Add untracked files&quot;</code></li><li>强制切换：<code>git checkout -f master</code></li></ol><p>好的，我们还是强制切换吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -f master<br>Switched to a new branch <span class="hljs-string">&#x27;master&#x27;</span><br>branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-built_in">set</span> up to track <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br></code></pre></td></tr></table></figure><p>Perfect</p><p>现在就跟直接执行<code>git clone</code>之后的仓库一毛一样了</p><h3 id="好好好-再提一嘴-跟踪分支是怎么回事"><a href="#好好好-再提一嘴-跟踪分支是怎么回事" class="headerlink" title="好好好 再提一嘴 跟踪分支是怎么回事"></a>好好好 再提一嘴 跟踪分支是怎么回事</h3><blockquote><p>branch ‘master’ set up to track ‘origin&#x2F;master’.</p></blockquote><p>注意这一句提示，<code>checkout</code>的时候本地<code>master</code>自动跟踪的远程的<code>origin master</code>分支</p><p>这个体现在<code>.git\config</code>就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs config">[branch &quot;master&quot;]<br>remote = origin<br>merge = refs/heads/master<br></code></pre></td></tr></table></figure><p>意味着，<code>pull</code> &amp; <code>merge</code>的时候，自动合并<code>origin</code>仓库的<code>master</code>分支，也就是跟踪了远程分支嘛 差不多就酱</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>我们刚刚采用的是<code>fetch + checkout -f</code>法，那能不能直接<code>pull</code>呢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git pull origin master<br>...<br>error: The following untracked working tree files would be overwritten by merge:<br>        README.md<br>        abc.txt<br>Please move or remove them before you merge.<br>Aborting<br><br>$ git branch -a<br>  remotes/origin/master<br></code></pre></td></tr></table></figure><p>好的，显然是不行，但是从这里我们可以清晰地看到<code>pull = fetch + merge</code></p><p>那么原因还是类似，有未跟踪文件存在，且有被覆盖的风险</p><p>那么<code>pull</code>或<code>merge</code>有没有类似<code>-f</code>的强制指令呢</p><p>答案是没有，因为<code>checkout</code>是切换分支，有覆盖的语义，但是<code>merge</code>或<code>pull</code>是合并两个分支，是平等的</p><p>所以我们只能手动清理这些文件了</p><p>由于这些代码是直接下载的<code>zip</code>，我们也没有修改，所以删了也不心疼，待会儿<code>pull</code>就恢复了，所以直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git clean -f<br></code></pre></td></tr></table></figure><p>库擦一下，工作区空了 &#x2F;哭</p><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git pull origin master<br>From https://github.com/Zulaikha12/git-test<br> * branch            master     -&gt; FETCH_HEAD<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -a<br>* master<br>  remotes/origin/master<br></code></pre></td></tr></table></figure><p>直接完美成功，本地也有了<code>master</code>分支</p><p>但是聪明的小伙伴可能发现了，本地没有分支怎么能<code>merge</code></p><p>根据<code>GPT-4</code>的说法：<code>Git</code>会自动帮我们<code>checkout</code>一个新分支并跟踪远程分支巴拉，反正就是噼里啪啦就好了</p><blockquote><p>注：实测发现，nonono，并不会自动设置远程跟踪分支，需要手动设置<br><code>git branch --set-upstream-to=origin/master master</code></p></blockquote><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>如果仓库实在太大，<code>fetch</code>跟<code>clone</code>其实压力是一样的</p><p>（只不过下载zip能让你更快地开始工作，之后再考虑fetch）&amp; 玄学：说不定fetch网络更好</p><p>咳咳</p><p>其实我们可以只<code>clone</code>最近的几次提交（浅克隆）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> --depth 1 https://github.com/XXX/XXX<br></code></pre></td></tr></table></figure><p>如果需要完整的历史记录，可以通过 <code>git fetch --unshallow</code> 将浅克隆的仓库转换为完整的仓库；这个命令会拉取剩余的历史记录。</p><p>Peace</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><code>GPT-4</code></p><p><a href="https://zhuanlan.zhihu.com/p/597688197">加速几十倍 git clone 速度的 –depth 1，它的后遗症怎么解决？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/astonishqft/article/details/83029490">git切换到指定远程分支_git 切换远程分支-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步的本质</title>
    <link href="/2023/11/29/%E5%BC%82%E6%AD%A5%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2023/11/29/%E5%BC%82%E6%AD%A5%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知：多进程、多线程</p><p>众也周闻：异步（Asynchronous）、协程（Coroutine）</p><p>人尽皆知：同步（Synchronous）、阻塞</p><p>我们常处于一种：清晰的混沌态；知而又不知</p><blockquote><p> 这就好像你知道自己拥有意识，可什么是意识</p></blockquote><blockquote><p>馒头卡即答：意识与枪法并重，能够在天时地利下做出正确决断，在殊死绝境中反败为胜</p></blockquote><h2 id="问天"><a href="#问天" class="headerlink" title="问天"></a>问天</h2><p>什么是异步呢？</p><p>也许这个问题有点难，那么，什么是同步呢</p><p>可能也不好回答</p><p>让我们举一个例子吧：发送网络请求并等待响应（或者说点餐并等待上菜）</p><ul><li>同步的代码是阻塞的：作为一个普通的单线程程序，执行流将卡在<code>wait()</code>这一行，直到服务器发来响应，那么用户将看到一个卡死的界面</li><li>异步的代码是非阻塞的：我们提交请求（sbmit）后，那行发送请求的函数代码直接返回，并不理会响应，直接执行之后的其他逻辑</li></ul><p>那么问题来了，异步的代码直接返回，不等待响应，那么如何获取响应呢？</p><h2 id="如何实现异步"><a href="#如何实现异步" class="headerlink" title="如何实现异步"></a>如何实现异步</h2><p>实现机制有很多，例如前端的<code>XMLHttpRequest</code>采用的是多进程</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>主进程通过<code>IPC</code>（进程间通信）利用网络进程发送和管理请求，网络进程代替主线程去监控响应的返回与否，并适时通知主进程（通过消息队列）</p><p>主进程有一个事件循环（与<code>Qt</code>类似），会轮询消息队列，获取响应</p><img src="/img/image-20231129203822655.png" alt="XMLHttpRequest请求" style="zoom: 80%;" /><p>如此一来，主渲染进程就无须等待响应，可以执行其他任务</p><h3 id="事件循环（消息队列）"><a href="#事件循环（消息队列）" class="headerlink" title="事件循环（消息队列）"></a>事件循环（消息队列）</h3><p>那么事件循环是什么呢，其实这也可以认为是一种异步</p><p>以<code>Qt</code>为例，<code>Qt GUI</code>程序的<code>main</code>函数其实非常简短</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    Widget w;<br>    w.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>a.exec()</code>最终调用了<code>QEventLoop::exec()</code>，其内部有一个死循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (!d-&gt;exit.<span class="hljs-built_in">loadAcquire</span>())<br>        <span class="hljs-built_in">processEvents</span>(flags | WaitForMoreEvents | EventLoopExec);<br></code></pre></td></tr></table></figure><p>不断地从事件队列中取出并处理事件</p><p><img src="/img/image-20231129205036046.png" alt="Qt事件循环"></p><p>当你启动一个窗口程序的时候，你就已经被困在这个循环里了</p><p>你可能会感到诧异，但是仔细想想：</p><p>你的每一次点击，每一次按键，<code>Windows</code>系统都会封装为一个消息，而我们又在循环中监听这些消息并处理</p><p>在每一次循环中获取事件，处理事件，刷新UI，并产生新事件（包括自定义），如此往复，不就形成了一个个动人的GUI程序了嘛</p><p>这算异步吗，大体算吧，我可以开启一个<code>Timer</code>，每隔一段时间就去监听网络请求是否返回，同样可以实现非阻塞</p><blockquote><p>这当然算异步，但是，核心不是事件循环提供了异步能力，而是系统的异步IO或者多线程在默默工作</p></blockquote><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>其实多线程当然也算一种异步，我们可以把耗时任务放到一个新线程（或线程池）上，实现非阻塞效果</p><p>参考<code>C++：std::sync</code></p><h4 id="不过多线程与事件循环的异步有什么区别"><a href="#不过多线程与事件循环的异步有什么区别" class="headerlink" title="不过多线程与事件循环的异步有什么区别"></a>不过多线程与事件循环的异步有什么区别</h4><p>线程是CPU调度的最小单位，所以线程的执行过程可能被随时打断（保存与恢复栈），这个很好理解</p><p>但是事件循环的每一个事件函数是不能被打断的，也就是同步的，所以可以称为基于同步的异步（我瞎起的名字）</p><h2 id="Rust异步编程"><a href="#Rust异步编程" class="headerlink" title="Rust异步编程"></a>Rust异步编程</h2><p>我们来分析一下<code>Rust</code>在单线程上是如何实现异步操作的</p><p><code>Rust</code>采用的是<strong>async&#x2F;await</strong>模型， 该模型性能高，还能支持底层编程，同时又像线程和协程那样无需过多的改变编程模型，但有得必有失，<code>async</code> 模型的问题就是内部实现机制过于复杂，理解和使用起来也没有线程和协程简单</p><p>这种模型中一般都会出现<code>Future</code>这个词，或者<code>JS</code>的<code>Promise</code>，这本质上就是一个在未来会返回的任务</p><p><code>Rust</code>的<code>Future</code>和其他语言不太一样</p><ul><li><strong>Future 在 Rust 中是惰性的</strong>，只有在被轮询(<code>poll</code>)时才会运行， 因此丢弃一个 <code>future</code> 会阻止它未来再被运行</li></ul><p><code>Future</code>是一个任务，或者说一段函数的包装，只要用<code>async</code>修饰函数或代码块，就会返回一个Future对象</p><p>而poll函数会<strong>非阻塞</strong>地返回该任务的<strong>当前状态</strong>（<code>Pending or Ready</code>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">// 一些同步代码</span><br>    fut_one.<span class="hljs-keyword">await</span>;<br>    <span class="hljs-comment">// 另一些同步代码</span><br>    fut_two.<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码会被编译器展开，自动为其实现<code>Future</code>接口，并将其<code>poll</code>函数实现为一个<strong>状态机</strong>，每一个<code>await</code>就是一个状态点</p><p>如此一来，我们就可以把一段异步代码拆分为几个阶段了，每个阶段内部不可打断，只有到await才会保存状态并交还控制权</p><p>看起来<code>fut_one.await;</code>和<code>fut_two.await;</code>是串行的，是同步阻塞的，但其实每一个<code>.await</code>调用的都是poll，都只是询问状态（立即返回），空闲下来的时间其实是去轮询其他的Future任务了（由外层<code>Executor</code>控制，待会儿说）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AsyncFuture</span> &#123;<br>    fut_one: FutOne,<br>    fut_two: FutTwo,<br>    state: AsyncState,<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AsyncState</span> &#123;<br>    Start,<br>    AwaitingFutOne,<br>    BetweenFuts,<br>    AwaitingFutTwo,<br>    Done,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Future</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AsyncFuture</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = ();<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> Poll&lt;()&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.state &#123;<br>            AsyncState::Start =&gt; &#123;<br>                <span class="hljs-comment">// 执行一些同步代码</span><br>                <span class="hljs-keyword">self</span>.state = AsyncState::AwaitingFutOne;<br>            &#125;<br>            AsyncState::AwaitingFutOne =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.fut_one.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>                Poll::<span class="hljs-title function_ invoke__">Ready</span>(()) =&gt; &#123;<br>                    <span class="hljs-comment">// 第一个 await 完成，执行中间的同步代码</span><br>                    <span class="hljs-comment">// 执行另一些同步代码</span><br>                    <span class="hljs-keyword">self</span>.state = AsyncState::AwaitingFutTwo;<br>                &#125;<br>                Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>            &#125;,<br>            AsyncState::AwaitingFutTwo =&gt; <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.fut_two.<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>                Poll::<span class="hljs-title function_ invoke__">Ready</span>(()) =&gt; <span class="hljs-keyword">self</span>.state = AsyncState::Done,<br>                Poll::Pending =&gt; <span class="hljs-keyword">return</span> Poll::Pending,<br>            &#125;,<br>            AsyncState::Done =&gt; <span class="hljs-keyword">return</span> Poll::<span class="hljs-title function_ invoke__">Ready</span>(()),<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一个<code>X.await</code>都意味着X是一个异步函数，是一个<code>Future</code>，那么展开后的代码中，其<code>poll</code>函数就会被调用，用以推进任务</p><p>所以<code>poll</code>函数会一层层嵌套，直到一个<code>Leaf Future</code>（自行实现了poll来管理其Pending和Ready的状态，或者是一段完全同步的无<code>await</code>代码）</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><h4 id="你们肯定很好奇，我们不断地询问（poll）任务的状态，那么谁去执行呢？"><a href="#你们肯定很好奇，我们不断地询问（poll）任务的状态，那么谁去执行呢？" class="headerlink" title="你们肯定很好奇，我们不断地询问（poll）任务的状态，那么谁去执行呢？"></a>你们肯定很好奇，我们不断地询问（poll）任务的状态，那么谁去执行呢？</h4><p>因为实际任务肯定是重量级的，是阻塞的，是消耗时间的，我们才需要用异步方式去解决对吧</p><p>那么所有<code>poll</code>函数都是非阻塞的，立即返回的，只是询问状态，那么这个任务怎么可能被完成（所有人都在摸鱼）</p><p>举个例子，假如我们的任务是：读取一个大文件；也就是最内层的<code>poll</code>函数在死循环读文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>()&#123;<br>    <span class="hljs-title function_ invoke__">while</span>(line = <span class="hljs-title function_ invoke__">next_line</span>())&#123;<br>    <span class="hljs-type">str</span> += line;<br>&#125;<br>    <span class="hljs-keyword">return</span> Ready;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，我们能从外层期望调用这个poll函数来返回这个任务的状态吗，是<code>Pending</code>还是<code>Ready</code></p><p>那显然是不可能的，作为一个单线程，怎么可能在一个阻塞的While循环进行时，又从外部调用这个函数</p><p>一旦进入了这个<code>poll</code>函数，那么就必须被阻塞到文件读取完毕，才返回Ready，那么，也就谈不上什么异步了</p><h4 id="所以其实要理解Rust是如何实现异步的，就要去思考最终的Leaf-Future的poll函数是怎么写的"><a href="#所以其实要理解Rust是如何实现异步的，就要去思考最终的Leaf-Future的poll函数是怎么写的" class="headerlink" title="所以其实要理解Rust是如何实现异步的，就要去思考最终的Leaf Future的poll函数是怎么写的"></a>所以其实要理解Rust是如何实现异步的，就要去思考最终的Leaf Future的poll函数是怎么写的</h4><p>比如说，我每读一行就返回怎么样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>()&#123;<br>    line = <span class="hljs-title function_ invoke__">next_line</span>()<br>    <span class="hljs-keyword">if</span> line == EOF <span class="hljs-keyword">return</span> Ready;<br>    <span class="hljs-type">str</span> += line;<br>    <span class="hljs-keyword">return</span> Pending;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是说，外部每调用一次poll，就会推进这个任务的进度（读一行），与惰性的Future莫名很搭有没有</p><p>那么读完一行后，就会交还控制权给外部，使其可以处理其他任务</p><p>这本质上就是<strong>时间片轮转算法</strong>或者说<strong>多任务并发</strong>，与在Qt事件循环中，每读若干行就<code>processEvents()</code>（以处理事件队列中的其他事件，如UI刷新）并无二异</p><p>那么你说，这种多任务并发算是异步吗？这是个值得讨论的问题</p><p>但是这种方式，读取文件的总时长并没有变化，甚至从读文件开始到结束会消耗更多的时间（期间处理其他任务）</p><p>唯一的好处是，在GUI程序中，可以保证主线程（GUI线程）不被阻塞</p><p>如果你真要提高文件读取效率，为什么不开多线程呢</p><p>当然，我们在这里讨论的是单线程异步，所以上述分片策略行不太通</p><h4 id="大家可能已经注意到了，磁盘IO和网络IO确实存在很大的不同"><a href="#大家可能已经注意到了，磁盘IO和网络IO确实存在很大的不同" class="headerlink" title="大家可能已经注意到了，磁盘IO和网络IO确实存在很大的不同"></a>大家可能已经注意到了，磁盘IO和网络IO确实存在很大的不同</h4><p>区别在哪呢，我们平时不都说是异步IO吗</p><ul><li>磁盘IO是真的一直在读数据，你偷懒了一秒，那么就要多花一秒去读</li><li>网络IO大部分时间都在等待，等待服务器回传数据，数据可能很少，等待要好几秒；这意味着，就算你这一秒去干别的事了，也不太耽误你对数据的读取</li></ul><p>所以，隔一段时间去读文件，和隔一段时间去监测网络数据是完全不同的概念</p><p>所以把上述的文件IO代码换成网络IO，就完全是一个可行的异步了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>()&#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">isDataOk</span>()&#123; <span class="hljs-comment">//linux中select epoll poll</span><br>        <span class="hljs-title function_ invoke__">readData</span>();<br>        <span class="hljs-keyword">return</span> Reday;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Pending;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为你真的可以去干别的事情，而不耽误等待了；相当于分片并发轮询，和事件循环也是类似的</p><p>这就体现了为什么真正的单线程异步通常要依赖于操作系统提供的异步API</p><h4 id="那么磁盘IO就没有异步API吗"><a href="#那么磁盘IO就没有异步API吗" class="headerlink" title="那么磁盘IO就没有异步API吗"></a>那么磁盘IO就没有异步API吗</h4><p>能不能让系统替我读文件，读完再告诉我</p><p>当然有，如：</p><ul><li>IOCP 是 Windows 提供的一种高效的线程池技术，用于处理异步 I&#x2F;O 操作</li><li>Linux 提供了一组 POSIX 异步 I&#x2F;O (AIO) 接口，由内核完成IO操作</li></ul><p>磁盘IO是一个实实在在的负载任务，总要有人负重前行的，要么是多线程，要么是内核（假装也算线程）</p><p>所以不依赖外物，真正的单线程异步磁盘IO是很难实现的</p><h4 id="所以真的有单线程异步吗"><a href="#所以真的有单线程异步吗" class="headerlink" title="所以真的有单线程异步吗"></a>所以真的有单线程异步吗</h4><p>如果内核算一个线程，替我们完成监测、等待工作的话，那确实没有单线程异步了</p><p>不过如果我们谈论的线程是<strong>用户空间的线程</strong>的话，那么可以依赖系统异步API实现</p><h4 id="暴论：单线程异步高度依赖系统异步API"><a href="#暴论：单线程异步高度依赖系统异步API" class="headerlink" title="暴论：单线程异步高度依赖系统异步API"></a>暴论：单线程异步高度依赖系统异步API</h4><blockquote><p>除非你要写一个 runtime，否则你不太可能自己实现一个叶子 Future，或者更多的是针对 Leaf-Future 的封装</p></blockquote><p>这也是为什么，我们很难理解Rust是如何实现单线程异步的原因，核心的操作都被封装在<code>tokio</code>库内部定义的叶子<code>Future</code>中了（要么多线程、要么系统API）</p><p>但是如果不理解叶子<code>Future</code>的实现原理，等于阿巴</p><h3 id="继续Rust异步"><a href="#继续Rust异步" class="headerlink" title="继续Rust异步"></a>继续Rust异步</h3><p>Okay，我们继续来讲<code>Rust</code>是如何实现异步的</p><h4 id="首先，为什么要用状态机"><a href="#首先，为什么要用状态机" class="headerlink" title="首先，为什么要用状态机"></a>首先，为什么要用状态机</h4><p>这是为了<strong>保存状态</strong>，一个异步函数内可以包括多个异步操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">async</span> &#123;<br>    fut_one.<span class="hljs-keyword">await</span>;<br>    fut_two.<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，假如没有状态机，我们每次进入这个异步函数（poll），都会重复执行这两个异步操作，也不知道第一个执行完没</p><p>并且，假如两个异步操作见有一些同步代码的话，也会被重复执行，那就寄了</p><p>每一个<code>.await</code>都是一个关键点，代表可以在这里退出与恢复异步函数</p><p>两个<code>.await</code>之间假如有同步代码的话，是不可以被打断的，每个状态内部都是同步的</p><h4 id="所以，暴论：Rust异步的本质是将大同步拆分为小同步，大任务手动拆分为小任务，而每个任务是同步的（不可被打断），虽然在同步任务里调用了异步代码-hhh（好吧-当我没说"><a href="#所以，暴论：Rust异步的本质是将大同步拆分为小同步，大任务手动拆分为小任务，而每个任务是同步的（不可被打断），虽然在同步任务里调用了异步代码-hhh（好吧-当我没说" class="headerlink" title="所以，暴论：Rust异步的本质是将大同步拆分为小同步，大任务手动拆分为小任务，而每个任务是同步的（不可被打断），虽然在同步任务里调用了异步代码 hhh（好吧 当我没说"></a>所以，暴论：Rust异步的本质是将大同步拆分为小同步，大任务手动拆分为小任务，而每个任务是同步的（不可被打断），虽然在同步任务里调用了异步代码 hhh（好吧 当我没说</h4><h4 id="状态保存："><a href="#状态保存：" class="headerlink" title="状态保存："></a>状态保存：</h4><p>其实Rust异步本质上是基于无栈协程的，这个状态机简直一毛一样</p><p>你想想多线程，每个线程由CPU调度，可能被随时打断，每个线程的状态保存在自己的栈上，所以无论何时被打断都能保存状态</p><p>有栈协程也是模拟了这个过程</p><p>而基于状态机的无栈协程和<code>Rust</code>的异步<code>poll</code>，也是为了保存状态，但是只能保存特定点（<code>.await</code>）的状态</p><p>仅此而已</p><h3 id="继续：那么poll函数由谁来调用呢"><a href="#继续：那么poll函数由谁来调用呢" class="headerlink" title="继续：那么poll函数由谁来调用呢"></a>继续：那么poll函数由谁来调用呢</h3><p>其实Rust语言本身只提供了最基本的异步关键字，但是没有提供运行时</p><p>所谓运行时，就是一个事件循环，去主动调用<code>Future</code>的<code>poll</code>函数</p><p>我们可以看看第三方库<code>Tokio</code>的实现：</p><p>我们一般是这样使用的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实会被展开为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    tokio::runtime::Builder::<span class="hljs-title function_ invoke__">new_multi_thread</span>() <span class="hljs-comment">//可以是单线程or多线程</span><br>        .<span class="hljs-title function_ invoke__">enable_all</span>()<br>        .<span class="hljs-title function_ invoke__">build</span>()<br>        .<span class="hljs-title function_ invoke__">unwrap</span>()<br>        .<span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-keyword">async</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br>        &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看就很清楚了，<code>block_on</code>就跟Qt的<code>exec</code>一样，<code>main</code>函数从一开始，就进入了一个死循环</p><p>这是一个简化的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">block_on</span>&lt;F, T, O&gt;(&amp;<span class="hljs-keyword">self</span>, f: F) <span class="hljs-punctuation">-&gt;</span> O<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_waker</span> = waker_fn::<span class="hljs-title function_ invoke__">waker_fn</span>(|| &#123;&#125;);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">cx</span> = &amp;<span class="hljs-keyword">mut</span> Context::<span class="hljs-title function_ invoke__">from_waker</span>(&amp;_waker);<br><br>        EX.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-keyword">self</span>, || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">fut</span> = <span class="hljs-title function_ invoke__">f</span>();<br>            pin_utils::pin_mut!(fut);<br>            <span class="hljs-keyword">loop</span> &#123;<br>                <span class="hljs-comment">// return if the outer future is ready</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">std</span>::task::Poll::<span class="hljs-title function_ invoke__">Ready</span>(t) = fut.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>                    <span class="hljs-keyword">break</span> t;<br>                &#125;<br><br>                <span class="hljs-comment">// consume all tasks</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(t) = <span class="hljs-keyword">self</span>.local_queue.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">future</span> = t.future.<span class="hljs-title function_ invoke__">borrow_mut</span>();<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = <span class="hljs-title function_ invoke__">waker</span>(t.<span class="hljs-title function_ invoke__">clone</span>());<br>                    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">context</span> = Context::<span class="hljs-title function_ invoke__">from_waker</span>(&amp;w);<br>                    <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = Pin::<span class="hljs-title function_ invoke__">new</span>(future).<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">poll</span>(&amp;<span class="hljs-keyword">mut</span> context);<br>                &#125;<br><br>                <span class="hljs-comment">// no task to execute now, it may ready</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">std</span>::task::Poll::<span class="hljs-title function_ invoke__">Ready</span>(t) = fut.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">poll</span>(cx) &#123;<br>                    <span class="hljs-keyword">break</span> t;<br>                &#125;<br><br>                <span class="hljs-comment">// block for io</span><br>                <span class="hljs-keyword">self</span>.reactor.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">wait</span>();<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对吧，其实就是一个事件循环，不断地从任务队列里取出<code>Future</code>，用<code>poll</code>轮询和推进</p><p>而在<code>poll</code>函数中，如果遇到了需要异步进行的任务（如网络IO）</p><p>就会主动将任务交给<code>reactor</code>（用以统一监听IO）并返回<code>Pending</code>：在每一次循环末尾会进行<code>self.reactor.borrow_mut().wait();</code></p><p>这个可以是阻塞的，因为只有当任务队列为空（都在等待IO时）才会进入wait</p><blockquote><p>所以异步与同步的区别就在于 在合适的时间做合适的事情</p></blockquote><p>当IO准备完毕时，<code>reactor</code>会唤醒相关的<code>Future</code>任务（将其加入任务队列）</p><p>这样，他下次又会被调用<code>poll</code>函数，同时因为有状态机记录状态，可以迅速地进行IO</p><p>大概就酱</p><h2 id="所以异步的本质是什么"><a href="#所以异步的本质是什么" class="headerlink" title="所以异步的本质是什么"></a>所以异步的本质是什么</h2><p>是对时间的压榨，是尽量减少无谓的等待，是在合适的时间同步，是对任务的拆分，是小明倒茶问题</p><h3 id="异步的实现方式有什么"><a href="#异步的实现方式有什么" class="headerlink" title="异步的实现方式有什么"></a>异步的实现方式有什么</h3><p>总结起来就俩</p><ul><li>多线程（多进程也是多线程）</li><li>系统异步API</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://zhuanlan.zhihu.com/p/611781411">Rust Tokio，运行时以及任务相关API - 知乎 (zhihu.com)</a></p><p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_12/monoio.html">字节跳动 | Rust 异步运行时的设计与实现 - Rust精选 (rustmagazine.github.io)</a></p><p><a href="https://github.com/ihciah/mini-rust-runtime/tree/master">ihciah&#x2F;mini-rust-runtime (github.com)</a></p><p><a href="https://blog.rustforever.top/2021/11/24/rust/futures/future-explained1/">future explained(1) - Hexo (rustforever.top)</a></p><p><a href="https://zhuanlan.zhihu.com/p/611587154">Rust学习笔记-异步编程(async&#x2F;await&#x2F;Future) - 知乎 (zhihu.com)</a></p><p><a href="https://course.rs/advance/async/getting-started.html">async 编程入门 - Rust语言圣经(Rust Course)</a></p><p><a href="https://zhuanlan.zhihu.com/p/474274504">无栈协程（stackless coroutine） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/347445164">浅谈有栈协程与无栈协程 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/tianlangstudio/article/details/107310211?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-107310211-blog-115638777.235%5Ev38%5Epc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-107310211-blog-115638777.235%5Ev38%5Epc_relevant_anti_vip_base&utm_relevant_index=6">一文读懂Rust的async_rust async-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 二级指针与二维数组</title>
    <link href="/2023/11/11/C-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2023/11/11/C-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%B8%8E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br><span class="hljs-type">int</span>** ptr = (<span class="hljs-type">int</span>**)a;<br></code></pre></td></tr></table></figure><p>把二维数组赋值给二级指针，该如何通过<code>ptr</code>对第i行第j列进行访问呢？</p><p>有人说，简单：<code>ptr[i][j]</code></p><p>那么好，众所周知：<code>ptr[i][j] == *(*(ptr+i)+j)</code> &#x2F;&#x2F;编译器展开</p><p>那么<code>ptr + i</code> 的步长是多少，或者说<code>ptr + 1</code> 移动了几个字节</p><p>那么显然是移动【指针指向的元素的大小】，也就是<code>int*</code> 的大小</p><p>那么显然：<code>ptr[i][j]</code> 不能正确定位第i行第j列</p><blockquote><p>其实，<code>int** ptr = a;</code>就会发出警告 <code>&quot;int(*)[3]&quot;类型的值不能用于初始化&quot;int**&quot;类型的实体</code> 也许，这说明，数组只能退化为一级指针</p></blockquote><p>如果在这种情况下，想要强行通过<code>ptr</code>访问</p><p>只能：<code>*((int*)ptr + i * N + j)</code> 强转为一级指针 &#x2F;&#x2F;N是一行的元素个数</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>同时，<code>**ptr</code> 会直接造成越界访问</p><p>这是因为第一次解引用<code>*ptr</code> 其实就已经是第一个元素的值<code>1</code> 了 &#x2F;&#x2F;32位系统下</p><p>也就是说，<code>(int)(*ptr)</code> &#x3D;&#x3D; 1 &#x2F;&#x2F;32位系统下</p><p>而且，解引用意味着找到指针所存地址上的值</p><p>如果把第一个元素看做指针，那么该指针所存的地址是<code>1</code>吗？不一定</p><ul><li>32位系统下，指针是4个字节</li><li>64位系统下，指针是8个字节，那么第一第二个元素会被共同解释为地址</li></ul><p>然后会去该地址（比如0000000200000001）寻找值</p><p>那么显然越界访问了，直接bomb，异常</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="所以，方法1：int-ptr-3-a"><a href="#所以，方法1：int-ptr-3-a" class="headerlink" title="所以，方法1：int (*ptr)[3] = a;"></a>所以，方法1：<code>int (*ptr)[3] = a;</code></h3><p>众所周知：右左法则（注意括号），跟我读：<code>ptr</code>是一个指针(*)，指向一个数组([3])，这个数组有3个元素，元素类型是<code>int</code></p><p>恒河里</p><p>所以，<code>a[2][3]</code>实际上就是有两个这样的一维数组[3]，数组的数组</p><p>酱紫的话，<code>ptr++</code>，就可以在这两个一维数组的首地址跳跃了，步长为<code>int[3]</code></p><p>所以也可以<code>ptr[i][j]</code>进行访问</p><h3 id="方法2：int-ptr-new-int-N"><a href="#方法2：int-ptr-new-int-N" class="headerlink" title="方法2：int** ptr = new int*[N];"></a>方法2：<code>int** ptr = new int*[N];</code></h3><p>这将意味着，申请的空间是一个一维数组，数组的每一个元素都是<code>int*</code> 类型</p><p>这种情况下，每一个<code>int*</code>都会指向一个一维数组</p><p>所以<code>ptr[i]</code>就是第i个一维数组的首地址，<code>ptr[i][j]</code>就是这个数组的第j个元素</p><p>所以可以正常访问</p><p>就是需要循环申请内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>** ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[rows];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>    ptr[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[cols];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QMediaPlayer与解码器浅析</title>
    <link href="/2023/09/26/QMediaPlayer%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8%E6%B5%85%E6%9E%90/"/>
    <url>/2023/09/26/QMediaPlayer%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Qt</code>可以很方便地使用<code>QMediaPlayer</code>类播放音视频（mp3、mp4等）</p><p>但是，当我们兴致冲冲地开始<code>play</code>时，却只收获了一行Error：</p><blockquote><p>DirectShowPlayerService::doRender: Unresolved error code 80040266</p></blockquote><p>这是因为<code>QMediaPlayer</code>底层是使用<code>DirectShowPlayerService</code>，这是一个基于<code>DirectShow</code>框架的后端实现</p><p>但是<code>DirectShowPlayerService</code>没有自带解码库，而是对平台相关的播放器框架做了封装，提供了平台无关的API</p><p>且<code>DirectShow</code>框架默认只支持一些常见的格式（如WMV、AVI、MPG等），如果要播放其他格式的音视频文件，就需要额外安装解码器</p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/directshow/supported-formats-in-directshow">DirectShow 中支持的格式 - Win32 apps | Microsoft Learn</a></p><h2 id="Pre-正片"><a href="#Pre-正片" class="headerlink" title="Pre - 正片"></a>Pre - 正片</h2><p>好的 现在我们知道了<code>QMediaPlayer</code>不能单独使用，除某些格式外，需要配合第三方解码器使用</p><p>那么什么解码器合适呢？</p><p>随便上网一搜报错，给出的答案都是<a href="https://github.com/Nevcairiel/LAVFilters/releases">LAVFilters</a></p><p>直接干，噼里啪啦安装到<code>Qt</code>目录下（不确定安装位置是否有要求）</p><p>安装过程会自动向<code>Windows</code>注册解码器，无需我们手动操作（不需要在Qt中指定解码器位置之类的）</p><p>好的，现在可以播放<code>mp3</code>音频文件了，よかった收工</p><h2 id="正片"><a href="#正片" class="headerlink" title="正片"></a>正片</h2><p>时光荏苒，斗转星移，转眼间，数年过去了</p><p><a href="https://github.com/SpriteOvO/AirPodsDesktop">AirpodsDesktop</a>需要使用<code>QMediaPlayer</code>播放<code>.avi</code>视频</p><p>出现了令人费解的无法渲染和卡顿现象</p><blockquote><p>起初，没有人在意这场灾难。这只不过是一次卡顿，一顿黑屏，一个视频的灭绝，一个控件的消失。直到每个解码器和这场灾难息息相关。</p></blockquote><p>是的，经过一顿搜索，这与解码器有着脱不开的干系</p><p>在卸载了<code>LAVFilters</code>之后，<code>.avi</code>视频可以正常播放了</p><h3 id="但是mp3播放不了了aaaa"><a href="#但是mp3播放不了了aaaa" class="headerlink" title="但是mp3播放不了了aaaa"></a>但是mp3播放不了了aaaa</h3><p>也就是说<code>mp3</code>需要依赖<code>LAVFilters</code>解码，<code>avi</code>不需要，且<code>LAVFilters</code>还会造成<a href="https://blog.csdn.net/windxgz/article/details/108603033">反作用</a></p><p>又经过一顿搜索发现这种现象并不罕见，<strong>解决方案</strong>：利用效果更好的<a href="http://codecguide.com/download_k-lite_codec_pack_standard.htm">K-Lite</a>替代<code>LAVFilters</code></p><p>酱紫<code>mp3</code>和<code>avi</code>都可以正常播放啦，可喜可贺！</p><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p>等一下，先别高兴得太早</p><p>大哥，你开发的可是软件，是要给用户使用的，解码器怎么安装</p><p>首先，从安装难度和安装包大小来说，<code>K-Lite</code>要远高于<code>LAVFilters</code></p><p>他俩都是基于<code>FFmpeg</code>开发的，而且貌似<code>K-Lite</code>内含一个<code>LAVFilters</code>（NewBing说的）</p><p>LAVFilters所包含的组件较少，大概就是<code>dll + ax + manifest</code>（在一个文件夹中）</p><p>只要在安装时，在用户电脑里自动执行ax的安装脚本即可</p><p>参考：<a href="https://blog.csdn.net/zyhse/article/details/113716578">在Windows下使用QMediaPlayer实现播放视频CSDN博客</a></p><p>但是<code>K-Lite</code>可能没这么方便</p><p>如果让用户手动安装的话，还需要一些指引（<code>K-Lite</code>选项与步骤繁多）</p><p>所以从这个层面来说<code>LAVFilters</code>更胜一筹（当然为了全面功能性，还是得考虑K-Lite）</p><h3 id="特事特办"><a href="#特事特办" class="headerlink" title="特事特办"></a>特事特办</h3><p>不过，在这个例子中，<code>AirpodsDesktop</code>使用的是<code>avi</code>文件，<code>QMediaPlayer</code>不需要额外的解码器就可以播放这个古老的格式，而我的<a href="https://github.com/MrBeanCpp/Right-Player">Right-Player</a>需要解码器来播放<code>mp3</code></p><p>为了调和这个矛盾，我们可以在安装<code>LAVFilters</code>时，取消勾选视频解码器（但是要保留Splitter分离器）</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>可能有人会想，为什么Edge这样的软件不需要额外安装解码器呢？</p><p><code>NewBing</code>的解释如下：</p><blockquote><p>Edge也是使用DirectShow框架来播放音频和视频文件，但它不是使用DirectShowPlayerService，而是使用自己的后端实现，它可以利用Windows Media Foundation（WMF）或Media Foundation（MF）来提供更高效和更稳定的解码服务</p><p>Edge不需要LAVFilters解码器，是因为它可以使用WMF或MF来提供解码器，而WMF或MF默认支持更多的视频格式，例如H.264、H.265、VP8、VP9等。这些格式涵盖了大部分的网络视频和流媒体服务，因此Edge可以直接播放这些视频文件，不需要额外安装解码器。</p></blockquote><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/birenxiaofeigg/article/details/104129207">QMediaPlayer视频没有画面显示，或播放卡顿问题解决_vs中通过qmediaplayer 加载不出视频-CSDN博客</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/directshow/supported-formats-in-directshow">DirectShow 中支持的格式 - Win32 apps | Microsoft Learn</a></p><p><a href="https://blog.csdn.net/windxgz/article/details/108603033">QT总结11——QMediaPlayer无法显示视频_qt中qmediaplayer播放视频无反应-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_37631516/article/details/105124407">QT视频播放不出来，报错 DirectShowPlayerService::doRender: Unresolved error code 80040266——没有安装视频解码器-CSDN博客</a></p><p><a href="https://github.com/SpriteOvO/AirPodsDesktop">SpriteOvO&#x2F;AirPodsDesktop: ☄️ AirPods desktop user experience enhancement program, for Windows and Linux (WIP) (github.com)</a></p><p><a href="https://github.com/MrBeanCpp/Right-Player">MrBeanCpp&#x2F;Right-Player: 一款轻量级音乐播放器，拥有简洁美观的UI设计 (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>QMediaPlayer，解码器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java为什么不支持泛型数组</title>
    <link href="/2023/07/15/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/"/>
    <url>/2023/07/15/Java%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Java</code>的泛型并不是真正的泛型</p><p>但是，究竟什么才是真正的泛型呢？</p><h3 id="真正的泛型"><a href="#真正的泛型" class="headerlink" title="真正的泛型"></a>真正的泛型</h3><p>根据<code>New Bing</code>的说法：</p><p>真正的泛型是指泛型类型在编译时和<strong>运行时</strong>都能保持类型信息</p><p>真正的泛型的实现方式通常是类型膨胀，也就是为每个泛型参数生成一个单独的类或方法</p><p>这一点可以参考<code>C++</code>的模板实现方式，在编译期为每一种使用的具体类型生成实例。</p><h3 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h3><p><code>Java</code>的泛型并不是真正的泛型，而是伪泛型</p><p>采用了一种称为 <strong>类型擦除</strong> 的技术。类型擦除的意思是，在编译时，泛型类型会被替换为它的<strong>上界</strong>类型（如果没有指定上界，则为 <code>Object</code> 类型），并且在字节码层面，泛型信息会被擦除，<strong>不会保留到运行时</strong></p><p>例如，我们定义了一个泛型类 <code>Pair&lt;T&gt;</code> ，其中 <code>T</code> 是一个无限定的类型变量，那么在编译后，它的原始类型就是 <code>Pair&lt;Object&gt;</code> ，也就是说 T 被替换为了 <code>Object</code> 类型。如果我们定义了一个泛型类 <code>Pair&lt;T extends Comparable&gt;</code> ，其中 <code>T</code> 是一个有限定的类型变量，那么在编译后，它的原始类型就是 <code>Pair&lt;Comparable&gt;</code> ，也就是说 <code>T</code> 被替换为了它的上界 <code>Comparable</code> 类型</p><p>那么，为什么 Java 要采用类型擦除的方式来实现泛型呢？这主要是出于 <strong>向后兼容性</strong> 的考虑。Java 泛型是在 Java 5 中引入的，而在此之前，Java 已经有了很多版本和很多类库。如果 Java 要实现真正的泛型，就需要修改 JVM 的指令集和类文件格式，这样就会导致之前的版本和类库无法在新版本的 JVM 上运行。为了避免这种情况，Java 设计者选择了一种不需要修改 JVM 的方式来实现泛型，也就是类型擦除。</p><p>类型擦除使得 Java 泛型能够与之前的版本和类库保持<strong>兼容</strong>，但也带来了一些<strong>限制和问题</strong>，比如：</p><ul><li>不能使用基本类型作为泛型参数，只能使用包装类 &#x2F;&#x2F; int × Integer √</li><li>不能根据泛型参数创建<strong>数组</strong>或实例化对象，只能使用反射或 Object 类型</li><li>不能对泛型参数进行 instanceof 检查或强制转换，只能使用通配符或边界</li><li>不能在静态方法或静态变量中使用泛型类的类型参数</li><li>不能创建泛型异常类</li></ul><h2 id="为什么不支持泛型数组"><a href="#为什么不支持泛型数组" class="headerlink" title="为什么不支持泛型数组"></a>为什么不支持泛型数组</h2><p>Java不能根据泛型参数创建数组，也不支持泛型数组</p><p>这俩看起来很像，但其实是两种不同的东东：</p><h3 id="不能根据泛型参数创建数组"><a href="#不能根据泛型参数创建数组" class="headerlink" title="不能根据泛型参数创建数组"></a>不能根据泛型参数创建数组</h3><p>不能根据泛型参数创建数组，是指不能使用<code>new T[size]</code>这样的语法来创建一个泛型类型的数组</p><p>因为在编译时<strong>无法确定<code>T</code>的具体类型</strong>，也就找不到对应的类字节码文件</p><p>解决方案参考：<a href="https://www.cnblogs.com/minghaiJ/p/11259318.html">Java中创建泛型数组 - minghai - 博客园</a></p><h3 id="不支持泛型数组"><a href="#不支持泛型数组" class="headerlink" title="不支持泛型数组"></a>不支持泛型数组</h3><p>不支持泛型数组，是指不能使用<code>new ArrayList&lt;T&gt;[size]</code>这样的语法来创建一个泛型类型的数组</p><p>因为这样做会<strong>破坏类型安全</strong>，导致运行时的<code>ClassCastException</code>异常</p><p>原因是Java的泛型是基于类型擦除实现的，在<strong>运行时</strong>泛型类型参数的<strong>具体类型信息是被擦除</strong>的，只剩下<code>Object</code>类型</p><p>而Java的数组是<strong>协变</strong>的，也就是说子类数组可以<strong>向上转型</strong>为父类数组，例如<code>String[]</code>可以转为<code>Object[]</code></p><p>如果Java允许创建泛型数组，那么就可能出现如下情况：（New Bing提供）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] strListArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">//假设这样可以创建泛型数组</span><br>Object[] objArray = strListArray; <span class="hljs-comment">//由于数组协变，可以向上转型为Object[]</span><br>objArray[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(); <span class="hljs-comment">//由于Object[]可以存放任何对象，可以放入一个ArrayList&lt;Integer&gt;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strListArray[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <span class="hljs-comment">//由于strListArray是List&lt;String&gt;[]类型，可以取出一个String</span><br><span class="hljs-comment">//但实际上strListArray[0]存放的是一个ArrayList&lt;Integer&gt;，所以会抛出ClassCastException</span><br></code></pre></td></tr></table></figure><p>为了避免这种情况发生，Java在编译时就<strong>禁止</strong>了创建泛型数组</p><blockquote><p>所以并不是Java实现不了，而是出于安全禁止</p></blockquote><h2 id="What？？"><a href="#What？？" class="headerlink" title="What？？"></a>What？？</h2><p>好的，想必以上的代码并没有触及根本，看了一脸懵逼</p><p>我们来仔细聊聊</p><p>首先看第三行：<code>objArray[0] = new ArrayList&lt;Integer&gt;();</code> &#x2F;&#x2F;Object[]可以存放任何对象</p><blockquote><p>是没错，酱紫编译可以过，但是这和泛不泛型又有什么关系呢？</p></blockquote><p>看以下两段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>这一段，把<code>Float</code>赋值给<code>Integer</code>数组<code>arr</code>，编译器直接报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>这一段，把<code>Float</code>赋值给<code>Object</code>数组<code>arr</code>，编译通过，但是运行抛出异常（类型不匹配）</p><p>可是可是，你有想过为什么吗，我凭什么知道编译时和运行时出不出错</p><h3 id="静态类型-amp-动态类型"><a href="#静态类型-amp-动态类型" class="headerlink" title="静态类型 &amp; 动态类型"></a>静态类型 &amp; 动态类型</h3><p>Java在编译时只检查静态类型（变量类型[Left]），运行时才检查动态类型（真实类型 aka 引用指向的类型[Right]）</p><p>例如：<code>Object[] arr = new Integer[10];</code>中，<code>arr</code>的静态类型是<code>Object[]</code>，而动态类型是<code>Integer[]</code></p><p>那么，有聪明的小可爱要问了，为什么不在编译时检查动态类型</p><p>好问题，因为编译时没法知道动态类型，看到<strong>动态</strong>俩字了嘛，我们可以根据用户输入改变引用的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//声明一个Animal类型的变量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">choice</span> <span class="hljs-operator">=</span> Integer.parseInt(args[<span class="hljs-number">0</span>]); <span class="hljs-comment">//从命令行参数获取一个整数</span><br><span class="hljs-keyword">if</span> (choice)<br>    animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">//如果输入为1，创建一个Dog对象并赋值给animal</span><br><span class="hljs-keyword">else</span><br>    animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">//否则，创建一个Animal对象并赋值给animal</span><br></code></pre></td></tr></table></figure><p>所以编译器直接放弃检查动态类型，只判断静态类型</p><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>okayokay，继续</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] strListArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] objArray = strListArray;<br>objArray[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br></code></pre></td></tr></table></figure><p>由于编译器<strong>类型擦除</strong>的存在，会变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] strListArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[<span class="hljs-number">10</span>];<br>Object[] objArray = strListArray;<br>objArray[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br></code></pre></td></tr></table></figure><p>编译器：诶，<code>ArrayList</code>可以存入<code>Object[]</code>，过！</p><p>虚拟机：诶，类型擦除，没类型，那就是<code>ArrayList</code>存入<code>ArrayList[]</code>，过！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> strListArray[<span class="hljs-number">0</span>].get(<span class="hljs-number">0</span>); <br></code></pre></td></tr></table></figure><p>由于<code>strListArray</code>是<code>List&lt;String&gt;[]</code>类型，可以取出一个<code>String</code></p><p>但实际上<code>strListArray[0]</code>存放的是一个<code>ArrayList&lt;Integer&gt;</code>，所以会抛出<code>ClassCastException</code></p><p>但是又有小可爱会说了：<strong>不是类型擦除了嘛，怎么还知道自己是<code>ArrayList&lt;Integer&gt;</code></strong></p><p>这是因为当我们从<code>strListArray</code>中取出一个元素时，编译器会自动插入一个<strong>强制转换</strong>，将其转换为<code>List&lt;String&gt;</code>类型。</p><p><strong>结论</strong>：由于<strong>类型擦除</strong>的存在，编译器和虚拟机都没办法区分堆中的<strong>泛型数组</strong>到底存的是什么<strong>具体类型</strong>，而这对强类型语言Java来说是<strong>不可接受</strong>的，为了安全考虑，<code>Java</code>直接不支持泛型数组了</p><p><em>以上内容参考：java为什么不支持泛型数组？ - 红松的回答 - 知乎 <a href="https://www.zhihu.com/question/20928981/answer/2993376953">https://www.zhihu.com/question/20928981/answer/2993376953</a></em></p><h2 id="咋办"><a href="#咋办" class="headerlink" title="咋办"></a>咋办</h2><p>那泛型数组不能用咋办？</p><p>可以使用<code>ArrayList</code>动态数组代替原生数组</p><p>因为<code>ArrayList</code>不支持协变，所以也就安全得多（かも）</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>总而言之，言而总之</p><p>Java的类型擦除实现机制导致运行时失去了泛型信息，导致了很多限制</p><p>深究起来就阿巴阿巴了，反正大概就这个亚子，aaaaaaa，寄了再说</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.zhihu.com/question/20928981">java为什么不支持泛型数组？ - 知乎</a></p><p><a href="https://www.zhihu.com/question/28665443"> Java 不能实现真正泛型的原因是什么？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/zawier/p/8505098.html">Java 中为什么不能创建泛型数组？ - _路上 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/anlian523/article/details/100643209">Java 泛型的本质——类型擦除_anlian523的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/minghaiJ/p/11259318.html">Java中创建泛型数组 - minghai - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>泛型，泛型数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++继承体系下函数调用辨析</title>
    <link href="/2023/06/12/C-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BE%A8%E6%9E%90/"/>
    <url>/2023/06/12/C-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BE%A8%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><blockquote><p>Darli：如果我想用子类的实例调用父类的同名函数应该怎么写？</p></blockquote><p>测试Code如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt;<span class="hljs-string">&quot; this is A(m)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt;<span class="hljs-string">&quot; this is A&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt;<span class="hljs-string">&quot; this is B(m)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt;<span class="hljs-string">&quot; this is B&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br>B b;<br>A* c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(); <br>a.<span class="hljs-built_in">func</span>();    <span class="hljs-comment">//this is A</span><br>b.<span class="hljs-built_in">func</span>();    <span class="hljs-comment">//this is B</span><br>b.A::<span class="hljs-built_in">func</span>();  <span class="hljs-comment">//this is A</span><br>c-&gt;<span class="hljs-built_in">func</span>();    <span class="hljs-comment">//this is B</span><br>c-&gt;A::<span class="hljs-built_in">func</span>(); <span class="hljs-comment">//this is A</span><br>((A)(*c)).<span class="hljs-built_in">func</span>();<span class="hljs-comment">//this is A 生成A临时对象实例</span><br>c-&gt;<span class="hljs-built_in">m</span>();<span class="hljs-comment">// this is A(m)</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Maybe：<code>C++</code>继承的同名函数可以分为虚函数重写和普通同名函数，而<code>Java</code>就默认重写了</p><p>在<code>C++</code>体系中，有三种方法可以实现通过子类实例调用父类同名函数：</p><ul><li>域操作符(::) <code>b.A::func(); c-&gt;A::func();</code></li><li>将指针解引用并强转为父类，会产生一个临时父类对象实例，<code>((A)(*c)).func();</code></li><li>父类和子类中的普通同名函数（非virtual），酱紫的话 就失去了多态性 也就是不看实际类型 只看接收的类型，比如<code>A* c = new B(); c-&gt;m();</code>调用的就是A的m()</li></ul><blockquote><p>教学相长也 C++高深也</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt-OpenGL VAO, VBO, IBO简析</title>
    <link href="/2023/03/06/Qt-OpenGL-VAO%E4%B8%8EIBO%E7%AE%80%E6%9E%90/"/>
    <url>/2023/03/06/Qt-OpenGL-VAO%E4%B8%8EIBO%E7%AE%80%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，初入<code>OpenGL</code>炼狱，便是一坨让人不明所以、一脸懵逼的名词</p><p>比如什么：<code>VAO</code>、<code>VBO</code>、<code>IBO</code></p><blockquote><p>啊，对，就你们仨，枪打出头鸟啊，就你们仨打头阵啊，还都以O结尾啊</p><p>那就干你们了</p></blockquote><h2 id="VBO（Vertex-Buffer-Object-：顶点缓冲对象）"><a href="#VBO（Vertex-Buffer-Object-：顶点缓冲对象）" class="headerlink" title="VBO（Vertex Buffer Object ：顶点缓冲对象）"></a>VBO（Vertex Buffer Object ：顶点缓冲对象）</h2><p>这一听就和<strong>顶点</strong>有关，实际上就是用来存储顶点相关信息的（坐标、颜色、贴图坐标、法向量等）</p><p>这个对象可以把顶点相关数据一次性发送到<code>GPU</code>，减少与<code>CPU</code>通信开销</p><blockquote><p>毕竟三维世界也需要二维的线和一维的点进行构建嘛</p><p>所以顶点信息是最基本的</p></blockquote><p>比如这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> pos[] = &#123;<br>    <span class="hljs-number">-150</span>, <span class="hljs-number">-150</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">150</span>, <span class="hljs-number">-150</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>    <span class="hljs-number">-150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>每一行是一个顶点的信息，前两个数代表二维坐标，后两个数代表贴图坐标（贴图与顶点的对应关系）</p><p>但是你会发现一个奇怪的点，为什么我要用一维数组呢，酱紫不是没有任何结构（struct or class）吗？</p><p>一点也不面向对象啊，这是因为<code>OpenGL</code>提供的<code>API</code>就只支持一维数组，并且需要手动解释其中的数据（区分哪些是坐标、哪些是颜色、贴图之类的）</p><p>类似于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">GLuint buffer;<br><span class="hljs-built_in">glGenBuffers</span>(<span class="hljs-number">1</span>, &amp;buffer);<br><span class="hljs-built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);<br><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)*<span class="hljs-number">8</span>, pos, GL_STATIC_DRAW);<br><span class="hljs-comment">//↑绑定数据（上传到GPU）</span><br><br><span class="hljs-comment">//↓解释数据</span><br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)*<span class="hljs-number">4</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">glEnableVertexAttribArray</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)*<span class="hljs-number">4</span>, (<span class="hljs-type">void</span>*)(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) * <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>顶点数据是怎么解释的呢，就是通过<code>glEnableVertexAttribArray</code>这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">glVertexAttribPointer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    GLuint index,</span></span><br><span class="hljs-params"><span class="hljs-function">    GLint size,</span></span><br><span class="hljs-params"><span class="hljs-function">    GLenum type,</span></span><br><span class="hljs-params"><span class="hljs-function">    GLboolean normalized,</span></span><br><span class="hljs-params"><span class="hljs-function">    GLsizei stride,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> GLvoid* pointer</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>比如这一句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)*<span class="hljs-number">4</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>ta的意思就是：</p><p><strong>对于0号属性（也就是坐标，数字不重要 不重复就行），由相邻的两个元素组成（二维坐标），类型是<code>GL_FLOAT</code>（浮点型），不开启归一化（GL_FALSE），两个数据（坐标）之间的步长是4个<code>float</code>字节的长度，并且距离数组起点的偏移量是0</strong></p><p>对于贴图坐标，也可以酱紫解释（命名为1号属性），这里属性的顺序啥的都不重要，只要在<code>shader</code>（着色器）中能自己对应上就可以</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>为什么要如此麻烦呢，为什么不给一些类和结构，而是从一维数组，原始数据开始解释呢</p><p>推测：<code>OpenGL</code>是底层图形库，酱紫可以提供最高的性能以及自由度，供程序员自由封装；同时也对<code>GPU</code>来讲更好读取</p><h2 id="IBO-（Index-Buffer-Object：索引数组对象）-or-EBO（Element-Buffer-Object）"><a href="#IBO-（Index-Buffer-Object：索引数组对象）-or-EBO（Element-Buffer-Object）" class="headerlink" title="IBO （Index Buffer Object：索引数组对象） or EBO（Element Buffer Object）"></a>IBO （Index Buffer Object：索引数组对象） or EBO（Element Buffer Object）</h2><p>其实有了<code>VBO</code>就可以开始绘制图形了，为啥还要<code>IBO</code>呢</p><p><code>IBO</code>也叫<code>EBO</code>，两种叫法，但是第一种更见名知意，一看就知道是保存索引的</p><p><code>IBO</code>的存在是为了优化内存</p><p>比如：我们要画一个正方形，众所周知，一个正方形可以由两个三角形构成（对角分）</p><p>两个三角形有6个顶点，但是正方形只需要4个顶点</p><p><img src="/img/image-20230306204158147.png" alt="正方形"></p><p>如此一来，有两个顶点的数据就是重复的，在<code>VBO</code>里包含6个顶点的信息显然是十分滴<strong>stupid</strong></p><p>那为何不直接用索引来代表顶点呢，比如给四个顶点编号（1,2,3,4）</p><p>然后告诉<code>OpenGL</code>，我要绘制两个三角形，一个是（1,2,4），一个是（2,3,4）</p><p>酱紫可不方便多了</p><p>保存索引的对象就叫<code>IBO</code>，索引缓冲对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">GLuint indices[] = &#123;<br>    <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>, <span class="hljs-comment">//三角形1</span><br>    <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">//三角形2</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="VAO（Vertex-Array-Object：顶点数组对象）"><a href="#VAO（Vertex-Array-Object：顶点数组对象）" class="headerlink" title="VAO（Vertex Array Object：顶点数组对象）"></a>VAO（Vertex Array Object：顶点数组对象）</h2><p>诶诶，有数据有索引了，还优化内存了，你还想咋样a，aaaaaa</p><p>是酱紫，兄弟，我知道你很急，但是你先别急</p><p>你看a，一组数据和一组索引可以绘制一个图形，但是假如有很多图形，每次切换着绘制，绘制前都要绑定这绑定那的有点麻烦</p><p>不如来一个东东来记录一下我们的操作（比如对顶点信息的解释，比如顶点数据）</p><p>这个东东就是<code>VAO</code>，可以保存我们的操作，酱紫就可以只绑定<code>VAO</code>实现绘制（通过<code>VAO</code>访问各种数据）</p><p>具体保存了啥呢？</p><ul><li><p>vertex attribute 对应的 VBO 的id，<strong>glBindBuffer</strong> 设置。</p></li><li><p>vertex attribute 的格式，由 <strong>glVertexAttribPointer</strong> 设置</p></li><li><p>vertex attribute 的开启或关闭，<strong>glEnableVertexAttribArray</strong>和<strong>glDisableVertexAttribArray</strong></p></li><li><p>**#当前#**绑定的 GL_ELEMENT_ARRAY_BUFFER（索引缓冲数组，IBO） 的名字，由 glBindBuffer 设置</p></li></ul><p>也就是保存了<code>VBO</code>和<code>IBO</code>，但是他们之间有一个很大的区别</p><ul><li>VBO是通过<code>glVertexAttribPointer</code>这个函数进行绑定的</li><li>而IBO是通过<code>glBindBuffer</code>函数进行绑定的</li></ul><p>这是因为一个<code>VAO</code>可以绑定多个<code>VBO</code>（可以用不同VBO保存不同数据（坐标、颜色可以分开））</p><p>但是只能绑定一个<code>IBO</code>（索引）</p><p><em>&#x2F;&#x2F; 绑定0号缓冲区就是解绑：VBO: glBindBuffer(GL_ARRAY_BUFFER, 0) or IBO: glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)</em></p><p>所以VBO的解绑并不会影响VAO对其数据的访问（已经通过<code>glVertexAttribPointer</code>保存了指针），而IBO的解绑就会导致VAO无法访问索引（变成0号IBO了）</p><h3 id="深入VAO"><a href="#深入VAO" class="headerlink" title="深入VAO"></a>深入VAO</h3><p>实际上，在现代<code>OpenGL</code>中，在<code>VAO</code>出现后（v3.0），必须使用VAO才能绘制</p><p>如果你不显示地定义一个<code>VAO</code>，那么默认（兼容模式）会提供的一个默认<code>VAO</code>以供绑定；&#x2F;&#x2F;核心模式不提供</p><p>所以，我们可以简单地这么想：</p><p><code>OpenGL</code>的<code>draw</code>绘制函数就是从当前的VAO中读取VBO和IBO信息，并进行绘制的</p><p><strong>那么，只要在绘制前，VAO中绑定了IBO，就可以正常运行</strong></p><p><strong>而在定义IBO时，并不需要绑定VAO</strong></p><p>所以我们可以酱紫：</p><p>初始化部分：<em>伪代码</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VAO.<span class="hljs-built_in">bind</span>();<br>VBO.<span class="hljs-built_in">bind</span>();<br>VBO.<span class="hljs-built_in">setData</span>();<br><span class="hljs-comment">//解释VBO数据</span><br>VBO.<span class="hljs-built_in">unbind</span>();<br>VAO.<span class="hljs-built_in">unbind</span>();<br><br>IBO.<span class="hljs-built_in">bind</span>();<br>IBO.<span class="hljs-built_in">setData</span>();<br>IBO.<span class="hljs-built_in">unbind</span>();<br></code></pre></td></tr></table></figure><p>绘制部分：<em>伪代码</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">VAO.<span class="hljs-built_in">bind</span>();<br>IBO.<span class="hljs-built_in">bind</span>(); <span class="hljs-comment">//绘制前再绑定到VAO</span><br><span class="hljs-comment">//draw()绘制</span><br>IBO.<span class="hljs-built_in">unbind</span>();<br><br>IBO2.<span class="hljs-built_in">bind</span>(); <span class="hljs-comment">//切换IBO</span><br><span class="hljs-comment">//draw()绘制</span><br>IBO2.<span class="hljs-built_in">unbind</span>();<br></code></pre></td></tr></table></figure><p>哦对，还想起个问题，为啥<code>VAO</code>这名嫩奇怪啊，顶点数组对象？</p><p>其实是酱紫，我们可以吧ta看成一个数组，每一个元素都是一组顶点数据，通过<code>glVertexAttribPointer</code>设置</p><p>比如<code>VAO[0]</code>是坐标，<code>VAO[1]</code>是颜色，<code>VAO[2]</code>是法向量酱紫（当然通过[]访问是为了好理解）</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/Mhypnos/article/details/123516615">OpenGL理解VBO，IBO，VAO_vbo和ibo_Mhypnos的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/sixdaycoder/article/details/78951764">[Modern OpenGL]谈谈VAO、VBO、IBO_SixDayCoder的博客-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/39082624">VAO和EBO解绑定的坑？ - 知乎</a></p><p><a href="https://blog.csdn.net/xiji333/article/details/114934590">OpenGL VAO VBO EBO(IBO)的绑定、解绑问题_解绑vbo,veo_csu_xiji的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/392128223">Opengl的VAO个人理解 - 知乎</a></p><p><strong>特别鸣谢</strong>：<code>New Bing</code> &amp; <code>ChatGPT</code></p>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt-鼠标长按式弹出菜单的一种实现方案</title>
    <link href="/2022/10/26/Qt-%E9%BC%A0%E6%A0%87%E9%95%BF%E6%8C%89%E5%BC%8F%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2022/10/26/Qt-%E9%BC%A0%E6%A0%87%E9%95%BF%E6%8C%89%E5%BC%8F%E5%BC%B9%E5%87%BA%E8%8F%9C%E5%8D%95%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>菜单，所为何物？</p><p>餐馆里菜品的种类表嘛</p><p>核理 太河里了</p><p>今天的blog就写到这里，开饭了</p><p>end</p><p>在软件中，在大众印象里，菜单应该是右键单击后弹出来的那玩意儿：</p><p><img src="/img/image-20221026191207095.png" alt="Menu"></p><p>横平竖直，死板而不富有生力</p><p>但是菜单项右侧的小箭头预示着 该项也是个菜单，可以开启二级菜单</p><p>同理可以开启多级菜单，aka 级联菜单</p><p><img src="/img/image-20221026191539227.png" alt="级联菜单"></p><p><code>Qt</code>中，这玩意儿叫做<code>QMenu</code></p><p><code>QMenu</code>中可以放入若干个菜单项：</p><ul><li>可以是QAction</li><li>也可以是QMenu，构成级联树状结构</li></ul><p>太好了，<code>Qt</code>提供了<code>QMenu</code>，太好用了，简直是救苦救难活菩萨</p><p>blog到这里又可以结束了 开饭了</p><h3 id="欲求不满"><a href="#欲求不满" class="headerlink" title="欲求不满"></a>欲求不满</h3><p>太没追求了，太埋汰了，太丑了</p><p>他甚至不能自定义菜单项的位置，只能垂直排列</p><p>作为一个有追求的程序员，决不能就此罢休</p><p>让我们来康康<code>Maya</code>的菜单：</p><p><img src="/img/image-20221026192838016.png" alt="Maya Menu"></p><p>我靠，什么叫<code>Maya</code>，什么叫业内标杆，就一个字：newbility</p><h3 id="哭闹"><a href="#哭闹" class="headerlink" title="哭闹"></a>哭闹</h3><p>我也要我也要，不嘛不嘛，我就要，www</p><p>我不听我不听，别人有我也要</p><h3 id="义眼盯针"><a href="#义眼盯针" class="headerlink" title="义眼盯针"></a>义眼盯针</h3><p>论断：</p><blockquote><p>这肯定是自绘菜单，肯定不是用的系统菜单（虽然QMenu也是Qt自绘的）</p></blockquote><p>你问我怎么知道的？</p><p>我只能说：dddd，懂的都懂，不懂的也不必多说，这里面的水很深，不说也是为你好</p><h2 id="正片（叠底"><a href="#正片（叠底" class="headerlink" title="正片（叠底"></a>正片（叠底</h2><p>那么要如何实现这种效果呢？</p><h3 id="大聪明"><a href="#大聪明" class="headerlink" title="大聪明"></a>大聪明</h3><p>有人可能会说：一个menu不行，那就多个menu同时<code>popup()</code>就可以了呀</p><p>聪明，太聪明了</p><p>但是经过实验发现，只有一个menu可以响应鼠标划过（hover），其他的均无反应</p><h3 id="自绘"><a href="#自绘" class="headerlink" title="自绘"></a>自绘</h3><p>当然，自绘控件（窗体）肯定是最优解决方案，自定义程度最高，如：</p><p><img src="/img/image-20221026194920895.png" alt="自绘菜单"></p><p>这是一个图片查看器的右键菜单，长按右键弹出，并且可以实现花里胡哨的效果</p><p>但是要注意一个问题，一般的菜单都是可以实现级联的</p><p>如果要自绘实现级联，那代码量就可想而知了</p><p>所以这个方案好是好，但是我是懒狗，o(╥﹏╥)o</p><h3 id="女娲补天"><a href="#女娲补天" class="headerlink" title="女娲补天"></a>女娲补天</h3><p>实际上，仔细观察<code>Maya</code>的菜单，只有第一级菜单是持久显示的</p><p>只要解决了第一级菜单的显示和响应，后续菜单直接使用<code>QMenu</code>即可</p><p>也就是只要实现第一级触发器即可</p><p>那么有什么能持久显示在窗体上呢</p><p>那么显然，除了<code>QMenu</code>都可以…</p><p>好的，当然，经过层层筛选，发现<code>QToolButton</code>是最合适的载体</p><p>因为这个控件自带菜单显示（setMenu方法）</p><p>补充一点：showMenu是阻塞方法（类似exec，内部循环），在<code>QTimer</code>中用会阻断<code>Timer</code></p><h2 id="正片"><a href="#正片" class="headerlink" title="正片"></a>正片</h2><p>根据高内聚低耦合精神，我们决定将菜单封装为一个单独的窗体</p><p>在窗体上放置<code>QToolButton</code>作为菜单的载体，自然地解决了级联菜单问题</p><p>然后再将窗体设置为透明和鼠标穿透</p><p>Perfect</p><p>哦，我的上帝，太简单了</p><blockquote><p>简直是原子核脑袋</p></blockquote><p>还记得我们的标题吗：长按鼠标弹出菜单</p><p>参考：Apex长按中键弹出标记菜单，松开即可标记</p><p><img src="/img/image-20221026201007425.png" alt="Apex Menu"></p><p>所以这题真正的难点在于：按住鼠标按键，并响应菜单</p><p>一般人可能不觉得这有什么难的</p><p>像Apex和Maya自绘的话，也当然不是什么难题</p><p>但对于偷鸡取巧的我们来讲，这就差点被<strong>checkmate</strong>了</p><p>偷鸡，是要承担后果的</p><h3 id="Windows窗口焦点系统"><a href="#Windows窗口焦点系统" class="headerlink" title="Windows窗口焦点系统"></a>Windows窗口焦点系统</h3><p>众所周知，只有焦点窗口才能接收鼠标和键盘输入</p><p>这其中，当属鼠标焦点最特殊</p><blockquote><p>在一个窗口A内，按住鼠标任意按键，拖动鼠标至窗口B，Press &amp; Move &amp; Release消息都会发送给窗口A</p><p>导致作为菜单弹出的B无法正常响应鼠标（即便是转移焦点也不行）</p></blockquote><p>也就是在窗口A中按住鼠标中键弹出菜单B的话，菜单B中的<code>QToolButton</code>是无法正常响应鼠标的，也就无法自动弹出Menu</p><p>离奇的是弹出的<code>QMenu</code>是可以响应鼠标hover的（怀疑是自行拦截了qApp事件）</p><p>所以我们的目标就是让<code>QToolButton</code>响应鼠标并弹出Menu</p><p>唯一的方法是向<code>qApp</code>安装事件过滤器，过滤所有mouseMove事件，控制菜单的弹出和关闭</p><p>当然细节很多，但是有了大思路，小细节只要耐心即可解决</p><p><img src="/img/image-20221026210503942.png" alt="Follower Menu"></p><p>具体可以参考：<a href="https://gitee.com/mrbeanc/follower-v2.0/blob/master/toolmenu.cpp">toolmenu.cpp · 蔡姬&#x2F;Follower v2.0 - 码云 - 开源中国 (gitee.com)</a></p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://stackoverflow.com/questions/22948145/how-to-show-the-menu-in-qpushbutton-without-blocking/22972318#22972318">qt - How to show the menu in QPushButton without blocking? - Stack Overflow</a></p><p><a href="https://gitee.com/mrbeanc/follower-v2.0/blob/master/toolmenu.cpp">toolmenu.cpp · 蔡姬&#x2F;Follower v2.0 - 码云 - 开源中国 (gitee.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Menu</tag>
      
      <tag>MouseLongPress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt-事件循环 &amp; 模态窗口</title>
    <link href="/2022/10/21/Qt-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E6%A8%A1%E6%80%81%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/10/21/Qt-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-%E6%A8%A1%E6%80%81%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>質問：</p><blockquote><p>为什么模态对话框会阻塞其他窗口的交互？</p></blockquote><p>众所周知，调用<code>QDialog::exec</code>会开启一个模态对话框，阻塞后续代码，并阻止其他窗口的交互</p><p>But Why？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QDialog::exec</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_D</span>(QDialog);<br>...<br>    <span class="hljs-built_in">setAttribute</span>(Qt::WA_ShowModal, <span class="hljs-literal">true</span>);<br>...<br>    <span class="hljs-built_in">show</span>();<br>...<br>    QEventLoop eventLoop;<br>    (<span class="hljs-type">void</span>) eventLoop.<span class="hljs-built_in">exec</span>(QEventLoop::DialogExec);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>观察源码可知，<code>exec</code>方法将窗口设置为了模态（Modal），并开启了局部事件循环</p><p>那么，究竟是局部事件循环阻止了与其他窗口的交互，还是<code>Modal</code>属性的仕業（しわざ）呢</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>首先来看看什么是事件循环</p><p>我们在<code>Qt</code>桌面程序的<code>main</code>函数里就能看到<code>QApplicaion::exec()</code></p><p>其内部就开了一个事件循环，也称为<code>Qt</code>程序的主循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QCoreApplication::exec</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>QEventLoop eventLoop;<br>eventLoop.<span class="hljs-built_in">exec</span>();<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QEventLoop::exec</span><span class="hljs-params">(ProcessEventsFlags flags)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>    <span class="hljs-keyword">while</span> (!d-&gt;exit.<span class="hljs-built_in">loadAcquire</span>())<br>        <span class="hljs-built_in">processEvents</span>(flags | WaitForMoreEvents | EventLoopExec);<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">QEventLoop::processEvents</span><span class="hljs-params">(ProcessEventsFlags flags)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_D</span>(QEventLoop);<br>    <span class="hljs-keyword">if</span> (!d-&gt;threadData-&gt;<span class="hljs-built_in">hasEventDispatcher</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> d-&gt;threadData-&gt;eventDispatcher.<span class="hljs-built_in">loadRelaxed</span>()-&gt;<span class="hljs-built_in">processEvents</span>(flags);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，事件循环的本质就是一个死循环，不断接收内部外部的各种消息，并派发到对应的函数进行处理</p><p>所以<code>exec</code>之后的（同一函数内的）代码在循环结束前是不会得到执行机会的（阻塞）</p><p>事件循环的本质就是以队列的方式再次分配线程时间片</p><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>事件循环还有一个重要性质，ta是可以被嵌套的</p><p>也就是在<code>QApplicaion::exec()</code>主循环内还可以开启局部事件循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QEventLoop eventLoop;<br>eventLoop.<span class="hljs-built_in">exec</span>();<br></code></pre></td></tr></table></figure><p>就像<code>while</code>循环一样，局部事件循环运行时，父循环就处于停滞状态</p><p>局部事件循环跳出后，父循环继续运行</p><p>不过，问题不大，事件循环本身就只是派发事件，与谁父谁子无关，局部循环同样能承担一样的职能</p><p><code>Qt</code>会把事件分发到生效的事件循环中去</p><p>所以，虽然<code>eventLoop.exec();</code>后的代码被阻塞，但是<code>UI</code>交互、<code>Timer</code>等等各类事件都是正常执行的</p><blockquote><p> 也就是一个函数被阻塞，但是千千万万个函数在阻塞前的那行代码内运行</p></blockquote><blockquote><p>时间停止了？不，世界仍在运行，只有你停滞不前 —— 蔡姬</p></blockquote><p>正因为如此，局部事件循环的妙用就是在不阻塞<code>UI</code>的前提下，实现函数的同步执行</p><p>例如：等待服务器响应，计算超时等等</p><h3 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h3><p>事件循环并不阻塞<code>UI</code>，不可能导致对话框阻塞其他窗口的交互</p><h2 id="迷"><a href="#迷" class="headerlink" title="迷"></a>迷</h2><p>那究竟是谁，干了这好事（恼）</p><p>只有模态属性了吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QDialog dia;<br>dia.<span class="hljs-built_in">setModal</span>(<span class="hljs-literal">true</span>);<br>dia.<span class="hljs-built_in">show</span>();<br></code></pre></td></tr></table></figure><p>确实如此，只要设置模态属性，就能实现交互阻塞</p><p>而且还有两种模式：</p><table><thead><tr><th align="center">模式</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">Qt::ApplicationModal</td><td align="center">阻塞应用程序的所有窗口</td></tr><tr><td align="center">Qt::WindowModal</td><td align="center">阻塞父窗口、祖先窗口及它们的子窗口</td></tr></tbody></table><h2 id="始作俑者"><a href="#始作俑者" class="headerlink" title="始作俑者"></a>始作俑者</h2><p>但是，为什么</p><p>难道说</p><blockquote><p>我真傻，真的</p><p>我一直以为阻塞是不得已而为之，却忘了人心险恶</p></blockquote><p>这极有可能是<code>Qt</code>在内部手动屏蔽了其他窗口的交互，只为了强制用户专心于模态窗口</p><blockquote><p>www 我真傻 真的</p></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>对了，还有一点</p><p><code>QEventLoop::ProcessEventsFlags</code>的枚举值在<code>Qt</code>文档中被刻意隐藏了一些</p><p>比如<code>Qt</code>源码中的<code>QEventLoop::DialogExec</code></p><p>原因未知</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/weixin_42981623/article/details/107593343">Qt事件循环详解（一）_一只向前的程序猿的博客-CSDN博客_qt循环</a></p><p><a href="https://www.cnblogs.com/senior-engineer/p/9629612.html">Qt 之 模态、非模态、半模态窗口的介绍及 实现QDialog的exec()方法 - maxiongying - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/goforwardtostep/article/details/53667566">Qt 之 模态、非模态、半模态窗口的介绍及 实现QDialog的exec()方法_前行中的小猪的博客-CSDN博客_qdialog模态显示</a></p><p><a href="https://www.cnblogs.com/findumars/p/4886573.html">QDialog 模态对话框与事件循环（exec其实就是调用了show和eventLoop.exec） - findumars - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/qiufenpeng/article/details/81583768">QT中使用QEventLoop来实现事件循环_「已注销」的博客-CSDN博客_qeventloop</a></p><p><a href="https://zhuanlan.zhihu.com/p/484482786">Qt | 模态对话框和非模态对话框 QDialog - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/CooCoChoco/p/14597001.html">Qt 模态窗口 - 索智源 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/easebone/article/details/46462435">Qt Object模型及其线程和事件处理_szonebit的博客-CSDN博客</a></p><p><a href="https://stackoverflow.com/questions/9523311/undocumented-processeventsflag-enums-in-qt">event handling - Undocumented ProcessEventsFlag enums in QT - Stack Overflow</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>EventLoop</tag>
      
      <tag>Modal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt-windeployqt部署发布浅谈</title>
    <link href="/2022/10/12/Qt-windeployqt%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E6%B5%85%E8%B0%88/"/>
    <url>/2022/10/12/Qt-windeployqt%E9%83%A8%E7%BD%B2%E5%8F%91%E5%B8%83%E6%B5%85%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，我们可以在<code>Qt Creator</code>中运行项目，或者是在<code>release/debug</code>文件夹中双击<code>exe</code>运行应用程序</p><p>有些同学可能对后者存在些许疑惑，时常会看到<code>找不到dll</code>等错误</p><p>这是由于未在环境变量中加入<code>msvc/bin</code> | <code>mingw/bin</code>等目录（环境变量可以看做是搜索目录）</p><p>而<code>bin</code>目录中存放的正是项目中依赖的各种<code>Qt-dll</code></p><blockquote><p> <code>exe</code>的运行依赖各种<code>dll</code>，这是常识</p></blockquote><p>但是具体依赖哪些<code>dll</code>，以及哪几类<code>dll</code>呢</p><p>从来源上，可以分为两种：<code>Windows dll</code> &amp; <code>Qt dll</code></p><ul><li><code>Windows dll</code>通常位于<code>C:\Windows\System32</code>文件夹下（以<code>x64</code>为例），一般系统自带，无需特殊处理</li><li><code>Qt dll</code>一般位于<code>msvc/bin</code> | <code>mingw/bin</code>（包含版本号），一般用户系统无<code>Qt</code>，大概率缺失，需要程序自带</li></ul><p>所以，为了将应用程序打包发布到一般<code>PC</code>上，我们需要搜集依赖的<code>Qt-dll</code>并与<code>exe</code>置于同级目录下，方便寻址</p><blockquote><p>But How</p></blockquote><h2 id="正片（叠底"><a href="#正片（叠底" class="headerlink" title="正片（叠底"></a>正片（叠底</h2><p>我们可以通过</p><ul><li><code>Dependencies</code>软件</li><li><code>任务管理器 - 性能 - 资源监视器 - 模块</code></li></ul><p>查看<code>exe</code>的<code>dll</code>依赖</p><p>但是一个个复制实在是，情けない，丢程序员的脸！</p><p><code>Qt</code>为我们提供了命令行工具<code>windeployqt</code>来自动化部署（这名字：win + deploy +qt 秀）</p><p>当然，我们不能在<code>cmd</code>中直接使用该命令</p><p>而是应该在Qt提供的命令行环境 <code>Qt 5.15.2 (MSVC 2019 64-bit)</code> | <code>Qt 5.15.2 (MinGW 8.1.0 64-bit)</code>中进行（选择对应的编译器和版本）</p><p>详细原因请参考我的另一篇blog：<a href="https://mrbeancpp.github.io/2021/09/17/windeployqt%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE-%E4%B8%BA%E4%BD%95%E6%80%BB%E6%98%AF%E7%BC%BA%E5%B0%91dll/">windeployqt发布项目 为何总是缺少dll - MrBeanC-Blog (mrbeancpp.github.io)</a></p><p>我们这次的重点并不在于此</p><h2 id="windeployqt"><a href="#windeployqt" class="headerlink" title="windeployqt"></a>windeployqt</h2><p>&#x2F;&#x2F;该工具可以帮助我们将<code>exe</code>所需要的<code>Qt-dll</code>拷贝到<code>exe</code>同级目录下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">Usage: <span class="hljs-title">windeployqt</span> [<span class="hljs-title">options</span>] [<span class="hljs-title">files</span>]</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Options</span>:</span><br><span class="hljs-function">  -?, -<span class="hljs-title">h</span>, --<span class="hljs-title">help</span>            <span class="hljs-title">Displays</span> <span class="hljs-title">this</span> <span class="hljs-title">help</span>.</span><br><span class="hljs-function">  -<span class="hljs-title">v</span>, --<span class="hljs-title">version</span>             <span class="hljs-title">Displays</span> <span class="hljs-title">version</span> <span class="hljs-title">information</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">dir</span> &lt;<span class="hljs-title">directory</span>&gt;         <span class="hljs-title">Use</span> <span class="hljs-title">directory</span> <span class="hljs-title">instead</span> <span class="hljs-title">of</span> <span class="hljs-title">binary</span> <span class="hljs-title">directory</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">libdir</span> &lt;<span class="hljs-title">path</span>&gt;           <span class="hljs-title">Copy</span> <span class="hljs-title">libraries</span> <span class="hljs-title">to</span> <span class="hljs-title">path</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">plugindir</span> &lt;<span class="hljs-title">path</span>&gt;        <span class="hljs-title">Copy</span> <span class="hljs-title">plugins</span> <span class="hljs-title">to</span> <span class="hljs-title">path</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">debug</span>                   <span class="hljs-title">Assume</span> <span class="hljs-title">debug</span> <span class="hljs-title">binaries</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">release</span>                 <span class="hljs-title">Assume</span> <span class="hljs-title">release</span> <span class="hljs-title">binaries</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">pdb</span>                     <span class="hljs-title">Deploy</span> .<span class="hljs-title">pdb</span> <span class="hljs-title">files</span> (<span class="hljs-title">MSVC</span>).</span><br><span class="hljs-function">  --<span class="hljs-title">force</span>                   <span class="hljs-title">Force</span> <span class="hljs-title">updating</span> <span class="hljs-title">files</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">dry</span>-<span class="hljs-title">run</span>                 <span class="hljs-title">Simulation</span> <span class="hljs-title">mode</span>. <span class="hljs-title">Behave</span> <span class="hljs-title">normally</span>, <span class="hljs-title">but</span> <span class="hljs-title">do</span> <span class="hljs-title">not</span></span><br><span class="hljs-function">                            <span class="hljs-title">copy</span>/<span class="hljs-title">update</span> <span class="hljs-title">any</span> <span class="hljs-title">files</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">patchqt</span>              <span class="hljs-title">Do</span> <span class="hljs-title">not</span> <span class="hljs-title">patch</span> <span class="hljs-title">the</span> <span class="hljs-title">Qt5Core</span> <span class="hljs-title">library</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">plugins</span>              <span class="hljs-title">Skip</span> <span class="hljs-title">plugin</span> <span class="hljs-title">deployment</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">libraries</span>            <span class="hljs-title">Skip</span> <span class="hljs-title">library</span> <span class="hljs-title">deployment</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">qmldir</span> &lt;<span class="hljs-title">directory</span>&gt;      <span class="hljs-title">Scan</span> <span class="hljs-title">for</span> <span class="hljs-title">QML</span>-<span class="hljs-title">imports</span> <span class="hljs-title">starting</span> <span class="hljs-title">from</span> <span class="hljs-title">directory</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">quick</span>-<span class="hljs-title">import</span>         <span class="hljs-title">Skip</span> <span class="hljs-title">deployment</span> <span class="hljs-title">of</span> <span class="hljs-title">Qt</span> <span class="hljs-title">Quick</span> <span class="hljs-title">imports</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">translations</span>         <span class="hljs-title">Skip</span> <span class="hljs-title">deployment</span> <span class="hljs-title">of</span> <span class="hljs-title">translations</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">system</span>-<span class="hljs-title">d3d</span>-<span class="hljs-title">compiler</span>  <span class="hljs-title">Skip</span> <span class="hljs-title">deployment</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">system</span> <span class="hljs-title">D3D</span> <span class="hljs-title">compiler</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">compiler</span>-<span class="hljs-title">runtime</span>        <span class="hljs-title">Deploy</span> <span class="hljs-title">compiler</span> <span class="hljs-title">runtime</span> (<span class="hljs-title">Desktop</span> <span class="hljs-title">only</span>).</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">compiler</span>-<span class="hljs-title">runtime</span>     <span class="hljs-title">Do</span> <span class="hljs-title">not</span> <span class="hljs-title">deploy</span> <span class="hljs-title">compiler</span> <span class="hljs-title">runtime</span> (<span class="hljs-title">Desktop</span> <span class="hljs-title">only</span>).</span><br><span class="hljs-function">  --<span class="hljs-title">webkit2</span>                 <span class="hljs-title">Deployment</span> <span class="hljs-title">of</span> <span class="hljs-title">WebKit2</span> (<span class="hljs-title">web</span> <span class="hljs-title">process</span>).</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">webkit2</span>              <span class="hljs-title">Skip</span> <span class="hljs-title">deployment</span> <span class="hljs-title">of</span> <span class="hljs-title">WebKit2</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">json</span>                    <span class="hljs-title">Print</span> <span class="hljs-title">to</span> <span class="hljs-title">stdout</span> <span class="hljs-title">in</span> <span class="hljs-title">JSON</span> <span class="hljs-title">format</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">angle</span>                   <span class="hljs-title">Force</span> <span class="hljs-title">deployment</span> <span class="hljs-title">of</span> <span class="hljs-title">ANGLE</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">angle</span>                <span class="hljs-title">Disable</span> <span class="hljs-title">deployment</span> <span class="hljs-title">of</span> <span class="hljs-title">ANGLE</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">no</span>-<span class="hljs-title">opengl</span>-<span class="hljs-title">sw</span>            <span class="hljs-title">Do</span> <span class="hljs-title">not</span> <span class="hljs-title">deploy</span> <span class="hljs-title">the</span> <span class="hljs-title">software</span> <span class="hljs-title">rasterizer</span> <span class="hljs-title">library</span>.</span><br><span class="hljs-function">  --<span class="hljs-title">list</span> &lt;<span class="hljs-title">option</span>&gt;           <span class="hljs-title">Print</span> <span class="hljs-title">only</span> <span class="hljs-title">the</span> <span class="hljs-title">names</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">files</span> <span class="hljs-title">copied</span>.</span><br><span class="hljs-function">                            <span class="hljs-title">Available</span> <span class="hljs-title">options</span>:</span><br><span class="hljs-function">                             <span class="hljs-title">source</span>:   <span class="hljs-title">absolute</span> <span class="hljs-title">path</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">source</span> <span class="hljs-title">files</span></span><br><span class="hljs-function">                             <span class="hljs-title">target</span>:   <span class="hljs-title">absolute</span> <span class="hljs-title">path</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">target</span> <span class="hljs-title">files</span></span><br><span class="hljs-function">                             <span class="hljs-title">relative</span>: <span class="hljs-title">paths</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">target</span> <span class="hljs-title">files</span>, <span class="hljs-title">relative</span></span><br><span class="hljs-function">                                       <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">target</span> <span class="hljs-title">directory</span></span><br><span class="hljs-function">                             <span class="hljs-title">mapping</span>:  <span class="hljs-title">outputs</span> <span class="hljs-title">the</span> <span class="hljs-title">source</span> <span class="hljs-title">and</span> <span class="hljs-title">the</span> <span class="hljs-title">relative</span></span><br><span class="hljs-function">                                       <span class="hljs-title">target</span>, <span class="hljs-title">suitable</span> <span class="hljs-title">for</span> <span class="hljs-title">use</span> <span class="hljs-title">within</span> <span class="hljs-title">an</span></span><br><span class="hljs-function">                                       <span class="hljs-title">Appx</span> <span class="hljs-title">mapping</span> <span class="hljs-title">file</span></span><br><span class="hljs-function">  --<span class="hljs-title">verbose</span> &lt;<span class="hljs-title">level</span>&gt;         <span class="hljs-title">Verbose</span> <span class="hljs-title">level</span>.</span><br><span class="hljs-function">  </span><br><span class="hljs-function"><span class="hljs-title">Arguments</span>:</span><br><span class="hljs-function">  [<span class="hljs-title">files</span>]                   <span class="hljs-title">Binaries</span> <span class="hljs-title">or</span> <span class="hljs-title">directory</span> <span class="hljs-title">containing</span> <span class="hljs-title">the</span> <span class="hljs-title">binary</span>.</span><br></code></pre></td></tr></table></figure><p>只要在命令行中改变(<code>cd·Change Directory</code>)工作目录至<code>exe</code>所在目录</p><p>并执行<code>windeployqt test.exe</code></p><p>便会自动将依赖文件（包括<code>dll</code>和图标等众文件）拷贝至<code>exe</code>所在目录</p><p>此时，打包为压缩包并一齐发布即可</p><h3 id="MSVC背刺"><a href="#MSVC背刺" class="headerlink" title="MSVC背刺"></a>MSVC背刺</h3><p>如果是<code>MSVC</code>编译器，要注意一点</p><p><code>MSVC</code>依赖于<code>VS</code>，可能会用到<code>VS</code>下的一些<code>dll</code>如：<code>MSVCP140.dll</code>等<code>C++</code>运行时环境</p><p>不属于<code>Qt</code>，所以需要自行拷贝（虽然多数电脑上包含）</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>如果你认为这篇博客到此为止，那就太年轻了</p><p>那和一般的CV blog有什么区别</p><p>咳咳</p><p><code>windeployqt</code>直接打包发布，运行并无大碍，但问题在于默认复制的依赖多数冗余，需要手动精简</p><h3 id="何がいる"><a href="#何がいる" class="headerlink" title="何がいる"></a>何がいる</h3><h4 id="libEGL-libGLESV2-opengl32sw"><a href="#libEGL-libGLESV2-opengl32sw" class="headerlink" title="libEGL libGLESV2 opengl32sw"></a>libEGL libGLESV2 opengl32sw</h4><p><code>libEGL.dll</code>,<code>libGLESV2.dll</code>这两个文件是 ANGLE 的文件，可以去掉</p><p><code>opengl32sw.dll</code>是软件模拟 OpenGL，除非用户的系统连 DirectX 支持都不完整（例如虚拟机），不然也没用</p><p>可以用<code>--no-angle</code> &amp; <code>--no-opengl-sw</code>这俩参数去除</p><h4 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h4><p>如果没有使用<code>svg</code>的话，<code>iconengines\qsvgicon.dll</code>, <code>imageformats\qsvg.dll</code>, <code>Qt5Svg.dll</code> 这三个文件也可以删掉</p><p>这是矢量图格式，大部分程序应该都不需要</p><h4 id="translations"><a href="#translations" class="headerlink" title="translations"></a>translations</h4><p>如果没有国际化支持的话，<code>translations</code>文件夹可以整个删掉</p><p>或者使用参数<code>--no-translations</code></p><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><p>综上，推荐使用：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">windeployqt --no-angle --no-opengl-sw --no-translations app.exe<br></code></pre></td></tr></table></figure><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/itas109/article/details/80497065">QT使用windeployqt部署发布及其精简_itas109的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/u012830675/article/details/102495371">QT MSVC编译项目打包_易日的博客-CSDN博客</a></p><p><a href="https://mrbeancpp.github.io/2021/09/17/windeployqt%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE-%E4%B8%BA%E4%BD%95%E6%80%BB%E6%98%AF%E7%BC%BA%E5%B0%91dll/">windeployqt发布项目 为何总是缺少dll - MrBeanC-Blog (mrbeancpp.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>windeployqt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一对airpods引发的程序员脑细胞大死亡事件</title>
    <link href="/2022/10/10/%E4%B8%80%E5%AF%B9airpods%E5%BC%95%E5%8F%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E8%84%91%E7%BB%86%E8%83%9E%E5%A4%A7%E6%AD%BB%E4%BA%A1%E4%BA%8B%E4%BB%B6/"/>
    <url>/2022/10/10/%E4%B8%80%E5%AF%B9airpods%E5%BC%95%E5%8F%91%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E8%84%91%E7%BB%86%E8%83%9E%E5%A4%A7%E6%AD%BB%E4%BA%A1%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，当你独自宅于自己的小房间时，可能会播放一些**的内容</p><p>此时，要是有一只名为<code>Human</code>的生物进入，<code>You</code>则会立刻社会性死亡</p><p>为了避免这种情况，我们需要：快速切换音频输出设备（between 扬声器 &amp; 耳机）</p><blockquote><p>But How to make it programmatically?</p></blockquote><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>获取所有音频输出设备</li><li>切换音频输出设备</li></ol><p>针对<strong>第一点</strong>，<code>Qt</code>提供了快捷方案（<code>QAudioDeviceInfo</code>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QStringList <span class="hljs-title">Win::validAudioOutputDevices</span><span class="hljs-params">()</span> <span class="hljs-comment">//第一个元素就是当前设备</span></span><br><span class="hljs-function"></span>&#123;<br>    QStringList devList;<br>    QList&lt;QAudioDeviceInfo&gt; audioDeviceList = QAudioDeviceInfo::<span class="hljs-built_in">availableDevices</span>(QAudio::AudioOutput);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; dev : <span class="hljs-built_in">qAsConst</span>(audioDeviceList)) &#123;<br>        <span class="hljs-type">const</span> QString&amp; name = dev.<span class="hljs-built_in">deviceName</span>();<br>        <span class="hljs-type">int</span> index = name.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">&quot; (&quot;</span>); <span class="hljs-comment">//&quot;耳机 (Realtek(R) Audio)&quot;-&gt;&quot;耳机&quot;</span><br>        devList &lt;&lt; (index == <span class="hljs-number">-1</span> ? name : name.<span class="hljs-built_in">left</span>(index));<br>    &#125;<br>    <span class="hljs-keyword">return</span> devList;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>&quot;耳机 (Realtek(R) Audio)&quot;-&gt;&quot;耳机&quot;</code>是为了下一步，切换音频输出设备做准备（同时也为一切埋下了隐患）</p><p><strong>第二点</strong>，切换音频设备，说实话，<code>Qt</code>没有什么办法（不合理啊喂，能获取为什么不能切换），<code>Windows API</code>里也没有什么便捷的办法，寄</p><p>但是，找到了一个第三方命令行工具，可以提供切换功能：<code>nircmd.exe</code></p><p>用法如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">nircmd setdefaultsounddevice &quot;耳机&quot; #不包含括号内的额外信息(Realtek(R) Audio)<br></code></pre></td></tr></table></figure><p><code>Qt</code>开启外部进程并传参也不是什么难事：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Win::setActiveAudioOutputDevice</span><span class="hljs-params">(<span class="hljs-type">const</span> QString&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br>    QProcess pro;<br>    pro.<span class="hljs-built_in">setProgram</span>(<span class="hljs-string">&quot;nircmd&quot;</span>);<br>    pro.<span class="hljs-built_in">setArguments</span>(<span class="hljs-built_in">QStringList</span>() &lt;&lt; <span class="hljs-string">&quot;setdefaultsounddevice&quot;</span> &lt;&lt; name);<br>    pro.<span class="hljs-built_in">start</span>();<br>    pro.<span class="hljs-built_in">waitForFinished</span>(<span class="hljs-number">2000</span>);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;#Changed Audio Output Device:&quot;</span> &lt;&lt; name;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后，切换的逻辑不用我说吧</p><p>Okay，已经结束了，就这么简单，散了散了</p><h3 id="和平捍卫者"><a href="#和平捍卫者" class="headerlink" title="和平捍卫者"></a>和平捍卫者</h3><p>就这样，我快乐地用着这个程序，快乐地在扬声器 &amp; 耳机间反复横跳，好不快活</p><p>一切都是那么美好</p><p>直到有一天，我向<code>Darli</code>借了一对<code>airpods</code>，库克便告诉了我，什么叫年轻</p><h3 id="东窗事发"><a href="#东窗事发" class="headerlink" title="东窗事发"></a>东窗事发</h3><p>当我快乐地将<code>airpods</code>连上<code>PC(Windows)</code>，便发现<code>airpods</code>的完整设备名叫做：耳机 (Airpods)</p><p>…</p><p>好的，我们现在有了三个音频输出设备：</p><ul><li>扬声器 (Realtek(R) Audio)</li><li>耳机 (Realtek(R) Audio)</li><li>耳机 (Airpods)</li></ul><p>而<code>nircmd</code>在切换设备时，不需要括号中的额外内容，只需要设备名：”耳机”</p><p>这不就蛋糕了嘛，这有俩耳机呀，二义性！</p><p>根据我多年程序员的直觉来看，我们需要一个唯一标识符，但是显然<code>QAudioDeviceInfo</code>并没有提供相关<code>API</code></p><p>好的，两个<code>parts</code>，获取和切换，都寄了</p><h2 id="正片（叠底"><a href="#正片（叠底" class="headerlink" title="正片（叠底"></a>正片（叠底</h2><p>好的，开始面向浏览器编程</p><p>打开<code>Edge</code>，打开<code>Bing</code>，搜索：Windows C++ 切换音频输出设备</p><p>あった</p><p><a href="https://blog.csdn.net/wangkui1331/article/details/78618310">windows代码设置默认音频输出设备_kevin–你不知道的事的博客-CSDN博客</a></p><p>可以看到有亿点点复杂呀，而且用到了<a href="https://baike.baidu.com/item/COM%E7%BB%84%E4%BB%B6/3351509">COM组件</a></p><p>不过问题不大，talk is cheap，这代码都有了，还能出啥幺蛾子</p><blockquote><p>插电 - 开机！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> HRESULT STDMETHODCALLTYPE <span class="hljs-title">SetDefaultEndpoint</span><span class="hljs-params">( <span class="hljs-comment">//com接口声明</span></span></span><br><span class="hljs-params"><span class="hljs-function">        __in PCWSTR wszDeviceId,</span></span><br><span class="hljs-params"><span class="hljs-function">        __in ERole eRole </span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">Warning: &#x27;__in&#x27; has not been declared<br></code></pre></td></tr></table></figure><blockquote><p>看起来没啥用 不如删了 __in</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">HRESULT hr = <span class="hljs-built_in">CoCreateInstance</span>(__uuidof(CPolicyConfigVistaClient), <span class="hljs-literal">NULL</span>, CLSCTX_ALL, __uuidof(IPolicyConfigVista), (LPVOID *)&amp;pPolicyConfig);<br></code></pre></td></tr></table></figure><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">Warning: undefined reference to _GUID const&amp; __mingw_uuidof()<br></code></pre></td></tr></table></figure><p>aaaaa o(╥﹏╥)o</p><p>打开<code>Edge</code>，打开<code>Bing</code>，搜索：undefined reference to _GUID const&amp; __mingw_uuidof()</p><p><a href="https://blog.csdn.net/dyj095/article/details/114632051">Qt5+mingw 在windows系统上调用COM控件时，用到__uuidof()报undefined reference to _GUID const&amp; __mingw_uuidof()_dyj095的博客-CSDN博客</a></p><p>嗯，看起来很有道理，试试：Warning Warning</p><blockquote><p>真是山穷水复疑无路，柳暗花明又一坑啊</p></blockquote><p>蛋糕</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">hr = pStore-&gt;<span class="hljs-built_in">GetValue</span>(PKEY_Device_FriendlyName, &amp;friendlyName);<br></code></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Warning:</span> undefined reference <span class="hljs-keyword">to</span> `PKEY_Device_FriendlyName<span class="hljs-comment">&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="HowTime-Flies"><a href="#HowTime-Flies" class="headerlink" title="HowTime Flies"></a>HowTime Flies</h3><blockquote><p>时间就像海绵里的水，只要你愿意挤，总会被你挤完的</p></blockquote><p>不知道过了多久</p><blockquote><p>岁月不堪数，故人不如初</p></blockquote><blockquote><p>后来，南山的风吹散了谷堆，北海的水淹没了墓碑</p></blockquote><p>我还是TMD通不过编译</p><p>我终于明白了，所谓<code>MinGW</code>编译器和<code>Windows</code>相性差是怎么一回事了</p><blockquote><p>CDSN网友有云：如果是在QT中进行COM编程，则QT的编译套件必须为 MSVC</p></blockquote><p>关于MinGW和MSVC编译器的区别，可以看我上一篇文章：<a href="https://mrbeancpp.github.io/2022/10/09/Qt%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%81%E7%A7%BB%EF%BC%9A%E4%BB%8EMinGW%E5%88%B0MSVC/">Qt编译器迁移：从MinGW到MSVC - MrBeanC-Blog (mrbeancpp.github.io)</a></p><p>我终于明白了，是时候该换编译器了</p><h3 id="大清还未亡呢"><a href="#大清还未亡呢" class="headerlink" title="大清还未亡呢"></a>大清还未亡呢</h3><p>等，一下</p><p>我是否可以用<code>VS</code>将代码封装为<code>dll</code>，供<code>Qt</code>链接使用呢</p><p><a href="https://blog.csdn.net/qq_41688035/article/details/113755872">VS 2017 导出dll</a>（注意使用.h时，要去掉<code>__declspec(dllexport)</code> 或 改为<code>__declspec(dllimport)</code>）</p><p><code>VS</code>是微软的亲儿子，用的也是<code>MSVC</code>编译器，编译以上代码那是如鱼得水</p><p>三下五除二，<code>dll</code>，<code>lib</code>，<code>h</code>新鲜出炉</p><p>导入<code>Qt</code>！</p><p>叮，链接失败</p><p>原来，<code>C++</code>的<code>dll</code>在不同编译器中命名方式不同，不能跨编译器使用，只能加上<code>extern&quot;C&quot;</code>标志，以C方式导出，但是限制了只能使用C语言 </p><p>这….</p><p>noooooooooooooooooooooooooooooooooooo</p><p>改写为C，还是另寻出入，蔡先生陷入了迷茫</p><p>躲得过初一，躲不过十五啊，今朝Clang，后朝(chao)可怎么办呢</p><p>不能妥协！</p><h4 id="小小小补充"><a href="#小小小补充" class="headerlink" title="小小小补充"></a>小小小补充</h4><ul><li>封装为<code>exe</code>则不存在以上问题，参考<code>nircmd.exe</code>，但是开启外部进程效率较低</li><li>注册为COM组件，供Qt调用（等一下 Qt不是编译不过嘛（但是貌似有什么ActiveX类，貌似，貌似，再说））</li></ul><h3 id="大明还坚挺呢"><a href="#大明还坚挺呢" class="headerlink" title="大明还坚挺呢"></a>大明还坚挺呢</h3><p>难道，真的要换<code>MSVC</code>编译器了吗，www</p><p><code>Qt + VS</code>联合开发吗，哎</p><ul><li>下载VS（2022）的<code>Qt VS Tool</code></li><li>在<code>Qt</code>中添加<code>MSVC</code>套件</li></ul><p>在<code>VS</code>中新建<code>Qt</code>项目，熟悉，而又陌生</p><p><code>VS</code>中的<code>Qt</code>项目没有<code>.pro</code>文件，怎么看都不像是亲生的</p><p>一看文件夹，好家伙，一个空项目足足<code>204MB</code>，不愧是<code>VS</code>（里面全是文件索引之类的数据库）</p><p>成功了吗，但为什么我却一点也开心不起来呢</p><p>不，这不是我熟悉的<code>Qt</code>，又大又不完整，noooooooooooo</p><blockquote><p>我要，我要，我就要旺旺碎冰冰</p></blockquote><h3 id="China！"><a href="#China！" class="headerlink" title="China！"></a>China！</h3><p>不，我不甘心，不就是个<code>MSVC</code>编译器吗，跟我<code>Qt Creator</code>编辑器有什么关系</p><p>我不相信！</p><blockquote><p>插电 - 开机！</p></blockquote><p>切换<code>MSVC</code>编译套件！</p><p><img src="/img/image-20221010144059972.png" alt="切换套件"></p><p>诶，成了？成了！</p><p>WTF</p><h3 id="小丑竟是我自己"><a href="#小丑竟是我自己" class="headerlink" title="小丑竟是我自己"></a>小丑竟是我自己</h3><p>啊，焯，原来根本不需要<code>VS</code></p><p><code>Qt + MSVC</code> in <code>Windows</code> yyds</p><blockquote><p>编译 - 运行！爽</p></blockquote><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><p>具体切换步骤参考上一篇blog</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.zhihu.com/question/40225132">有哪些描述时间过得快的好句子？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/pigautumn/article/details/94381624">C++获取Windows音频设备列表_xhubobo的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/findumars/p/8001358.html">QT 调用 DLL 方法（三种方法） - findumars - 博客园</a></p><p><a href="https://www.cnblogs.com/sankye/p/5951852.html">QT总结第3篇：如何在QT中添加.lib，.dll还有.h文件 - Sankye - 博客园</a></p><p><a href="https://blog.csdn.net/Dorthyn/article/details/116224270">Qt 加载VS生成的C&#x2F;C++ dll_Dorthyn的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40285839/article/details/82657867">QT调用VS生成的DLL（无头文件）_qq_40285839的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_41688035/article/details/113755872">VS 2017 DLL文件的导出到调用步骤_嘎嘣脆341的博客-CSDN博客_vs导出dll</a></p><p><a href="https://www.itbaoku.cn/post/492615.html">QT5+如何为QMediaPlayer设置默认音频设备 - IT宝库 (itbaoku.cn)</a></p><p><a href="https://xiaolong.blog.csdn.net/article/details/113127300">QT应用编程: windows下QT调用COM组件并集成到QT界面_DS小龙哥的博客-CSDN博客_qt 调用com</a></p><p><a href="https://blog.csdn.net/dyj095/article/details/114632051">Qt5+mingw 在windows系统上调用COM控件时，用到__uuidof()报undefined reference to _GUID const&amp; __mingw_uuidof()_dyj095的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/bailang_zhizun/article/details/117779762?spm=1001.2014.3001.5502">QT - QT中的COM编程（exe进程外组件形式）_bailang_zhizun的博客-CSDN博客</a></p><p><a href="https://github.com/Belphemur/AudioEndPointLibrary">Belphemur&#x2F;AudioEndPointLibrary: A library based on DefSound to provides access to Default Sound Devices. (github.com)</a></p><p><a href="https://github.com/frgnca/AudioDeviceCmdlets">frgnca&#x2F;AudioDeviceCmdlets: AudioDeviceCmdlets is a suite of PowerShell Cmdlets to control audio devices on Windows (github.com)</a></p><p><a href="https://www.cnblogs.com/zzr-stdio/p/16289725.html">C++设置默认声音输出设备(SetDefaultAudioPlaybackDevice) - 这种人 - 博客园</a></p><p><a href="https://download.csdn.net/download/hx0318/10581431">C++修改默认音频输出设备_c切换音频输出设备-C++代码类资源-CSDN文库</a></p><p><a href="https://blog.csdn.net/wangkui1331/article/details/78618310">windows代码设置默认音频输出设备_kevin–你不知道的事的博客-CSDN博客</a></p><p><a href="http://www.nirsoft.net/utils/nircmd.html">NirCmd - Windows command line tool (nirsoft.net)</a></p><p><a href="http://www.nirsoft.net/utils/sound_volume_view.html#command_line">View &#x2F; change sound volume on Windows from command line or GUI (nirsoft.net)</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
      <tag>dll</tag>
      
      <tag>MinGW</tag>
      
      <tag>MSVC</tag>
      
      <tag>VS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt编译器迁移：从MinGW到MSVC</title>
    <link href="/2022/10/09/Qt%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%81%E7%A7%BB%EF%BC%9A%E4%BB%8EMinGW%E5%88%B0MSVC/"/>
    <url>/2022/10/09/Qt%E7%BC%96%E8%AF%91%E5%99%A8%E8%BF%81%E7%A7%BB%EF%BC%9A%E4%BB%8EMinGW%E5%88%B0MSVC/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Qt</code>支持两种编译器</p><ul><li>MSVC（Microsoft Visual C++ Compiler）：微软的VC编译器，如VS中自带</li><li>MinGW（Minimalist GNU for Windows）：是将GNU开发工具移植到Win32平台下的产物</li></ul><h3 id="疯玛吉：选择！"><a href="#疯玛吉：选择！" class="headerlink" title="疯玛吉：选择！"></a>疯玛吉：选择！</h3><p>那么，问题来了，小孩子才全都要，大人必须得选一个了</p><p>为什么要选呢</p><p><strong>第一个问题</strong>在于，<code>MSVC</code>和<code>MinGW</code>编译的<code>dll</code>通常不兼容，不能相互调用，这决定了你能用多少第三方库</p><ul><li>在<code>Windows</code>下，<code>MSVC</code>编译的库更多</li><li>但是<code>MinGW</code>的库能跨平台（<code>Linux</code>）</li></ul><p>所以你用哪个编译不取决于你想用哪个，取决于你习惯用来自哪个平台的第三方库</p><p><strong>其次</strong>，<code>MSVC</code>，一听就是微软家的，<code>Windows</code>也是微软家的，亲生的编译器不用我多说吧（例如一些<code>COM</code>组件的操作在<code>MinGW</code>中就死活不能通过）</p><p>总结：</p><ul><li><code>Windows</code>平台选<code>MSVC</code></li><li>跨平台选<code>MinGW</code></li></ul><h3 id="疯玛吉：再选择！"><a href="#疯玛吉：再选择！" class="headerlink" title="疯玛吉：再选择！"></a>疯玛吉：再选择！</h3><p>除了两种编译器，我们还有三种开发方式</p><p><img src="/img/image-20221009210739958.png" alt="对比"></p><p>在VS中可以更好地进行调试，但是毕竟不是原生方式，多少有点问题少年了</p><p>一般选择<code>QtCreator + MSVC</code>方式进行<code>Windows</code>开发</p><h2 id="正片（叠底"><a href="#正片（叠底" class="headerlink" title="正片（叠底"></a>正片（叠底</h2><p>诶，那你说，我作为一个<code>Windows</code>程序员，既然选择<code>QtCreator + MSVC</code>无疑，为什么会写下这篇迁移博客呢？</p><p>咳咳</p><p>说来惭愧，我一直以为<code>MSVC</code>必须要用<code>VS</code>配合开发，就……</p><p>害，说多了都是泪</p><h2 id="迁徙！"><a href="#迁徙！" class="headerlink" title="迁徙！"></a>迁徙！</h2><p>那么，在<code>Qt Creator</code>下，如何从<code>MinGW</code>切换为<code>MSVC</code>呢</p><p>其实说来也简单，首先，我们需要在<code>Qt</code>的<code>MaintenanceTool.exe</code>中添加<code>MSVC</code>组件（包含MSVC版本的dll）</p><p><img src="/img/image-20221009211741210.png" alt="Qt维护工具"></p><p>其次，需要下载对应版本的<code>VS</code>（在该例中，我下载的是2022版也ok hhh）</p><p>这样，<code>Qt</code>就能自动检测到<code>VS</code>中的<code>MSVC</code>编译器和<code>debugger</code>了</p><p>然后再项目中就能看到<code>MSVC</code>套件了，点击即可切换</p><p><img src="/img/image-20221009212022400.png" alt="切换toolkit"></p><h2 id="大逼兜"><a href="#大逼兜" class="headerlink" title="大逼兜"></a>大逼兜</h2><p>这就完了？想得美，这才哪到哪，也就算是刚在考卷上写完班级姓名吧</p><p>迎面而来的是满屏的<code>Warning</code>和<code>Error</code></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>其中最显眼的便是</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">warning</span> C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失<br></code></pre></td></tr></table></figure><p>这是由于<code>MSVC</code>（早期版本）默认只支持<code>UTF-8(with BOM)</code>，而<code>MinGW</code>的原始编码可能是<code>UFT-8</code>，导致了编码不兼容</p><p>其中一个办法是更改源文件编码，但费时费力，而且原始的中文可能编译后是乱码（文件中看不出来）</p><p>终极解决方案应该是在<code>.pro</code>文件中加入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs qmake">msvc &#123;<br>    QMAKE_CFLAGS += /utf-8<br>    QMAKE_CXXFLAGS += /utf-8<br>&#125;<br></code></pre></td></tr></table></figure><p>强制<code>MSVC</code>采用<code>utf-8</code>编译</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在现有工程中直接切换为<code>MSVC</code>还会导致编译问题</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>msvc-version.conf loaded but QMAKE_MSC_VER isn&#x27;t set<br></code></pre></td></tr></table></figure><p>还会导致识别不到项目文件</p><p>解决办法：手动清空工程原来编译后生成的文件夹及文件，重新生成工程即可</p><p>（特别是：.stash Makefile 之类的文件）</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>由于<code>MinGW</code>和<code>MSVC</code>的区别，某些库可能链接失败，需要手动在<code>.pro</code>文件中加入<code>lib</code></p><p>如：<code>LIBS += -luser32</code></p><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>仔细观察<code>Qt</code>的<code>MinGW</code>和<code>MSVC</code>文件夹，会发现他们的<code>dll</code>依赖都是不同的（同名但内容不同 推测是用对应编译器编译的）</p><p>并且<code>MSVC</code>的<code>dll</code>都是有两个版本的（Release和Debug（文件名+d））</p><p>更有甚者，<code>MSVC</code>的<code>plugins/audio</code>文件夹内居然多了一个<code>qtaudio_wasapi.dll</code></p><p>导致<code>QAudioDeviceInfo::availableDevices(QAudio::AudioOutput)</code>卡顿，且重复输出音频设备（转换编译器后发现的第一个恶性bug）</p><p>解决方案是删除该<code>dll</code></p><p>怪，真滴太怪了 家人们</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>不过，<code>Qt Creator</code>原生支持<code>MSVC</code>，不用联合<code>VS</code>了，よかった www</p><p>我真傻 真的</p><p>Peace</p><h2 id="Careful"><a href="#Careful" class="headerlink" title="Careful"></a>Careful</h2><p>为了让<code>exe</code>在非IDE环境下运行，我们通常都要设置环境变量（<code>PATH</code>）</p><p>但是当<code>MinGW/bin</code>和<code>MSVC/bin</code>的环境变量共存时</p><p>其中的同名<code>dll</code>会产生误导和冲突，<code>exe</code>会自动选择<strong>靠前</strong>的环境变量中的<code>dll</code></p><p>导致编译器不同时产生错误（<code>dll</code>不通用）</p><p>解决方案：</p><ul><li>改用同一个编译器</li><li>拷贝<code>dll</code>至<code>exe</code>同一目录（やばい）</li><li>手动设置<code>exe</code>环境变量</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.iamli.cc/archives/129#:~:text=MSVC%20%E4%B8%AD%E7%9A%84utf-8%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%20%2F,Qt%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%20%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8VS%E9%87%8C%E9%9D%A2%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E4%BB%A5UTF8%E4%BF%9D%E5%AD%98%E7%9A%84c%E6%BA%90%E7%A8%8B%E5%BA%8F%E6%97%B6%EF%BC%8C%20MSVC%E4%BC%9A%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BC%96%E7%A0%81%E4%BB%8EUTF8%E8%BD%AC%E6%8D%A2%E4%B8%BAANSI%E7%BC%96%E7%A0%81%20%28%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%A1%B5%E4%BB%A3%E7%A0%81%29">MSVC 中的utf-8编码问题 &#x2F; Qt中文乱码问题 – li的blog</a></p><p><a href="https://blog.csdn.net/lenkco/article/details/123932391">QT+MSVC的UTF-8配置、MSVC的UTF-8配置_lenkco的博客-CSDN博客_msvc utf8</a></p><p><a href="https://blog.csdn.net/qq_43521843/article/details/116864525">Qt记录：Qt编程遇C2001错误，提示“常量中有换行符”_星辰丶大海的博客-CSDN博客_qt常量中有换行符</a></p><p><a href="https://blog.csdn.net/u013185164/article/details/48160561?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-48160561-blog-80573034.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-48160561-blog-80573034.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2">Qt MinGW与MSVC对比_16ern的博客-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/331375227">Qt 用 MSVC 和 MinGW 哪个编译器编译程序比较好？ - 知乎</a></p><p><a href="https://blog.csdn.net/qq_38025219/article/details/105666735">Qt小白之选择何种开发方式（vs+qt or qt+mingw&#x2F;msvc）_行思坐忆，志凌云的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_52040845/article/details/118761684">QAudioDeviceInfo::availableDevices 获取语音输入设备问题_#苔花如米小#的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/u011602263/article/details/103882827">Qt编译错误： error: msvc-version.conf loaded but QMAKE_MSC_VER isn’t set_酷侠一剑绝ggh的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/u013245354/article/details/113772880">QtCreator + MSVC编译器开发_feimimizhiy的博客-CSDN博客_qtcreator配置编译器</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
      <tag>MinGW</tag>
      
      <tag>MSVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP 杂谈小记</title>
    <link href="/2022/09/16/Spring-AOP-%E6%9D%82%E8%B0%88%E5%B0%8F%E8%AE%B0/"/>
    <url>/2022/09/16/Spring-AOP-%E6%9D%82%E8%B0%88%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>IOC(Inversion of Control)</code> &amp;&amp; <code>AOP(Aspect-Oriented Programming)</code>是<code>Spring</code>的两大核心</p><p>而<code>AOP</code>又是基于<code>IOC</code>的</p><p><code>AOP</code>，面向切面编程，是<code>OOP</code>（面向对象编程）的拓展和延伸，是设计模式中<strong>代理模式</strong>的一种实现</p><p><code>OOP</code>通常只能对连续代码进行封装，而类似日志这样分散核心代码前后各处的非核心代码，却难以实现集中处理，是一大痛点</p><p>官方一点就是：它将业务逻辑的各个部分进行隔离，使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率</p><p>于是便有了<code>AOP</code></p><p><code>Spring</code>的<code>AOP</code>基于<code>AspectJ</code>，具体底层实现有两种：</p><ul><li><code>JDK</code>原生动态代理（有接口的情况）：需要被代理的目标类必须实现接口，因为这个技术要求<strong>代理对象和目标对象实现同样的接口</strong>（兄弟两个拜把子模式）</li><li><code>cglib</code>（无接口的情况）：通过<strong>继承被代理的目标类</strong>（认干爹模式）实现代理，所以不需要目标类实现接口，但是不能对<code>final</code>方法进行代理；其底层使用字节码处理框架<code>ASM</code>，来转换字节码并生成新的类（效率高于前者）</li></ul><h2 id="正片（叠底"><a href="#正片（叠底" class="headerlink" title="正片（叠底"></a>正片（叠底</h2><p>好的，上面都是官方废话</p><p>前情提要啊，前情提要</p><p>（略过切面的配置，你们都懂的对吧）</p><p>现在的主要问题是如何使用<code>AOP</code>生成的代理类呢</p><p>（我发现大部分都在讲怎么配置 没讲怎么用啊大哥）</p><h3 id="有接口的情况（JDK动态代理）"><a href="#有接口的情况（JDK动态代理）" class="headerlink" title="有接口的情况（JDK动态代理）"></a>有接口的情况（JDK动态代理）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-context.xml&quot;</span>);<br>    <span class="hljs-type">Calculator</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> ioc.getBean(Calculator.class); <br>    System.out.println(cal.div(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，现在假装：我们有一个接口（<code>Calculator</code>）和一个实现类（<code>CalculatorImpl</code>）</p><p>前面说了，<code>Spring</code>的<code>AOP</code>基于<code>IOC</code>，所以我们的目标类和代理类都是交给<code>IOC</code>管理的</p><p>并且，我们将不能再通过<code>IOC</code>容器获取原始目标类（被从<code>IOC</code>中删除，可能是给代理类让位）</p><p>好的，问题来了，我们要如何获取代理类呢？</p><p>首先，我们不知道代理类的类名，其次不知道其<code>bean</code>的<code>id</code>，how to get it</p><p><em>（插叙：其实通过<code>cal.getClass().getName()</code>可以获得类名，发现是动态生成的：<code>com.sun.proxy.$Proxy16</code>）</em></p><p>但是，前面说了，代理类和目标类共同实现同一个接口，而且<code>IOC</code>容器可以智能地根据接口返回实现类（前提是实现类唯一）</p><p>这可能就是<code>IOC</code>自动删除目标类<code>bean</code>的原因，这样我们就可以根据接口直接获取代理类了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calculator</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> ioc.getBean(Calculator.class); <br></code></pre></td></tr></table></figure><p>但是捏，问题来了，如果实现类不唯一怎么办</p><p>比如还有一个实现类：<code>CalculatorImpl2</code>也实现了<code>Calculator</code>接口</p><p>那么<code>IOC</code>容器中将有两个代理类（实现了同一接口<code>Calculator</code>）</p><p>这种情况下<code>ioc.getBean(Calculator.class)</code>就不知道返回哪一个实现类了，就会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">NoUniqueBeanDefinitionException<br></code></pre></td></tr></table></figure><p>那我们在这种情况下该如何获取<code>CalculatorImpl</code>的代理类呢（大部分资料都没说aaaaa 气shi我啦）</p><p>这种时候就需要回想一下<code>IOC</code>的知识了，在接口有多个实现类的情况下，我们如何获取指定实现类</p><p>通过重载函数<code>getBean(String var1, Class&lt;T&gt; var2)</code>是吧，第一个参数是<code>bean id</code>，第二个是接口类</p><p>那么此时，我们也可以通过这种方法标识实现类（毕竟直接通过<code>实现类.class</code>已经不行了对吧，deleted）</p><h4 id="id？"><a href="#id？" class="headerlink" title="id？"></a>id？</h4><p>那么问题又来了，<code>id</code>是啥，如果是通过<code>xml</code>配置的，<code>id</code>就是自己写的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;calImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mrbeanc.spring.aop.CalculatorImpl&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果是通过<code>@Component</code>注解控制的，那么默认<code>id</code>为类名的小驼峰，即<code>calculatorImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calculator</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> ioc.getBean(<span class="hljs-string">&quot;calculatorImpl&quot;</span>, Calculator.class);<br></code></pre></td></tr></table></figure><p>当然<code>@Component</code>也可以自定义<code>id</code>，like <code>@Component(&quot;calImpl&quot;)</code></p><h4 id="这个故事告诉我们知识需要回顾和串联"><a href="#这个故事告诉我们知识需要回顾和串联" class="headerlink" title="这个故事告诉我们知识需要回顾和串联"></a>这个故事告诉我们知识需要回顾和串联</h4><h3 id="无接口（cglib继承实现子类）"><a href="#无接口（cglib继承实现子类）" class="headerlink" title="无接口（cglib继承实现子类）"></a>无接口（cglib继承实现子类）</h3><p>这种情况下直接通过目标类即可获取代理类（子类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CalculatorImpl</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> ioc.getBean(<span class="hljs-string">&quot;calculatorImpl&quot;</span>);<br><span class="hljs-comment">//or</span><br><span class="hljs-type">CalculatorImpl</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> ioc.getBean(CalculatorImpl.class); <br><span class="hljs-comment">//maybe 我猜的hh</span><br></code></pre></td></tr></table></figure><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://juejin.cn/post/7019868958140399629">Spring——AOP实现方式 - 掘金</a></p><p><a href="https://blog.csdn.net/glpghz/article/details/107362344">字节码增强和spring AOP 原理_长不大的大灰狼的博客-CSDN博客_字节码增强实现aop</a></p><p><a href="https://www.jianshu.com/p/ba6610930b01">理解Spring中的getBean() - 简书</a></p><p><a href="https://blog.csdn.net/Sampson_S/article/details/106908797">【Spring框架】Spring的AOP使用_Sampson_S的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>AOP</tag>
      
      <tag>AspectJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论 Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;) 是如何寻址的</title>
    <link href="/2022/09/09/%E8%AE%BA-Resources-getResourceAsStream-mybatis-config-xml-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84/"/>
    <url>/2022/09/09/%E8%AE%BA-Resources-getResourceAsStream-mybatis-config-xml-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BB%E5%9D%80%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="单刀直入"><a href="#单刀直入" class="headerlink" title="单刀直入"></a>单刀直入</h2><p>大家在学<code>MyBatis</code>的时候肯定用到了<code>Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;)</code>这行代码<br>（in <code>SqlSessionUtil</code>）</p><p>但是有没有想过，为什么这个参数只需要写文件名就能定位呢</p><ul><li>有人可能说了：这相对路径，那肯定是在同一个文件夹下嘛</li></ul><p>非也，非也</p><p><img src="/img/image-20220909161841514.png" alt="Figure 1"></p><p>诸君请看，他俩相隔十万八千里</p><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>首先，第一个比较莽撞的猜想，难道是根据<code>resources</code>的文件夹标记定位根目录的吗</p><p>非也，非也</p><p>去掉标记仍能运行</p><h2 id="真相（Maybe）"><a href="#真相（Maybe）" class="headerlink" title="真相（Maybe）"></a>真相（Maybe）</h2><p>诸君请看</p><p><img src="/img/image-20220909162406745.png" alt="Figure 2"></p><p>观察编译后的<code>target</code>文件夹</p><p><code>java</code>文件夹和<code>resources</code>文件夹 <strong>合并</strong>了</p><p>统一归并在<code>classes</code>文件夹下</p><p>诶，好像有那么点接近真相了，但又没有完全接近…</p><ul><li>有华生可能发现盲点了：你这<code>SqlSessionUtil</code>类在<code>utils</code>文件夹下，和<code>mybatis-config.xml</code>也不同级啊，怎么能相对引用</li></ul><p>咳咳，这个呢，主要是</p><p>上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream <span class="hljs-title function_">getResourceAsStream</span><span class="hljs-params">(String resource, ClassLoader[] classLoader)</span> &#123;<br>        ClassLoader[] var3 = classLoader;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> classLoader.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var5 &lt; var4; ++var5) &#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> var3[var5];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != cl) &#123;<br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> cl.getResourceAsStream(resource);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == returnValue) &#123;<br>                    returnValue = cl.getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + resource);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != returnValue) &#123;<br>                    <span class="hljs-keyword">return</span> returnValue;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是<code>Resources.getResourceAsStream</code>的深层实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == returnValue) &#123;<br>returnValue = cl.getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + resource);<br>&#125;<br></code></pre></td></tr></table></figure><p>观察这几行可以发现，在获取文件失败后，会自动加上”&#x2F;“再进行尝试（非常滴人性化呀）</p><p>大家都知道，加上”&#x2F;“之后，就意味着从根目录进行寻址，也就找到了<code>mybatis-config.xml</code>（我猜根目录是classes）</p><p>咳咳，就是这样啦（maybe）</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>其实这个知识点还可用于<code>mybatis-config.xml</code>的<code>mappers</code>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一般来说，每一个映射文件都要这样写入核心配置</p><p>但是，这未免太过麻烦，因为每一个映射就要写一行</p><p>所以经常写为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.mrbeanc.mybatis.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就可以把<code>mapper</code>下的所有映射文件自动写入啦</p><p>但是这么写是有两个要求的</p><ol><li>mapper接口和映射文件所在包一致</li><li>mapper接口和映射文件的文件名一致</li></ol><p>那么有人就要问了，诶，为什么包要一致啊</p><p>你这一个在java文件夹下，一个在resources文件夹下，就算内部包一致，父文件夹也不一致呀</p><p><img src="/img/image-20220909163834063.png" alt="Figure 3"></p><p>但是结合上面的知识点，可以发现，编译后他俩就会合并</p><p><img src="/img/image-20220909163915194.png" alt="Figure 4"></p><p>这样一来，他俩就在一个文件夹里了，寻址非常方便</p><h3 id="Peace"><a href="#Peace" class="headerlink" title="Peace"></a>Peace</h3><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.bilibili.com/video/BV1Ya411S7aT?p=17&vd_source=72f34a53a3e27b95117029804465fa3f">017-MyBatis核心配置文件之mappers_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>idea</tag>
      
      <tag>MyBatis</tag>
      
      <tag>Resources</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何迁移Hexo Blog至 new PC</title>
    <link href="/2022/09/09/%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BBHexo-Blog%E8%87%B3-new-PC/"/>
    <url>/2022/09/09/%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BBHexo-Blog%E8%87%B3-new-PC/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>话说回来，我已经五个月没有更新<code>Blog</code>了，真是懐かしいなあ</p><p>いろんな原因だね</p><p>嘛，要说忙，其实也不是</p><p>主要是换了新笔记本电脑，就要对<code>Hexo</code>进行迁移</p><p>但是捏，不用我多说，大家也不是什么萌新，应该知道这不是<code>Copy</code>一个文件夹那么简单的事</p><p>甚至比从零开始要更加复杂一点，因为需要维持原有的<code>Theme</code>、<code>配置文件</code>、<code>.md文件</code>和<code>imgs</code>，以及与<code>gitee</code>连通的部分</p><p>而且安装<code>Hexo</code>本身就需要<code>NodeJs</code>的前置支持</p><p>主要是我已经忘了当时是如何配置的，aaa，想想就头大</p><p>便一直拖到了现在….（惭愧惭愧）</p><h2 id="正片（叠底"><a href="#正片（叠底" class="headerlink" title="正片（叠底"></a>正片（叠底</h2><p>然后嘛，最近在看<code>JavaWeb</code>，的确需要记录一点一些东东，没办法，需求才是第一驱动力啊</p><p>『リンクスタート！』</p><p>怎么迁移呢？</p><p>步骤这么多，先从骨架开始</p><ol><li>安装<a href="www.nodejs.org"><code>NodeJs</code></a></li><li>安装<code>hexo</code>并执行<code>hexo init</code>（啊，我们得到了一个纯洁无瑕的hexo目录）</li><li>然后怎么办呢…</li></ol><p>这就很尴尬了</p><p>一开始 我把所有的文件统统复制到了新目录里，虽然可以运行 但是显然<code>hexo g</code>重新生成会失败</p><p>咳咳，怎么可能这么简单嘛</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><ul><li><p>其实最简单的迁移就是拷贝<code>source/_posts</code>下的所有<code>.md</code>文件，这是最简单的内容迁移</p></li><li><p>其次是<code>theme</code>主题迁移，使用<code>npm install --save hexo-theme-fluid</code>安装主题（根据自己需求更改主题）</p></li><li><p>并且拷贝原PC上的<code>.yml</code>文件，即可完成主题迁移</p></li></ul><p>哦 别忘了原本的<code>img</code>文件夹（<code>node_modules\主题文件夹\source\img</code>）</p><p>ok，现在已经完成<strong>本地迁移</strong>了</p><p>接下来还需要配置<code>gitee</code>的上传，由于gitee的配置早已完成（last PC），<code>.yml</code>配置文件也写好了</p><ul><li>就差一个<code>npm</code>依赖（<code>npm install hexo-deployer-git --save</code>）</li></ul><p>大功告成</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>诶 这个主题怎么稍稍变了一点点</p><p>emmm 应该是更新了吧 en 应该是这样 大概 たぶん</p><p>Peace</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.337.search-card.all.click&vd_source=72f34a53a3e27b95117029804465fa3f">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>迁移</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于C++模板与非模板函数重载</title>
    <link href="/2022/04/26/%E5%85%B3%E4%BA%8EC-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E9%9D%9E%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/04/26/%E5%85%B3%E4%BA%8EC-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E9%9D%9E%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>假如我们需要为<code>QList&lt;T&gt;</code>的某个类型编写特殊的<code>operator==</code></p><p>那就需要考虑是编写普通函数还是模板特化了</p><h2 id="模板函数与非模板函数的重载决议步骤"><a href="#模板函数与非模板函数的重载决议步骤" class="headerlink" title="模板函数与非模板函数的重载决议步骤"></a>模板函数与非模板函数的重载决议步骤</h2><h3 id="1-为这个函数名建立候选函数集合"><a href="#1-为这个函数名建立候选函数集合" class="headerlink" title="1.为这个函数名建立候选函数集合"></a>1.为这个函数名建立候选函数集合</h3><ul><li>与被调用函数名字相同的任意普通函数</li><li>任意函数模板实例化，在其中，模板实参推断发现了与调用中所用函数实参相匹配的模板实参</li></ul><h3 id="2-确定哪些普通函数是可行的（如果有可行函数的话）。候选集合中的每个模板实例都可行的，因为模板实参推断保证函数可以被调用"><a href="#2-确定哪些普通函数是可行的（如果有可行函数的话）。候选集合中的每个模板实例都可行的，因为模板实参推断保证函数可以被调用" class="headerlink" title="2.确定哪些普通函数是可行的（如果有可行函数的话）。候选集合中的每个模板实例都可行的，因为模板实参推断保证函数可以被调用"></a>2.确定哪些普通函数是可行的（如果有可行函数的话）。候选集合中的每个模板实例都可行的，因为模板实参推断保证函数可以被调用</h3><h3 id="3-如果需要转换来进行调用，根据转换的种类排列可靠函数，记住，调用模板函数实例所允许的转换是有限的"><a href="#3-如果需要转换来进行调用，根据转换的种类排列可靠函数，记住，调用模板函数实例所允许的转换是有限的" class="headerlink" title="3. 如果需要转换来进行调用，根据转换的种类排列可靠函数，记住，调用模板函数实例所允许的转换是有限的"></a>3. 如果需要转换来进行调用，根据转换的种类排列可靠函数，记住，调用模板函数实例所允许的转换是有限的</h3><ul><li>如果只有一个函数可选，就调用这个函数</li><li>如果调用有二义性，从可行函数集合中去掉所有函数模板实例</li></ul><h3 id="4-重新排列去掉函数模板实例的可行函数"><a href="#4-重新排列去掉函数模板实例的可行函数" class="headerlink" title="4.重新排列去掉函数模板实例的可行函数"></a>4.重新排列去掉函数模板实例的可行函数</h3><ul><li>如果只有一个函数可选，就调用这个函数</li><li>否则，调用有二义性</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> MyList&lt;T&gt;&amp; l) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a == l.a;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> MyList&lt;T&gt;&amp; l) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a != l.a;<br>    &#125;<br>    T a;<br>&#125;;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> MyList&lt;<span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> MyList&lt;<span class="hljs-type">int</span>&gt;&amp; rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> lhs.a == rhs.a;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> MyList&lt;<span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> MyList&lt;<span class="hljs-type">int</span>&gt;&amp; rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    MyList&lt;<span class="hljs-type">int</span>&gt; list, list2;<br>    list == list2;<br>    list != list2;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上图 调用<code>!=</code>运算符会报错</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">E:\Qt5.14.2\Projects\HelloWorld\hellodialog.cpp:44: <span class="hljs-keyword">error</span>: ambiguous overload <span class="hljs-keyword">for</span> &#x27;operator==&#x27; (operand types are &#x27;<span class="hljs-keyword">const</span> MyList&lt;<span class="hljs-keyword">int</span>&gt;&#x27; and &#x27;<span class="hljs-keyword">const</span> MyList&lt;<span class="hljs-keyword">int</span>&gt;&#x27;)<br>     <span class="hljs-keyword">return</span> !(lhs == rhs);<br>              ~~~~^~~~~~<br></code></pre></td></tr></table></figure><p>也就是类模板的成员函数 和 普通函数产生二义性（都是完美匹配）</p><p>但是你可能说了：函数模板优先级不应该低于普通函数吗，应该调用普通函数才对呀</p><p>我也这么认为</p><p>但是有没有可能，成员函数<code>operator==</code>不是模板函数呢？</p><p>因为唯一的模板适用于指示模板类的类型的</p><p>一旦类的类型确定，<code>operator==</code>的参数也就确定了</p><blockquote><p>在类模板作用域中，可以直接使用模板名而不提供实参 —— 《C++ Primer》 P589</p></blockquote><p>即，以下两种皆可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> MyList&lt;T&gt;&amp; l) <span class="hljs-type">const</span>;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> MyList&amp; l) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><p>这就是普通函数</p><p><code>operator==</code>根本不是模板函数</p><p>导致模板函数匹配规则不适用</p><p>（以上我猜的）</p><p><strong>第二点</strong>：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">E:\Qt5<span class="hljs-number">.14</span><span class="hljs-number">.2</span>\Projects\HelloWorld\hellodialog.cpp:<span class="hljs-number">64</span>: warning: ISO C++ says <span class="hljs-keyword">that</span> these are ambiguous, even though <span class="hljs-keyword">the</span> worst conversion <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> <span class="hljs-keyword">is</span> better than <span class="hljs-keyword">the</span> worst conversion <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span>:<br>     <span class="hljs-built_in">list</span> == list2;<br>             ^~~~~<br></code></pre></td></tr></table></figure><p>这个是<code>warning</code>，如果按以上分析，此时虽然要经过<code>const</code>转换，这应该也得是二义性错误，为什么此时普通函数更好，不解</p><h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><p>想要不冲突，最好不要产生模板函数和普通函数的重载</p><p>最好进行模板特化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-type">bool</span> MyList&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> MyList&lt;<span class="hljs-type">int</span>&gt;&amp; l) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> l.a == a;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-type">bool</span> MyList&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> MyList&lt;<span class="hljs-type">int</span>&gt;&amp; l) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> !(l == *<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PS</strong>：注意模板特化要写在调用之前，否则会导致产生新模板实例</p><h2 id="寄"><a href="#寄" class="headerlink" title="寄"></a>寄</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/rickyk/p/3941176.html">C++普通函数与模板函数以及特化函数重载的优先级问题 - Ricky.K - 博客园</a></p><p><a href="https://www.cnblogs.com/liyuan989/p/4138378.html">聊聊C++模板函数与非模板函数的重载 - origins - 博客园</a></p><p><a href="https://blog.csdn.net/wangwenjing90/article/details/8530498">函数模板与同名的非模板函数重载的时候，两者调用顺序_九月丫头的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/brook0344/article/details/53444786">类模板函数特化（专用化）specialization of …… after instantiation_布鲁克零三四四的博客</a></p><p><a href="https://harttle.land/2015/10/03/cpp-template.html">C++模板的偏特化与全特化 | Harttle Land</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SwitchToThisWindow 点石成金？</title>
    <link href="/2022/04/11/SwitchToThisWindow-%E7%AA%97%E7%8B%AC%E5%88%86%E5%AD%90%EF%BC%9F/"/>
    <url>/2022/04/11/SwitchToThisWindow-%E7%AA%97%E7%8B%AC%E5%88%86%E5%AD%90%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>加更一期</p><p>别前情提要了，熄灯了大哥</p><h2 id="正片"><a href="#正片" class="headerlink" title="正片"></a>正片</h2><p>偶然发现</p><blockquote><p><code>SwitchToThisWindow</code> 作用于<code>Qt</code>子控件（如<code>QLineEdit</code>）导致原本的窗口整体分裂为众多子窗体</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">SwitchToThisWindow</span>(<span class="hljs-built_in">HWND</span>(ui-&gt;lineEdit-&gt;<span class="hljs-built_in">winId</span>()), <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>众所周知，<code>Spy++</code>探测<code>Qt</code>窗口是只能扫到一整个窗口的</p><p>但是如此操作之后，就能探测到子控件（已经上升为子窗体 拥有<code>HWND</code>）</p><p><img src="/img/image-20220411225430212.png" alt="分裂"></p><p>后果是，上层子窗体会拦截<code>WM_NCHITTEST</code>，导致下层主窗体无法接收，导致自定义标题栏无法响应鼠标移动（窗体无法移动）</p><p>我只能说很神奇，这绝对是一个非常难发现的特性（并没有发现任何记载）</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>还有更神奇的</p><p>对<code>QListWidget</code>的自定义<code>item</code>使用后发现</p><ul><li>第一行的<code>item</code>是一个整体，第二行开始，每个控件都分裂为窗口</li><li>新增的<code>item</code>在初始化时会表现为首行<code>item</code>样貌，然后瞬间恢复正常</li></ul><p>这就</p><p><img src="/img/image-20220411230439944.png" alt="大受震撼"></p><p>交给后人了</p><p>睡了 peace</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows Hook 技术浅析</title>
    <link href="/2022/04/07/Windows-Hook-%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/"/>
    <url>/2022/04/07/Windows-Hook-%E6%8A%80%E6%9C%AF%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，出于安全性考虑，操作系统的进程间是相互隔离的，窗口也不例外</p><p><code>Windows</code>的通信基于消息机制，操作系统会将各种信息通过消息(<code>Message</code>)的形式传递给各个线程（消息队列是以线程为单位的）</p><p>这也意味着一个进程<strong>只能</strong>获取<code>Windows</code>发送给<strong>自身</strong>窗体的消息，如：</p><ul><li>键盘按键信息</li><li>鼠标滚轮、双击信息</li><li>窗口最小化&#x2F;最大化</li><li>…</li></ul><p><em>“两耳不闻窗外事，一心只读圣贤书”</em>了属于是</p><p>他想闻也闻不到啊主要是，操作系统给他掐了</p><p><code>Windows</code>：喂，别东张西望</p><h2 id="外面的世界"><a href="#外面的世界" class="headerlink" title="外面的世界"></a>外面的世界</h2><p>那莫，我要是求知欲特别强，就是想知道别的进程&#x2F;窗口发生了什么，怎么办呢？</p><p>比如：（监听其他窗口的密码输入）</p><p>哦，不是不是，误会了，我的老伙计</p><p>我是说：帮助一些行动不便的程序，处理一些消息~</p><p>咳咳</p><p>那就需要用到<code>Windows Hook</code>技术了</p><h2 id="Windows-Hook"><a href="#Windows-Hook" class="headerlink" title="Windows Hook"></a>Windows Hook</h2><p>什么是<code>Hook</code></p><p><code>Hook</code>，直译：钩子，挂钩</p><p>非常形象，其作用就是在<code>Windows</code>将消息分发给指定窗口过程中捕获（钩住）消息，从而获得对消息的控制权，以便处理或修改，甚至可以拦截（不继续传递）</p><p>比如：在浏览器输入文字，按键消息就会由<code>Windows</code>发布到浏览器窗口，在这个过程中，可以用键盘钩子捕获消息，从而得知用户的输入</p><h2 id="Hook类型（这一段可以跳过，查阅用）"><a href="#Hook类型（这一段可以跳过，查阅用）" class="headerlink" title="Hook类型（这一段可以跳过，查阅用）"></a>Hook类型（这一段可以跳过，查阅用）</h2><p>有如下的几种常用类型：</p><ul><li>键盘钩子和低级键盘钩子可以监视各种键盘消息</li><li>鼠标钩子和低级鼠标钩子可以监视各种鼠标消息</li><li>外壳钩子可以监视各种<code>Shell</code>事件消息。比如启动和关闭应用程序</li><li>日志钩子可以记录从系统消息队列中取出的各种事件消息</li><li>窗口过程钩子监视所有从系统消息队列发往目标窗口的消息</li></ul><p>详细来说：</p><h3 id="1-WH-CALLWNDPROC-和-WH-CALLWNDPROCRET"><a href="#1-WH-CALLWNDPROC-和-WH-CALLWNDPROCRET" class="headerlink" title="1.WH_CALLWNDPROC 和 WH_CALLWNDPROCRET"></a>1.WH_CALLWNDPROC 和 WH_CALLWNDPROCRET</h3><p>监视发送到窗口过程的消息。系统在消息发送到接收窗口过程之前调用<code>WH_CALLWNDPROC Hook</code>子程，并且在窗口过程处理完消息之后调用<code>WH_CALLWNDPROCRET Hook</code>子程</p><h3 id="2-WH-CBT"><a href="#2-WH-CBT" class="headerlink" title="2.WH_CBT"></a>2.WH_CBT</h3><p>在以下事件之前，系统都会调用<code>WH_CBT Hook</code>子程，这些事件包括：</p><ul><li>激活，建立，销毁，最小化，最大化，移动，改变尺寸等窗口事件</li><li>完成系统指令</li><li>来自系统消息队列中的移动鼠标，键盘事件</li><li>设置输入焦点事件</li><li>同步系统消息队列事件</li></ul><p><code>Hook</code>子程的返回值确定系统是否允许或者防止这些操作中的一个</p><h3 id="3-WH-DEBUG"><a href="#3-WH-DEBUG" class="headerlink" title="3.WH_DEBUG"></a>3.WH_DEBUG</h3><p>在系统调用系统中与其他<code>Hook</code>关联的子程之前，系统会调用<code>WH_DEBUG Hook</code>子程。你可以使用这个<code>Hook</code>来决定是否允许系统调用与其他<code>Hook</code>关联的子程</p><h3 id="4-WH-FOREGROUNDIDLE"><a href="#4-WH-FOREGROUNDIDLE" class="headerlink" title="4.WH_FOREGROUNDIDLE"></a>4.WH_FOREGROUNDIDLE</h3><p>当应用程序的前台线程处于空闲状态时，可以使用<code>WH_FOREGROUNDIDLE Hook</code>执行低优先级的任务。当应用程序的前台线程大概要变成空闲状态时，系统就会调用<code>WH_FOREGROUNDIDLE Hook</code>子程</p><h3 id="5-WH-GETMESSAGE"><a href="#5-WH-GETMESSAGE" class="headerlink" title="5.WH_GETMESSAGE"></a>5.WH_GETMESSAGE</h3><p>应用程序使用<code>WH_GETMESSAGE Hook</code>来监视从<code>GetMessage</code> or <code>PeekMessage</code>函数返回的消息。你可以使用<code>WH_GETMESSAGE Hook</code>去监视鼠标和键盘输入，以及其他发送到消息队列中的消息</p><h3 id="6-WH-JOURNALPLAYBACK"><a href="#6-WH-JOURNALPLAYBACK" class="headerlink" title="6.WH_JOURNALPLAYBACK"></a>6.WH_JOURNALPLAYBACK</h3><p><code>WH_JOURNALPLAYBACK Hook</code>使应用程序可以插入消息到系统消息队列。可以使用这个<code>Hook</code>回放通过使用<code>WH_JOURNALRECORD Hook</code>记录下来的连续的鼠标和键盘事件。只要<code>WH_JOURNALPLAYBACK Hook</code>已经安装，正常的鼠标和键盘事件就是无效的。<code>WH_JOURNALPLAYBACK Hook</code>是全局<code>Hook</code>，不会注入<code>dll</code>。<code>WH_JOURNALPLAYBACK Hook</code>返回超时值，这个值告诉系统在处理来自回放<code>Hook</code>当前消息之前需要等待多长时间，这就使<code>Hook</code>可以控制实时事件的回放。</p><h3 id="7-WH-JOURNALRECORD"><a href="#7-WH-JOURNALRECORD" class="headerlink" title="7.WH_JOURNALRECORD"></a>7.WH_JOURNALRECORD</h3><p><code>WH_JOURNALRECORD Hook</code>用来监视和记录输入事件。可以使用这个<code>Hook</code>记录连续的鼠标和键盘事件，然后通过使用<code>WH_JOURNALPLAYBACK Hook</code>来回放。<code>WH_JOURNALRECORD Hook</code>是全局<code>Hook</code>，不会注入<code>dll</code></p><h3 id="8-WH-KEYBOARD"><a href="#8-WH-KEYBOARD" class="headerlink" title="8.WH_KEYBOARD"></a>8.WH_KEYBOARD</h3><p>在应用程序中，<code>WH_KEYBOARD Hook</code>用来监视<code>WM_KEYDOWN</code> and <code>WM_KEYUP</code>消息，这些消息通过<code>GetMessage</code> or <code>PeekMessage</code> 函数返回。可以使用这个<code>Hook</code>来监视输入到消息队列中的键盘消息</p><h3 id="9-WH-KEYBOARD-LL"><a href="#9-WH-KEYBOARD-LL" class="headerlink" title="9.WH_KEYBOARD_LL"></a>9.WH_KEYBOARD_LL</h3><p>监视即将输入到线程消息队列中的键盘消息</p><h3 id="10-WH-MOUSE"><a href="#10-WH-MOUSE" class="headerlink" title="10.WH_MOUSE"></a>10.WH_MOUSE</h3><p>监视从<code>GetMessage</code> 或者 <code>PeekMessage</code> 函数返回的鼠标消息。使用这个<code>Hook</code>监视输入到消息队列中的鼠标消息</p><h3 id="11-WH-MOUSE-LL"><a href="#11-WH-MOUSE-LL" class="headerlink" title="11.WH_MOUSE_LL"></a>11.WH_MOUSE_LL</h3><p>监视即将输入到线程消息队列中的鼠标消息</p><h3 id="12-WH-MSGFILTER-和-WH-SYSMSGFILTER"><a href="#12-WH-MSGFILTER-和-WH-SYSMSGFILTER" class="headerlink" title="12.WH_MSGFILTER 和 WH_SYSMSGFILTER"></a>12.WH_MSGFILTER 和 WH_SYSMSGFILTER</h3><p>可以监视菜单，滚动条，消息框，对话框消息并且发现用户使用<code>ALT+TAB</code> or <code>ALT+ESC</code> 组合键切换窗口</p><h3 id="13-WH-SHELL"><a href="#13-WH-SHELL" class="headerlink" title="13.WH_SHELL"></a>13.WH_SHELL</h3><p>当外壳应用程序是激活的并且当顶层窗口建立或者销毁时，系统调用<code>WH_SHELL Hook</code>子程</p><h2 id="不管了，先开始"><a href="#不管了，先开始" class="headerlink" title="不管了，先开始"></a>不管了，先开始</h2><p>上面一大坨看得头痛是吧，那就先别看了，不如上手试试</p><p>其实大多数人入手<code>Hook</code>的第一个例子就是鼠标和键盘钩子，比如：获取全局键盘输入</p><p>那么，问题来了，哪一种类型的<code>Hook</code>可以实现这种需求呢？</p><p>小学英语也可以筛选出两个：<code>WH_KEYBOARD</code> &amp;&amp; <code>WH_KEYBOARD_LL</code></p><p>Q：那这俩怎么选嘛，都是<code>KeyBoard</code>，诶，那个<code>LL</code>后缀是啥呀</p><p>A：Low Level，代表低级键盘钩子</p><p>Q：有啥区别呢</p><p>A：<code>WH_KEYBOARD_LL</code>会在消息即将发布到线程消息队列时调用，而<code>WH_KEYBOARD</code>会在消息被线程处理前调用，也就是说，<code>WH_KEYBOARD_LL</code>调用时机更早</p><p>而且使用起来更简单，为啥呢？因为<code>WH_KEYBOARD_LL</code>调用时，消息还未发布到具体线程，所以不用编写独立<code>dll</code>用以注入。坏处是，正由于消息还未发布到具体线程，所以不知道消息的接收者是谁。</p><p>而<code>WH_KEYBOARD</code>是在线程获取消息时调用，所以上下文已经切换至具体线程，想要执行<code>Hook</code>函数就必须编写独立<code>dll</code>并将<code>dll</code>注入指定线程（<code>Windows</code>执行注入）才能执行（同一片地址空间），这样就会削削有点麻烦，但可以实现监控指定线程</p><p>那么什么<code>Hook</code>可以不用<code>dll</code>呢，貌似<code>Global Only</code>的可以不要：</p><p><img src="/img/image-20220407142524115.png" alt="Hook Scope"></p><h2 id="写了再说"><a href="#写了再说" class="headerlink" title="写了再说"></a>写了再说</h2><p>管不了那么多了，直接莽</p><p>编写钩子程序的步骤分为三步：定义钩子函数、安装钩子和卸载钩子</p><h3 id="1-定义钩子函数"><a href="#1-定义钩子函数" class="headerlink" title="1.定义钩子函数"></a>1.定义钩子函数</h3><p>钩子函数是一种特殊的回调函数，钩子监视的特定事件发生后，系统会调用钩子函数进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">HookProc</span><span class="hljs-params">(<span class="hljs-type">int</span> nCode ,WPARAM wParam,LPARAM lParam)</span></span><br></code></pre></td></tr></table></figure><p>参数<code>wParam </code>和 <code>lParam</code>包含所钩消息的信息，比如鼠标位置、状态，键盘按键等，<code>nCode</code>包含有关消息本身的信息，比如是否从消息队列中移出</p><p>在钩子函数中实现了具体功能后，还需要返回值</p><p>推荐用<code>CallNextHookEx</code>函数把消息传递给后一个对象（下一个钩子函数或特定线程）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">LRESULT <span class="hljs-title">CallNextHookEx</span><span class="hljs-params">( HHOOK hhk, <span class="hljs-type">int</span> nCode, WPARAM wParam, LPARAM lParam )</span></span><br></code></pre></td></tr></table></figure><p>当然也可以直接<code>return true</code>不继续传递，即拦截消息</p><p>（这样非常霸道，可以用来屏蔽键盘）</p><p>注：在钩子函数中，不要做耗时操作，否则会阻塞系统，导致性能下降</p><h3 id="2-安装钩子"><a href="#2-安装钩子" class="headerlink" title="2.安装钩子"></a>2.安装钩子</h3><p>调用函数<code>SetWindowsHookEx</code>安装钩子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">HHOOK <span class="hljs-title">SetWindowsHookEx</span><span class="hljs-params">( <span class="hljs-type">int</span> idHook,HOOKPROC lpfn, INSTANCE hMod,DWORD dwThreadId )</span></span><br></code></pre></td></tr></table></figure><ul><li><code>idHook</code>表示钩子类型，如：<code>WH_KEYBOARD</code></li><li><code>lpfn</code>是钩子函数的地址</li><li><code>hMod</code>是钩子函数所在的实例的句柄</li><li><code>dwThreadId</code>指定钩子所监视的线程的ID，若为<code>NULL</code>，则监视所有线程（全局钩子）</li><li>返回值为钩子句柄（唯一标识符）</li></ul><p>注：最近安装的钩子放在<code>Hook</code>链的开始，而最早安装的钩子放在最后，也就是后加入的先获得控制权</p><p>注：如果钩子过程超时，系统将消息传递给下一个钩子。但是，在 <code>Windows 7</code> 及更高版本上，该挂钩会在不被调用的情况下被静默删除。应用程序无法知道挂钩是否被移除</p><p><strong>Windows 10 版本 1709 及更高版本</strong>系统允许的最大超时值为 1000 毫秒（1 秒）。<strong>如果LowLevelHooksTimeout</strong>值设置为大于 1000 的值，系统将默认使用 1000 毫秒超时。</p><h3 id="3-卸载钩子"><a href="#3-卸载钩子" class="headerlink" title="3.卸载钩子"></a>3.卸载钩子</h3><p>钩子特别是系统钩子会消耗消息处理时间，降低系统性能。只有在必要的时候才安装钩子，在使用完毕后要及时卸载:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">BOOL <span class="hljs-title">UnhookWindowsHookEx</span><span class="hljs-params">(HHOOK hhk)</span></span><br></code></pre></td></tr></table></figure><p>不过，实际上呢，由于<code>Windows</code>系统的鲁棒性，在程序退出时，系统会隐式释放所有句柄，所以其实不用太担心</p><p>实验表明，如果钩子函数写在<code>dll</code>中，程序直接退出，系统会释放<code>Hook</code>句柄，并卸载在其他线程注入的<code>dll</code>（可能有延迟）</p><p>注：调用<code>SetWindowsHookEx</code>的进程获得句柄（载入<code>dll</code>后调用也是（同一进程空间））</p><h2 id="实操：低级键盘钩子（无dll）"><a href="#实操：低级键盘钩子（无dll）" class="headerlink" title="实操：低级键盘钩子（无dll）"></a>实操：低级键盘钩子（无dll）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setKeyboardHook</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    h_key = <span class="hljs-built_in">SetWindowsHookEx</span>(WH_KEYBOARD_LL, keyboardProc, <span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unHook</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (h_key != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">UnhookWindowsHookEx</span>(h_key);<br>        h_key = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function">LRESULT <span class="hljs-title">keyboardProc</span><span class="hljs-params">(<span class="hljs-type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//关于wParam 和 lParam的定义 不同Hook类型都不同，需查阅微软官方文档</span><br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;keyBoard Hook:&quot;</span> &lt;&lt; ((KBDLLHOOKSTRUCT*)lParam)-&gt;vkCode;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是非常简单，这样就实现了屏蔽键盘的功能</p><p>但是，这也太<code>low</code>了吧，还不能监控指定线程，换碟！</p><h2 id="实操2：鼠标钩子（dll）"><a href="#实操2：鼠标钩子（dll）" class="headerlink" title="实操2：鼠标钩子（dll）"></a>实操2：鼠标钩子（dll）</h2><p>一般与特定线程&#x2F;窗口相关的钩子都需要编写独立<code>dll</code></p><p>那么怎么写呢？</p><p>一般用<code>Visual Studio</code>来编写（新建<code>dll</code>工程就有模板）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;.SHARE&quot;</span>)<span class="hljs-comment">//共享数据段</span></span><br>HWND hWndServer = <span class="hljs-literal">NULL</span>;<br>HWND hWndTarget = <span class="hljs-literal">NULL</span>;<br>HHOOK hMouse = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.SHARE,rws&quot;</span>)</span><br><br>HINSTANCE hInstance;<br>UINT UWM_MOUSEHOOK;<br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call) &#123;<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<span class="hljs-comment">//首次载入目标进程</span><br>            hInstance = hModule;<br>            UWM_MOUSEHOOK = <span class="hljs-built_in">RegisterWindowMessage</span>(<span class="hljs-string">L&quot;Chrome_WH_MOUSE&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>        <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>        <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">MouseProc</span><span class="hljs-params">(<span class="hljs-type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nCode == HC_ACTION &amp;&amp; hWndServer) &#123;<br>        MOUSEHOOKSTRUCT* data = (MOUSEHOOKSTRUCT*)lParam;<br>        ::<span class="hljs-built_in">PostMessageA</span>(hWndServer, UWM_MOUSEHOOK, wParam, (LPARAM)data-&gt;hwnd);<span class="hljs-comment">//PostMessage不能发送指针</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">CallNextHookEx</span>(hMouse, nCode, wParam, lParam);<br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">setMouseHook</span><span class="hljs-params">(HWND hWnd, HWND target, DWORD* errorCode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (hWndServer) &#123;<br>        *errorCode = <span class="hljs-number">11451444</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    hMouse = <span class="hljs-built_in">SetWindowsHookEx</span>(WH_MOUSE, (HOOKPROC)MouseProc, hInstance, <span class="hljs-built_in">GetWindowThreadProcessId</span>(hWndTarget = target, <span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">if</span> (hMouse) &#123;<br>        hWndServer = hWnd;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    *errorCode = <span class="hljs-built_in">GetLastError</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport)<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">clearHook</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>hWndServer = <span class="hljs-literal">NULL</span>;<br>hMouse = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">UnhookWindowsHookEx</span>(hMouse);<span class="hljs-comment">//若hook已被自动卸载 也会返回false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;.SHARE&quot;</span>)<span class="hljs-comment">//共享数据段 名字可以随便去 但要和最后一句对应</span></span><br>HWND hWndServer = <span class="hljs-literal">NULL</span>;<br>HWND hWndTarget = <span class="hljs-literal">NULL</span>;<br>HHOOK hMouse = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.SHARE,rws&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>这段用于定义共享数据段</p><p>为什么要共享呢？因为<code>dll</code>注入在不同的线程中，数据是不共享的，那可坏了，<code>Hook</code>句柄和服务端窗口句柄都读不到了</p><p>为了共享就需要用到编译器指令<code>#pragma data_seg</code></p><p>同时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport)<br></code></pre></td></tr></table></figure><p>这句话用于声明<code>dll</code>中要导出的函数（以C风格 为了兼容性），否则外部不能访问</p><p>处理函数在注入到其他线程的<code>dll</code>中，那么天高皇帝远，我们怎么才能获取到消息呢？</p><p>这就要让注入的<code>dll</code>充当内鬼了，将消息通过<code>PostMessage</code>传递出来</p><p>为啥是<code>PostMessage</code>而不是<code>SendMessage</code>呢？</p><p>因为前面说了，钩子函数要尽量高效，不能阻塞，而<code>SendMessage</code>是阻塞函数，显然不行</p><p>那么问题又来了，由于<code>PostMessage</code>异步执行，所以不能传递指针（所指向的对象早就销毁了）</p><p>而<code>lParam</code>通常是一个指向结构体的指针</p><p>那咋办呢？</p><p>要么用<code>VirtualAlloc</code>在目标进程开空间，然后复制过去，要么，最多只能传递<code>sizeof(LPARAM)</code>，64bits 8字节的数据</p><p>那发消息总得有暗号吧</p><p>可以使用<code>RegisterWindowMessage</code>定义用户消息，接收端就可以识别了</p><h3 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h3><p>Okay，<code>dll</code>写完了，总得有人用吧，我们以<code>Qt</code>为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(*HookFunc)</span><span class="hljs-params">(HWND, HWND, DWORD*)</span></span>;<span class="hljs-comment">//声明函数结构</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">bool</span> <span class="hljs-params">(*UnHookFunc)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">QLibrary <span class="hljs-title">lib</span><span class="hljs-params">(<span class="hljs-string">&quot;mouseHook.dll&quot;</span>)</span></span>;<br>HookFunc setMouseHook = (HookFunc)lib.<span class="hljs-built_in">resolve</span>(<span class="hljs-string">&quot;setMouseHook&quot;</span>);<span class="hljs-comment">//根据函数名定位</span><br>UnHookFunc clearHook = (UnHookFunc)lib.<span class="hljs-built_in">resolve</span>(<span class="hljs-string">&quot;clearHook&quot;</span>);<br>HWND hWndChrome = <span class="hljs-built_in">FindWindowA</span>(<span class="hljs-string">&quot;Chrome_WidgetWin_1&quot;</span>, <span class="hljs-literal">NULL</span>);<br>DWORD errorCode;<br><span class="hljs-built_in">clearHook</span>();<span class="hljs-comment">//手动清除hWndServer防止Chrome dll未卸载导致共享变量未删除</span><br><span class="hljs-built_in">setMouseHook</span>((HWND)<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">winId</span>(), hWndChrome, &amp;errorCode);<br></code></pre></td></tr></table></figure><p>可以用<code>QLibrary</code>载入<code>dll</code>（<code>Windows API</code>为<code>LoadLibrary</code>）</p><p>并根据函数名定位函数地址（有了地址就可以调用了）</p><p>然后在消息循环中接收内鬼<code>dll</code>发来的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Widget::nativeEvent</span><span class="hljs-params">(<span class="hljs-type">const</span> QByteArray&amp; eventType, <span class="hljs-type">void</span>* message, <span class="hljs-type">long</span>* result)</span> </span><br><span class="hljs-function"></span>&#123;<br>    MSG* msg = (MSG*)message;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> UINT UWM_MOUSEHOOK = <span class="hljs-built_in">RegisterWindowMessageW</span>(<span class="hljs-string">L&quot;Chrome_WH_MOUSE&quot;</span>);<br>    <span class="hljs-keyword">if</span> (msg-&gt;message == UWM_MOUSEHOOK &amp;&amp; msg-&gt;wParam == WM_LBUTTONDBLCLK) &#123;<br>        HWND hwnd = (HWND)msg-&gt;lParam;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;WM_LBUTTONDBLCLK&quot;</span> &lt;&lt; hwnd;<br>        <span class="hljs-keyword">if</span> (Win::<span class="hljs-built_in">getWindowClass</span>(hwnd) == ChromeClass) &#123;<br>            Win::<span class="hljs-built_in">simulateKeyEvent</span>(<span class="hljs-built_in">QList</span>&lt;BYTE&gt;(&#123; VK_CONTROL, <span class="hljs-string">&#x27;W&#x27;</span> &#125;));<span class="hljs-comment">//模拟双击关闭标签页</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//此处返回false，留给其他事件处理器处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Okay，大功告成，这样就实现了监听<code>Chrome</code>标题栏的左键双击并模拟<code>Ctrl+W</code>关闭标签页的效果</p><h2 id="问题和注意事项"><a href="#问题和注意事项" class="headerlink" title="问题和注意事项"></a>问题和注意事项</h2><p>1.<a href="https://blog.csdn.net/immigrator/article/details/7560965">关于<code>dll</code>被多个进程调用</a></p><p><code>Win32</code>系统会确保内存中只有一个该<code>DLL</code>的拷贝，这是通过内存映射文件来实现的。不同的进程分别将这份<code>DLL</code>的代码段地址映射到自己的进程空间中，同时不同的进程在自己的进程空间分别有各自的一份该<code>DLL</code>的数据段（全局变量）拷贝</p><p>2.<a href="https://blog.csdn.net/immigrator/article/details/7560965">既然代码段共享，如果进程A中修改<code>DLL</code>的代码内容，使用同一<code>DLL</code>的其它进程B是否受影响？</a></p><p>NO！</p><p>这就涉及到一个内存的<code>COPY ON WRITE</code>机制问题</p><p>如果进程A修改了<code>dll</code>代码或数据，则有内容被修改后，会构造副本，重新映射</p><p>所以基本上内存中只有一份<code>dll</code>可以节省空间</p><p>3.不调用<code>UnhookWindowsHookEx</code>释放钩子会如何？</p><p>其实不会如何，由于<code>Windows</code>系统的鲁棒性，在程序退出时，系统会隐式释放所有句柄，所以其实不用太担心</p><p>实验表明，如果钩子函数写在<code>dll</code>中，程序直接退出，系统会释放<code>Hook</code>句柄，并卸载在其他线程注入的<code>dll</code>（可能有<strong>延迟</strong>）</p><h4 id="所有dll释放后，共享数据段被清空（我猜的）"><a href="#所有dll释放后，共享数据段被清空（我猜的）" class="headerlink" title="所有dll释放后，共享数据段被清空（我猜的）"></a>所有<code>dll</code>释放后，共享数据段被清空（我猜的）</h4><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/Castlehe/article/details/108275984">Visual Studio关于hook项目的简单使用_吨吨不打野的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/fanling999/p/4592740.html">HOOK API （一）——HOOK基础+一个鼠标钩子实例 - …..? - 博客园</a></p><p><a href="http://www.flounder.com/hooks.htm">Hooks and DLLs</a></p><p><a href="https://blog.csdn.net/immigrator/article/details/7560965">有关DLL的几个问题_SONG_CA的博客-CSDN博客</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowshookexa?redirectedfrom=MSDN">SetWindowsHookExA function (winuser.h) - Win32 apps | Microsoft Docs</a></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Windows</tag>
      
      <tag>Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟按键 - keybd_event Send/PostMessage的一些思考</title>
    <link href="/2022/03/23/%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE-keybd-event-Send-PostMessage%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <url>/2022/03/23/%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE-keybd-event-Send-PostMessage%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在软件开发，特别是辅助软件开发过程中，经常需要用到键盘按键模拟来实现自动化</p><p>比如，使用虚拟键码<code>VK_VOLUME_UP</code> &amp; <code>VK_VOLUME_DOWN</code>来实现音量调节</p><p>或者，使用<code>VK_SNAPSHOT</code>实现截屏</p><p>这是一种可以避开系统<code>API</code>复杂操作的，非常讨巧的捷径</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="keybd-event"><a href="#keybd-event" class="headerlink" title="keybd_event"></a>keybd_event</h3><p>为了实现按键模拟，我们常用<code>Windows API</code> - <code>keybd_event</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">keybd_event</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] BYTE      bVk, <span class="hljs-comment">//一个虚拟键码。代码必须是 1 到 254 范围内的值</span></span></span><br><span class="hljs-params"><span class="hljs-function">  [in] BYTE      bScan, <span class="hljs-comment">//密钥的硬件扫描码</span></span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD     dwFlags, <span class="hljs-comment">//控制功能操作的各个方面: KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP</span></span></span><br><span class="hljs-params"><span class="hljs-function">  [in] ULONG_PTR dwExtraInfo <span class="hljs-comment">//与击键关联的附加值</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>一般情况下，我们只需要使用<code>bVK</code> &amp; <code>dwFlags</code>参数即可（复杂情况，如游戏窗口，需要加上扫描码）</p><p>一个击键的过程分为两个步骤：按下 &amp; 抬起</p><p>所以，如果我们要模拟键盘上<code>A</code>键的击键：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">keybd_event</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//第三个参数0代表KeyDown</span><br><span class="hljs-built_in">keybd_event</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>, KEYEVENTF_KEYUP, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>或者是，回车键<code>（ENTER）</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">keybd_event</span>(VK_RETURN, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">keybd_event</span>(VK_RETURN, <span class="hljs-number">0</span>, KEYEVENTF_KEYUP, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>知道了这点，那么模拟组合键也不在话下了，如<code>Ctrl+Tab</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">keybd_event</span>(VK_CONTROL, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//按下Ctrl</span><br><span class="hljs-built_in">keybd_event</span>(VK_TAB, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//按下Tab</span><br><span class="hljs-built_in">keybd_event</span>(VK_TAB, <span class="hljs-number">0</span>, KEYEVENTF_KEYUP, <span class="hljs-number">0</span>);<span class="hljs-comment">//抬起Tab</span><br><span class="hljs-built_in">keybd_event</span>(VK_CONTROL, <span class="hljs-number">0</span>, KEYEVENTF_KEYUP, <span class="hljs-number">0</span>);<span class="hljs-comment">//抬起Ctrl</span><br></code></pre></td></tr></table></figure><p>其他按键的宏定义可以参考：<a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes">虚拟键代码（Virtual-Key Codes）</a></p><p><em>注：微软官方建议 - 此功能已被取代。请改用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-sendinput">SendInput</a>（其实差不多）</em></p><h3 id="SendMessage-x2F-PostMessage"><a href="#SendMessage-x2F-PostMessage" class="headerlink" title="SendMessage&#x2F;PostMessage"></a>SendMessage&#x2F;PostMessage</h3><p>众所周知，<code>Windows</code>系统是基于消息的，而这两个函数都是向窗口发送消息</p><p>他们的区别在于：</p><ul><li><code>SendMessage</code>是同步函数，或者说阻塞函数，调用指定窗口的窗口过程，直到窗口过程<strong>处理完</strong>消息才返回</li><li><code>PostMessage</code>是异步函数，在与创建指定窗口的线程关联的消息队列中发布一条消息，并在<strong>不等待</strong>线程处理消息的情况下返回。</li></ul><p>也就是说，<code>SendMessage</code>返回的时候，消息肯定被对方处理完了</p><p>而<code>PostMessage</code>不管处理没处理，什么时候处理，直接扔过去就返回了</p><p>好处是，对方不回应的时候，自己不会卡死（挂起）</p><p>为什么要提这两个函数呢，因为<code>Windows</code>基于消息，所以按键也是<code>消息(WM_KEYDOWN | WM_KEYUP)</code></p><p>那么只要向指定窗口发送消息就可以模拟按键了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//模拟A键</span><br><span class="hljs-built_in">SendMessage</span>(hwnd, WM_KEYDOWN, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">SendMessage</span>(hwnd, WM_KEYUP, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>比<code>keybd_event</code>多一个参数，这里的<code>hwnd</code>指的是窗口句柄，类似于窗口的<code>ID</code></p><p>而<code>PostMessage</code>如果这么写的话，就会发现不对劲了，按键貌似被重复了两遍</p><p>查询资料 &amp; 官方文档可知，我们忽略了最后一个参数：<code>lParam</code></p><blockquote><p>重复计数、扫描码、扩展键标志、上下文代码、前一个键状态标志和转换状态标志，如下所示</p></blockquote><p><img src="/img/image-20220323145807093.png" alt="lParam"></p><blockquote><p>击键消息的<strong>lParam</strong>参数包含有关生成消息的击键的附加信息。该信息包括重复计数、扫描码、扩展键标志、上下文代码、前一个键状态标志和转换状态标志。下图显示了这些标志和值在<strong>lParam</strong>参数中的位置。</p></blockquote><p><img src="https://docs.microsoft.com/en-us/windows/win32/inputdev/images/csinp-02.png" alt="击键消息的 lparam 参数中的标志和值的位置"></p><p>也就是在一个<code>32</code>位的参数中，表示了大量标志信息，这需要用到位运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">DWORD dwVKFkeyData;<br>WORD dwScanCode = <span class="hljs-built_in">MapVirtualKey</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//计算扫描码</span><br>dwVKFkeyData = <span class="hljs-number">1</span>; <span class="hljs-comment">//00000...00001(b)</span><br>dwVKFkeyData |= dwScanCode &lt;&lt; <span class="hljs-number">16</span>;<br><span class="hljs-built_in">PostMessage</span>(hwnd, WM_KEYDOWN, <span class="hljs-string">&#x27;B&#x27;</span>, dwVKFkeyData);<br>dwVKFkeyData |= <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">30</span>; <span class="hljs-comment">//11(b) &lt;&lt; 30</span><br><span class="hljs-built_in">PostMessage</span>(hwnd, WM_KEYUP, <span class="hljs-string">&#x27;B&#x27;</span>, dwVKFkeyData);<br></code></pre></td></tr></table></figure><p>这样才能完成一次<code>PostMessage</code>击键消息的正确发送</p><p>显然是<code>SendMessage</code>更方便，但要考虑到阻塞函数的成本</p><h2 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h2><p>以上都是一些基础操作，没什么好说的，也都是大家公认的</p><p>但是呢，需求一旦复杂化，基本的信息就不够用了，问题就蜂拥而至了</p><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>首先我们说一下，<code>keybd_event</code> 与 <code>Send/PostMessage</code>的区别吧</p><ul><li><p><code>keybd_event</code>是全局按键模拟，也就是像真实地按键一样，将消息发送给<strong>前台活动</strong>窗口，也就是<strong>焦点</strong>窗口，这是一大限制</p></li><li><p><code>Send/PostMessage</code>可以自行指定发送的窗口对象，可以向<strong>无焦点</strong>的窗口发送按键信息，更灵活</p></li></ul><p>如果世上真有这样完美的函数就好了，那另一方就会被抹杀</p><p>这两者同时存在是有原因的：</p><ul><li><code>Send/PostMessage</code>无法模拟组合键（<code>ALT</code>除外），这是一个很大的限制，因为消息只是状态的<strong>切换</strong>，不能<strong>维持</strong>按下，而程序通常是直接检测<code>Ctrl Shift</code>等修饰键的状态来决定组合键的</li><li>模拟按键时，<code>SendMessage</code>有时会失效（如QQ窗口），所以建议用<code>PostMessage</code>（<em>原因不明</em>）</li></ul><h3 id="组合键处理"><a href="#组合键处理" class="headerlink" title="组合键处理"></a>组合键处理</h3><p>那怎么办，要发送组合键怎么办</p><p>如果是活动窗口，那直接<code>keybd_event</code>模拟，没啥好说的</p><p>如果是非活动窗口怎么办</p><ul><li>最粗暴，直接将其变为前台活动窗口，然后再模拟（设置前台窗口参见：<a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-attachthreadinput">AttachThreadInput</a> &amp; <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a>）</li><li>↑但这是个悖论，这样就不是非活动窗口了</li><li>或者用<code>keybd_event</code>模拟修饰键（如<code>Ctrl</code>） + <code>Send/PostMessage</code>模拟其他按键（如<code>A</code>），但问题在于无法很好地配合消息顺序，因为<code>keybd_event</code>不会等待消息处理</li><li>解决办法：在<code>keybd_event</code>之后延时一段时间，再进行<code>SendMessage</code>，可实现对非活动窗口的组合键控制</li></ul><h3 id="往下-再往下（驱动级模拟）"><a href="#往下-再往下（驱动级模拟）" class="headerlink" title="往下 再往下（驱动级模拟）"></a>往下 再往下（驱动级模拟）</h3><p>一般的窗口这样就行了，但是游戏窗口可能会直接使用底层硬件输入（低延时），而不经过<code>Windows</code></p><p>这时候就不能在使用<code>Windows</code>消息机制了，必须直接对底层端口进行操作</p><p>这时候就需要外力帮助了</p><blockquote><p>WinIO程序库允许在32位的Windows应用程序中直接对I&#x2F;O端口和物理内存进行存取操作。通过使用一种内核模式的设备驱动器和其它几种底层编程技巧，它绕过了Windows系统的保护机制</p></blockquote><p>拓展资料：</p><p><a href="https://github.com/starofrainnight/winio">winio下载winio的源码_GitHub_帮酷</a></p><p><a href="https://www.cnblogs.com/WoodHower/p/14850251.html">winIO介绍 - 野蛮木头 - 博客园</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="http://www.noobyard.com/article/p-fxffgjkm-gg.html">键盘鼠标模拟全知道 - 菜鸟学院</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-keybd_event">keybd_event function (winuser.h) - Win32 apps | Microsoft Docs</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/about-keyboard-input#keystroke-message-flags">About Keyboard Input - Win32 apps | Microsoft Docs</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown">WM_KEYDOWN message (Winuser.h) - Win32 apps | Microsoft Docs</a></p><p><a href="https://blog.csdn.net/lzl_li/article/details/117386885">通过PostMessage&#x2F;SendMessage实现模拟键盘鼠标按键，发送不成功或出现重复按键的可参考本文_lzl_li的博客-CSDN博客_c# sendmessage模拟键盘</a></p><p><a href="https://www.codeleading.com/article/40993377446/">向某个窗口发送按键消息(包括后台隐藏的窗口) - 代码先锋网</a></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次数组越界引发的内存篡改导致的野指针引用灾难</title>
    <link href="/2022/03/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98%E7%AF%A1%E6%94%B9%E5%AF%BC%E8%87%B4%E7%9A%84%E9%87%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%81%BE%E9%9A%BE/"/>
    <url>/2022/03/21/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98%E7%AF%A1%E6%94%B9%E5%AF%BC%E8%87%B4%E7%9A%84%E9%87%8E%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%81%BE%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>那是一个风和日丽的晚上，我回到寝室，打开电脑，发现我的程序窗口（姑且叫它<code>QF.exe</code>）消失了</p><ul><li>这是一个跟随QQ窗口的辅助小程序</li></ul><p>“可能是之前忘记开了吧”，我并没有太在意</p><p>随后便再次打开了<code>QF.exe</code></p><p>刷刷B站，玩玩游戏，好不快活</p><p>可当我再次打开QQ，点击<code>QF</code>的窗口时，看着旋转的鼠标指针，我好像知道接下来要发生什么了</p><ul><li><code>QF</code>再次消失了</li></ul><blockquote><p>ta 轻轻地走了，正如 ta 轻轻地来，挥一挥鼠标，不带走一块内存</p><p>只留我一人，在风中凌乱</p></blockquote><p>“ta 不是这样的人，ta 从不会不辞而别”</p><p>我这才意识到事情的严重性，其实之前也发生过类似的事情，但我却一直不以为意，让 ta 承受了太多</p><p>悔不当初，如果给我再来一次的机会，我一定会对 ta 说三个字：<strong>我焯！</strong></p><p>加班吧</p><h2 id="你能再表演一次吗"><a href="#你能再表演一次吗" class="headerlink" title="你能再表演一次吗"></a>你能再表演一次吗</h2><blockquote><p>修正程序错误的第一步是要重现这个错误。—— Tom Duff</p></blockquote><p>如果收集不到足够多的<code>bug</code>样例，就没有办法对<code>bug</code>进行分析</p><p>所以<code>debug</code>的第一步就是复现<code>bug</code></p><p>当时无论我如何测试程序，ta 表现得都极其正常，反而是在我抛之脑后几小时，才会出现闪退，并且时机极其<strong>随机</strong></p><ul><li>即：无法确定<code>bug</code>触发机制</li></ul><p>调查陷入了僵局</p><h2 id="搜狗，我叫你一声你敢应吗"><a href="#搜狗，我叫你一声你敢应吗" class="headerlink" title="搜狗，我叫你一声你敢应吗"></a>搜狗，我叫你一声你敢应吗</h2><p>唯一值得在意的是，异常退出前，在<code>QtCreator</code>的输出窗口中出现了这么一行：<code>D:\SogouInput\Components</code></p><p><img src="/img/image-20220321175514697.png" alt="D:\SogouInput\Components"></p><p>可以肯定的是，这不是本程序的任何输出</p><p>也就是说，要么是<code>QtCreator</code>的提示，要么是搜狗输入法搞的鬼</p><p>经过搜索，发现我并不是唯一一个受到搜狗青睐的码农</p><p>有不少人都遇到过这样的提示，但大伙都一致表示，这锅还真不能让搜狗背</p><p><img src="/img/image-20220321175153078.png" alt="Google"></p><p><img src="/img/image-20220321175236363.png" alt="跟搜狗没关系"></p><p>而且，我的记忆中貌似也遇到过这样的提示，确实是野指针的问题</p><h2 id="是你，又不是你"><a href="#是你，又不是你" class="headerlink" title="是你，又不是你"></a>是你，又不是你</h2><p>既然知道了是野指针的问题，那就找呗</p><p>但奇怪的是，在反反复复阅读了所有代码后，我确认了一个事实：</p><ul><li>我的代码里没有任何可能的野指针，全员初始化</li></ul><p>调查再次陷入僵局</p><h2 id="Windows-你怎么看"><a href="#Windows-你怎么看" class="headerlink" title="Windows, 你怎么看"></a>Windows, 你怎么看</h2><p>通过<code>Windows</code>的事件查看器，我们发现，程序的异常退出触发了一次<code>Application Error</code>记录</p><p><img src="/img/image-20220321181024001.png" alt="事件查看器"></p><p>可以发现，出错的模块为：Qt5Gui.dll</p><p>至少可以确认是与<code>GUI</code>相关函数出错，且通过错误偏移量可以确认函数名称（虽然当时并不知道How）</p><p>但与<code>GUI</code>操作相关的类太多，依旧难以定位</p><h2 id="对不起，搜狗"><a href="#对不起，搜狗" class="headerlink" title="对不起，搜狗"></a>对不起，搜狗</h2><p>有谁还记得搜狗给我留下的线索：<code>D:\SogouInput\Components</code></p><p>我尝试着进入这个目录，发现了<code>crash</code>文件夹，里面含有：</p><ul><li>crash.dmp</li><li>errorlog.txt</li></ul><p><code>errorlog.txt</code>里记录了<code>QF</code>的崩溃时间，模块以及当时的所有进程</p><p>而<code>crash.dmp</code>是<code>Windows</code>的内存转储文件，需要用<code>windbg</code>打开</p><p>里面记录了<code>QF</code>崩溃瞬间的内存信息，以及函数调用链</p><p>这是程序生命最后的黑匣子（www）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dmp">ExceptionAddress: 000000000119fa8a (Qt5Gui!ZNK4QPeneqERKS_+0x000000000000001a)<br>ExceptionCode: c0000005 (Access violation)<br>ExceptionFlags: 00000000<br>NumberParameters: 2<br>   Parameter[0]: 0000000000000000<br>   Parameter[1]: ffffffffffffffff<br>Attempt to read from address ffffffffffffffff<br><br>STACK_TEXT:  <br> Qt5Gui!ZNK4QPeneqERKS_+0x1a<br> Qt5Gui!ZN8QPainter6setPenERK4QPen+0x23<br> QQ_Follower+0x4d51<br></code></pre></td></tr></table></figure><p>这是<code>dll</code>的导出函数，虽然函数名经过处理，不过还是能大致看出其本来面目</p><h2 id="是谁？"><a href="#是谁？" class="headerlink" title="是谁？"></a>是谁？</h2><p>可以清晰地看到，元凶是<code>ZNK4QPeneqERKS_</code>这个函数进行了非法内存访问，导致的崩溃</p><p>而上一级调用函数是<code>ZN8QPainter6setPenERK4QPen</code></p><p>根据代码猜测，这两个函数分别是<code>QPen::operator==()</code> 和 <code>QPainter::setPen()</code></p><p>而且本程序唯一使用<code>QPainter::setPen()</code>的地方只有<code>paintEvent()</code></p><p>并且貌似之前都是在窗体重新渲染时，出现的闪退</p><p>这么一来，基本可以确定是<code>paintEvent()</code>中<code>QPainter::setPen()</code>的问题了</p><h2 id="为什么是你？"><a href="#为什么是你？" class="headerlink" title="为什么是你？"></a>为什么是你？</h2><p>乍一看，已经找到了问题所在，但你仔细想想，这是十分不合理的</p><p>在<code>paintEvent()</code>中利用<code>QPainter::setPen()</code>设置画笔，改变颜色 &amp; 线条粗细等，是常规操作，不应该出问题</p><p>在仔细阅读了<code>Qt</code>源码后，我发现，<code>QPainter::setPen()</code>中确实用到了<code>QPen::operator==()</code> 用以比较新旧画笔</p><p>但是这个函数想要出现指针引用错误，就只能是<code>QPainter::setPen(const QPen&amp; pen)</code>传入的参数<code>pen</code>的问题了</p><p>这个<code>pen</code>，嗯，嗯？嗯！嗯？</p><p>这次确实有些不同，为了减少每次构造 &amp; 析构的开销，我使用了<code>static</code>将<code>pen</code>修饰为静态变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent* event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> QPen <span class="hljs-title">pen</span><span class="hljs-params">(Qt::darkGray, <span class="hljs-number">2</span>)</span></span>;<br>    painter.<span class="hljs-built_in">setPen</span>(pen);<br>    painter.<span class="hljs-built_in">drawRect</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">rect</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，那又如何呢</p><p>一个<code>static QPen</code>总不可能是野指针吧，况且是通过<code>const &amp;</code>引用传递</p><p>虽说<code>QPen</code>类内含指针成员，但是没有任何函数修改这个<code>static</code>对象呀</p><h2 id="不，不是你"><a href="#不，不是你" class="headerlink" title="不，不是你"></a>不，不是你</h2><p>不应该不应该，怎么说都不可能是<code>static</code>的问题</p><p>这非常违反我多年来的<code>C++</code>常识</p><p>此案另有隐情</p><h2 id="试试也无妨"><a href="#试试也无妨" class="headerlink" title="试试也无妨"></a>试试也无妨</h2><p>在数次希望与失望中徘徊后，我甚至想过是<code>Sougou</code>的<code>32/64 bits</code>版本问题</p><p>在思索无果后，虽然很冲击我的常识，但还是决定死马当活马医，试试去掉<code>static</code></p><h2 id="扑朔迷离"><a href="#扑朔迷离" class="headerlink" title="扑朔迷离"></a>扑朔迷离</h2><p>在去除<code>static</code>后，离奇的事情发生了</p><p>虽然程序还是崩溃了，但是<code>dmp</code>的分析结果却产生了变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dmp">ExceptionAddress: 000000006895a94e (Qt5Core!ZN9QtPrivate20QStringList_containsEPK11QStringListRK7QStringN2Qt15CaseSensitivityE+0x000000000000000e)<br>ExceptionCode: c0000005 (Access violation)<br>ExceptionFlags: 00000000<br>NumberParameters: 2<br>   Parameter[0]: 0000000000000000<br>   Parameter[1]: ffffffffffffffff<br>Attempt to read from address ffffffffffffffff<br></code></pre></td></tr></table></figure><p>这次发生异常的函数不再是<code>QPen::operator==()</code> 而是<code>ZN9QtPrivate20QStringList_containsEPK11QStringListRK7QStringN2Qt15CaseSensitivityE</code></p><p>也就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">QPrivate::<span class="hljs-built_in">QStringList_contains</span>(<span class="hljs-type">const</span> QStringList *that, <span class="hljs-type">const</span> QString &amp;str, Qt::CaseSensitivity cs)<br></code></pre></td></tr></table></figure><h2 id="惊人的相似"><a href="#惊人的相似" class="headerlink" title="惊人的相似"></a>惊人的相似</h2><p>那么，我在什么地方使用了这个函数呢</p><p>我记得非常清楚</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> QStringList BlackList = &#123; <span class="hljs-string">&quot;XXX&quot;</span>, <span class="hljs-string">&quot;YYY&quot;</span>, <span class="hljs-string">&quot;ZZZ&quot;</span> &#125;;<br><span class="hljs-keyword">if</span>(BlackList.<span class="hljs-built_in">contains</span>(title))&#123;...&#125;<br></code></pre></td></tr></table></figure><p>我只在这个<code>QStringList</code>对象上调用了<code>contains</code>函数（该函数在内部会继续调用上述函数）</p><p>发现了吗，又是一个<code>static</code>对象，又是野指针非法内存访问</p><p>这种不谋而合的相似，真是让我不寒而栗</p><p>难以言说，但有种真相呼之欲出的感觉</p><h2 id="前方是什么"><a href="#前方是什么" class="headerlink" title="前方是什么"></a>前方是什么</h2><p>为了解决这个疑问</p><p>我决定要亲眼看一看内存</p><p>用<code>QtCreator</code>的<code>debug</code>模式调试，并设置断点，查看<code>BlackList</code>的内存</p><p>乍一看，平平无奇，但当我抬头时，我却看到了令人震撼的一幕</p><h2 id="鬼压床"><a href="#鬼压床" class="headerlink" title="鬼压床"></a>鬼压床</h2><p><img src="/img/image-20220321192456055.png" alt="内存"></p><p>在<code>BlackList</code>的内存上方，赫然立着两个数组 <code>text</code> &amp; <code>path</code>，分别存储窗口标题和进程路径</p><p>如果这俩数组下溢的话，那将直接覆盖<code>BlackList</code>的内存，后果不堪设想，其中的指针必然野化</p><p>顺便说一下，这俩数组为何会并列<code>BlackList</code>出现在这里</p><p>那是因为 <code>text</code> <code>path</code> <code>BlackList</code>均为<code>static</code>变量，统一置于静态存储区</p><h2 id="真相？"><a href="#真相？" class="headerlink" title="真相？"></a>真相？</h2><p>至此，我们可以大致还原事件的真相</p><p>可能是某数组下溢，导致<code>BlackList</code>中的指针被覆盖，导致产生野指针，解引用后非法内存访问导致崩溃</p><p>不过，究竟是什么导致数组溢出？</p><h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">QString <span class="hljs-title">Win::getWindowText</span><span class="hljs-params">(HWND hwnd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> WCHAR text[<span class="hljs-number">128</span>];<span class="hljs-comment">//#</span><br>    <span class="hljs-built_in">GetWindowTextW</span>(hwnd, text, <span class="hljs-built_in">sizeof</span>(text));<span class="hljs-comment">//#</span><br>    <span class="hljs-keyword">return</span> QString::<span class="hljs-built_in">fromWCharArray</span>(text);<br>&#125;<br><span class="hljs-function">QString <span class="hljs-title">Win::getProcessName</span><span class="hljs-params">(HWND hwnd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (hwnd == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">QString</span>();<br>    DWORD PID = <span class="hljs-built_in">getProcessID</span>(hwnd);<br><br>    <span class="hljs-type">static</span> WCHAR path[<span class="hljs-number">128</span>];<span class="hljs-comment">//#</span><br>    HANDLE Process = <span class="hljs-built_in">OpenProcess</span>(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);<br>    <span class="hljs-built_in">GetProcessImageFileNameW</span>(Process, path, <span class="hljs-built_in">sizeof</span>(path));<span class="hljs-comment">//#</span><br>    <span class="hljs-built_in">CloseHandle</span>(Process);<br><br>    QString pathS = QString::<span class="hljs-built_in">fromWCharArray</span>(path);<br>    <span class="hljs-keyword">return</span> pathS.<span class="hljs-built_in">mid</span>(pathS.<span class="hljs-built_in">lastIndexOf</span>(<span class="hljs-string">&#x27;\\&#x27;</span>) + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>问题只可能出现在<code>GetWindowTextW</code> &amp; <code>GetProcessImageFileNameW</code>的参数上（Windows API分为W和A版本，W代表宽字符）</p><p>但是为什么明明用了<code>sizeof</code>还会溢出呢？</p><p>问题就出在这</p><p>阅读官方文档可知：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetWindowTextW</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  HWND   hWnd,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out] LPWSTR lpString,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  <span class="hljs-type">int</span>    nMaxCount <span class="hljs-comment">//复制到缓冲区的最大字符数，包括空字符。如果文本超出此限制，则将其截断。</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>最后一个参数是 最大<strong>字符数</strong>，而非<strong>字节数</strong></p><p>一字之差，导致了程序的崩溃</p><p>在<code>ASCII</code>编码下，一字符为一字节，可以用<code>sizeof</code>直接获取</p><p>而为了表示中文，就需要用到宽字符<code>WCHAR</code>（wchar_t）</p><p>一个宽字符并不是一字节 所以使用<code>sizeof</code>会导致结果大于字符数，导致<code>text</code>溢出</p><p>正确的做法是使用<a href="https://www.cnblogs.com/envoy/p/8352467.html"><code>_countof</code></a>宏来获取实际数组元素个数</p><p><code>path</code>同上</p><h2 id="结束了吗？"><a href="#结束了吗？" class="headerlink" title="结束了吗？"></a>结束了吗？</h2><p>并没有</p><p>仔细观察可以发现，<code>text</code>在<code>path</code>上方，要溢出也是先覆盖<code>path</code>，并不会对<code>BlackList</code>造成影响</p><p>真相就在眼前，却要峰回路转了嘛？</p><p>仔细回忆可以发现，程序貌似只在<code>release</code>模式下崩溃过，在<code>debug</code>模式下虽然也会有<code>SougouInput</code>的信息：</p><ul><li>Shared library architecture i386 is not compatible with target architecture i386:x86-64.</li></ul><p>但显然与之前不同，且不会造成崩溃</p><h2 id="冷不丁"><a href="#冷不丁" class="headerlink" title="冷不丁"></a>冷不丁</h2><p>难道是<code>release</code> &amp; <code>debug</code>模式下内存分布不同？</p><p>确是如此</p><p>在<code>release</code>模式下输出三者地址：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">path:         <span class="hljs-number">0x40d140</span><br>text:         <span class="hljs-number">0x40d240</span><br>&amp;BlackList:   <span class="hljs-number">0x40d358</span><br></code></pre></td></tr></table></figure><p>发现<code>text</code>更靠近<code>BlackList</code>，溢出后直接导致其覆盖</p><h2 id="还没完"><a href="#还没完" class="headerlink" title="还没完"></a>还没完</h2><p>知道了内部机理，但究竟是什么导致了<code>text</code>溢出</p><p>一般情况下，窗口标题是不太可能超过128字符的</p><p>这也是此<code>bug</code>难以复现的原因之一</p><p>在偶然情况下，我记录到了使程序崩溃的窗口标题，长达173字符</p><ul><li>是<code>Chrome</code>浏览器在加载网页的瞬间，窗口标题短暂变为网址（可能还未获取到网页标题）</li></ul><p>这也解释了必须在玩乐之后才会崩溃的原因</p><p>而且在<code>text</code>越界后，程序并不会马上崩溃，必须要在QQ窗口重新获取焦点并监测<code>BlackList</code>时，才会触发野指针</p><p>更增加了<code>debug</code>难度</p><h2 id="结案"><a href="#结案" class="headerlink" title="结案"></a>结案</h2><p>该事件，十分复杂，让我们来捋一捋<code>bug</code>发生的流程：</p><ul><li>是<code>Chrome</code>浏览器在加载网页的瞬间，窗口标题短暂变为网址，导致<code>text</code>溢出</li><li><code>text</code>溢出覆盖<code>static</code>的<code>QPen</code>（before） 或者 覆盖<code>static</code>的<code>QStringList</code>（After），导致两者内部的指针野化</li><li>前者在<code>paintEvent()</code>时崩溃，后者在QQ获取焦点，比较<code>BlackList</code>时崩溃（非法内存访问）</li></ul><p>注意点：</p><ul><li><code>release</code> &amp; <code>debug</code>模式下内存分布可能不同</li></ul><p>解决办法：</p><ul><li>使用<a href="https://www.cnblogs.com/envoy/p/8352467.html"><code>_countof</code></a>宏来获取实际数组元素个数，而非<code>sizeof</code></li></ul><p>启示：</p><ul><li>使用<code>dmp</code>内存转储文件来记录程序崩溃瞬间的内存，并用<code>windbg</code>分析调用链</li><li>使用调试模式，观察内存，注意数组越界 &amp; 野指针</li><li>使用<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump"><code>ProcDump</code></a>工具创建<code>dmp</code>文件</li><li>其实<code>Windows</code>系统也会自动生成<code>dmp</code>文件，路径：<code>C:\Users\用户名\AppData\Local\CrashDumps</code>（在系统属性-高级-启动和故障恢复中设置）</li></ul><p>注：</p><ul><li>搜狗输入法可以获取程序崩溃信息 可能是因为输入法需要<code>dll</code>注入</li></ul><p>焯：</p><ul><li>我两年前好像犯过这样的错误：</li><li><a href="https://blog.csdn.net/qq_33374268/article/details/107687784?spm=1001.2014.3001.5501">记一次 C++ string 假性“内存泄露“ (_Big_allocation_sentinel)_MrBeanC的博客-CSDN博客_c++ string内存泄漏</a></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procdump">ProcDump - Windows Sysinternals | Microsoft Docs</a></p><p><a href="https://blog.csdn.net/weixin_38416696/article/details/107576060">Qt 利用 dmp 文件进行调试_Copy-&gt;Paste的博客-CSDN博客_dmp qt</a></p><p><a href="https://www.cnblogs.com/envoy/p/8352467.html">读懂_countof，可以懂得什么 - envoy - 博客园</a></p><p><a href="https://www.jianshu.com/p/d30c4fdd43cb">野指针 Crash - 简书</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextw">GetWindowTextW function (winuser.h) - Win32 apps | Microsoft Docs</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/getting-started-with-windbg">WinDbg 入门（用户模式） - Windows drivers | Microsoft Docs</a></p><p><a href="https://blog.csdn.net/Evennaire/article/details/82229695">Qt报错：C:\Program Files (x86)\SogouInput\Components_PlasticMatrix的博客-CSDN博客</a></p><p><a href="https://code.woboq.org/qt5/qtbase/src/gui/painting/qpainter.cpp.html#_ZN8QPainterD1Ev">qpainter.cpp source code [qtbase&#x2F;src&#x2F;gui&#x2F;painting&#x2F;qpainter.cpp] - Woboq Code Browser</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Windows文件关联</title>
    <link href="/2022/02/14/%E5%85%B3%E4%BA%8EWindows%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94/"/>
    <url>/2022/02/14/%E5%85%B3%E4%BA%8EWindows%E6%96%87%E4%BB%B6%E5%85%B3%E8%81%94/</url>
    
    <content type="html"><![CDATA[<p><a href="https://my.oschina.net/tojosaki/blog/1517530">Windows 文件关联机制剖析 - 东条咲的个人页面 - OSCHINA - 中文开源技术交流社区</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/shell/default-programs?redirectedfrom=MSDN#reg_examples">默认程序 - Win32 apps | Microsoft Docs</a></p><p><a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/630ed1d9-73f1-4cc0-bc84-04f29cffc13b/what-registry-keys-are-responsible-for-file-extension-association?forum=netfxbcl">What registry keys are responsible for file extension association?</a></p><p><a href="https://blogs.windows.com/windows-insider/2015/05/20/announcing-windows-10-insider-preview-build-10122-for-pcs/">Announcing Windows 10 Insider Preview Build 10122 for PCs | Windows Insider Blog</a></p><p><a href="https://cainiaojiaocheng.com/questions/3536634/getting-file-associations-using-windows-api">使用Windows API获取文件关联|菜鸟教程</a></p><p><a href="https://blog.csdn.net/weixin_40269730/article/details/99676425">利用AssocQueryString函数获取扩展名的关联程序路径_同学xx的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_41399894/article/details/109544067?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&utm_relevant_index=2">Qt之文件关联_朗朗上口就行啦的博客-CSDN博客_qt 文件关联</a></p><p><a href="https://www.it1352.com/1278749.html">如何以编程方式在Windows 10中设置文件关联。 - IT屋-程序员软件开发技术分享社区 (it1352.com)</a></p><p><a href="http://www.cnit.net.cn/?id=616">为啥用改注册表方式无法修改Win10_1803默认浏览器_其他分享_技术小哥 ‘S blog (cnit.net.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/79489549">Win10_64 默认应用的UserChoice Hash算法学习 - 知乎 (zhihu.com)</a></p><p><a href="https://download.csdn.net/download/wjc1231313/10335453?utm_source=bbsseo">win8以上后缀关联userchoice计算hash值_UserChoice-C++代码类资源-CSDN文库</a></p><p><a href="https://www.zhihu.com/question/53466947?ivk_sa=1024320u">(29 封私信 &#x2F; 80 条消息) Win10总提示“已重置应用默认设置”是为什么？ - 知乎 (zhihu.com)</a></p><p><a href="https://docs.microsoft.com/zh-cn/archive/blogs/windowsinternals/windows-10-how-to-configure-file-associations-for-it-pros">Windows 10 – 如何为IT专业人员配置文件？ |微软文档 (microsoft.com)</a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>凉了，<code>Win10</code>不太建议编程设置文件关联，更倾向于用户手动选择</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++重构案例1：repeat in switch</title>
    <link href="/2022/02/05/C++%E9%87%8D%E6%9E%84%E6%A1%88%E4%BE%8B1%EF%BC%9Arepeat-in-switch/"/>
    <url>/2022/02/05/C++%E9%87%8D%E6%9E%84%E6%A1%88%E4%BE%8B1%EF%BC%9Arepeat-in-switch/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>这是<strong>图片查看器</strong>(ImageViewer2.0)中的一段代码，用于检测按键并切换图片：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::keyPressEvent</span><span class="hljs-params">(QKeyEvent* event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = fileList.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//fileList存放图片文件名</span><br>    <span class="hljs-keyword">switch</span> (event-&gt;<span class="hljs-built_in">key</span>()) &#123;<br>    <span class="hljs-keyword">case</span> Qt::Key_Left: &#123;<br>        index = <span class="hljs-built_in">qMax</span>(index - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<br>        <span class="hljs-built_in">setPixmap</span>(filePath);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Qt::Key_Right: &#123;<br>        index = <span class="hljs-built_in">qMin</span>(index + <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>);<br>        QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<br>        <span class="hljs-built_in">setPixmap</span>(filePath);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，这段代码检测小键盘的<code>Left/Right</code>按键，并更改<code>index</code>以切换图片</p><h2 id="問題点"><a href="#問題点" class="headerlink" title="問題点"></a>問題点</h2><p>由于<code>Left/Right</code>仅有<code>index</code>自增&#x2F;自减的区别</p><p>导致<strong>7、8</strong> &amp;&amp; <strong>12、13</strong>行代码重复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<span class="hljs-comment">//拼接文件路径</span><br><span class="hljs-built_in">setPixmap</span>(filePath);<span class="hljs-comment">//设置图片</span><br></code></pre></td></tr></table></figure><p>代码重复！</p><p>我焯</p><p>重复了两行代码！</p><p>你能忍吗？！</p><p>我不能忍</p><p>士可杀不可辱！</p><h2 id="插叙"><a href="#插叙" class="headerlink" title="插叙"></a>插叙</h2><p>在开始解决这个问题之前，先来解开大家对于代码的一点疑问</p><h3 id="1-index增减"><a href="#1-index增减" class="headerlink" title="1.index增减"></a>1.index增减</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">index = <span class="hljs-built_in">qMax</span>(index - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这行代码是为了防止<code>index</code>在减小的过程中变成负数</p><p>看起来没什么问题对吧</p><p>确实没什么问题，但是nie</p><p>按照我风格，怎么的也得写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">index = <span class="hljs-built_in">qMax</span>(--index, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这种前置自减运算符形式吧</p><p>虽说帅了一点，简洁了一点，这实际上这是<code>undefined</code>行为：在一个序列点前对<code>index</code>产生了两次<a href="https://blog.csdn.net/swordtraveller/article/details/110306917">副作用</a></p><ul><li><p><code>--index</code>自减操作对<code>index</code>的改变保证在<code>;</code>分号结束前完成</p></li><li><p>等号左边的<code>index</code>也会在<code>;</code>分号结束前被改变</p></li></ul><p>无法判断这两种副作用发生顺序，是<code>undefined</code>行为</p><p>所以不建议这么写</p><h3 id="2-case内花括号"><a href="#2-case内花括号" class="headerlink" title="2.case内花括号{}"></a>2.case内花括号{}</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">case</span> Qt::Key_Left: &#123;<br>    index = <span class="hljs-built_in">qMax</span>(index - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<br>    <span class="hljs-built_in">setPixmap</span>(filePath);<br>&#125; <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>为何<code>case</code>内要加上花括号(<code>line 1 &amp; 5</code>)呢</p><p>那我们不妨吧花括号去掉试试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">E:\Qt5<span class="hljs-number">.14</span><span class="hljs-number">.2</span>\Projects\ImageViewer_2\widget.cpp:<span class="hljs-number">302</span>: error: jump to <span class="hljs-keyword">case</span> label [-fpermissive]<br>     <span class="hljs-keyword">default</span>:<br>     ^~~~~~~<br>E:\Qt5<span class="hljs-number">.14</span><span class="hljs-number">.2</span>\Projects\ImageViewer_2\widget.cpp:<span class="hljs-number">299</span>: note:   crosses initialization of <span class="hljs-string">&#x27;QString filePath&#x27;</span><br>         QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<br>                 ^~~~~~~~<br></code></pre></td></tr></table></figure><p>哦吼 报错了</p><p>这是因为变量<code>filePath</code>的作用域是初始化点到<code>switch</code>的结尾处</p><p>由于我们无法确定其他<code>case</code>中是否会使用到这个变量，也无法判断使用之前变量是否被初始化（选择支具有不确定性）</p><p>导致编译器晕乎</p><p>所以只要用花括号<code>&#123;&#125;</code>限定<code>filePath</code>的作用域在单一<code>case</code>中即可（不会有人不知道<code>&#123;&#125;</code>限制作用域吧，不会吧不会吧）</p><p>Okey-dokey，解决了这些疑问，我们可以开始重构代码了</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><h3 id="其一：case-fall-through"><a href="#其一：case-fall-through" class="headerlink" title="其一：case fall through"></a>其一：case fall through</h3><p>众所周知，<code>case</code>标签内的代码执行完后并不会主动退出<code>switch</code>，而是自由落体至下一个<code>case</code></p><p>（这也就是要加上<code>break</code>的原因）</p><p>だから、只要利用这一特性，就能让<code>case Qt::Key_Left</code>滑落到<code>case Qt::Key_Right</code></p><p>从而实现复用代码的目的啦（小天才）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::keyPressEvent</span><span class="hljs-params">(QKeyEvent* event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = fileList.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">switch</span> (event-&gt;<span class="hljs-built_in">key</span>()) &#123;<br>    <span class="hljs-keyword">case</span> Qt::Key_Left:<br>        index -= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">case</span> Qt::Key_Right: &#123;<br>        index = <span class="hljs-built_in">qBound</span>(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>);<span class="hljs-comment">//std::clamp</span><br>        QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<br>        <span class="hljs-built_in">setPixmap</span>(filePath);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里会给出<code>Warning：this statement may fall through</code></p><p>hhh 用的就是这个特性</p><p>然后利用<code>qBound</code>来限制<code>index</code>范围（<code>std::clamp</code>也行）</p><h3 id="其二：优雅のlambda"><a href="#其二：优雅のlambda" class="headerlink" title="其二：优雅のlambda"></a>其二：优雅のlambda</h3><p>虽说<code>case</code>自由落体很帅，不过可读性基本是负数，估计一个月后自己也一脸懵逼了（自食恶果）</p><p>既然代码重复，那就封装函数就好了嘛，多简单的道理</p><p>而<code>lambda</code>可以简化小函数的书写，且可以写在另一个函数内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::keyPressEvent</span><span class="hljs-params">(QKeyEvent* event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> alterPixmap = [=](<span class="hljs-type">int</span> i) &#123;<br>        QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[i];<br>        <span class="hljs-built_in">setPixmap</span>(filePath);<br>    &#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = fileList.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">switch</span> (event-&gt;<span class="hljs-built_in">key</span>()) &#123;<br>    <span class="hljs-keyword">case</span> Qt::Key_Left:<br>        index = <span class="hljs-built_in">qMax</span>(index - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">alterPixmap</span>(index);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Qt::Key_Right:<br>        index = <span class="hljs-built_in">qMin</span>(index + <span class="hljs-number">1</span>, N - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">alterPixmap</span>(index);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>稳健</p><p>不过，这代码怎么变长了，emmm 等下</p><p>既然封装，我为什么不把<code>index</code>范围判断也扔进去，焯</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::keyPressEvent</span><span class="hljs-params">(QKeyEvent* event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> alterPixmap = [=](<span class="hljs-type">int</span> i) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = fileList.<span class="hljs-built_in">size</span>();<br>        index = <span class="hljs-built_in">qBound</span>(<span class="hljs-number">0</span>, i, N - <span class="hljs-number">1</span>);<span class="hljs-comment">//this-&gt;index</span><br>        QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<br>        <span class="hljs-built_in">setPixmap</span>(filePath);<br>    &#125;;<br>    <span class="hljs-keyword">switch</span> (event-&gt;<span class="hljs-built_in">key</span>()) &#123;<br>    <span class="hljs-keyword">case</span> Qt::Key_Left:<br>        <span class="hljs-built_in">alterPixmap</span>(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Qt::Key_Right:<br>        <span class="hljs-built_in">alterPixmap</span>(index + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>啊哈哈哈哈，我滴任务 完成辣</p><p>只能用帅气来形容</p><p>不过这里有个小知识点需要注意</p><h4 id="lambda-amp-this"><a href="#lambda-amp-this" class="headerlink" title="lambda &amp; this"></a><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">lambda &amp; this</a></h4><p><code>lambda</code>的捕获列表要如何处理类内的数据成员 &amp; 成员函数呢？</p><p>其实际上，所有的类内变量 &amp; 函数都是通过<code>this</code>指针来调用的</p><p>只要用<code>[=]</code>拷贝<code>this</code>指针即可</p><p>如：<code>index</code>，即<code>this-&gt;index</code>，也就可以随意修改调用了</p><h3 id="其三：正经函数"><a href="#其三：正经函数" class="headerlink" title="其三：正经函数"></a>其三：正经函数</h3><p>虽然<code>lambda</code>很优雅，但是在函数内定义，无法被外界调用</p><p>所以，我们还是老老实实写成函数吧（顺便改个名）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Widget::switchPixmap</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = fileList.<span class="hljs-built_in">size</span>();<br>    index = <span class="hljs-built_in">qBound</span>(<span class="hljs-number">0</span>, i, N - <span class="hljs-number">1</span>);<br>    QString filePath = curDirPath + <span class="hljs-string">&#x27;/&#x27;</span> + fileList[index];<br>    <span class="hljs-built_in">setPixmap</span>(filePath);<br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::keyPressEvent</span><span class="hljs-params">(QKeyEvent* event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (event-&gt;<span class="hljs-built_in">key</span>()) &#123;<br>    <span class="hljs-keyword">case</span> Qt::Key_Left:<br>        switchPixmap(index - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Qt::Key_Right:<br>        switchPixmap(index + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Perfect</p><p>peace</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">C++之Lambda表达式 - 季末的天堂 - 博客园</a></p><p><a href="https://blog.csdn.net/swordtraveller/article/details/110306917">【C++】序列点与副作用_swordtraveller的博客-CSDN博客</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%A1%BA%E5%BA%8F%E7%82%B9">顺序点 - 维基百科，自由的百科全书</a></p><p><a href="https://www.jianshu.com/p/254abfa7caed">【C++ 异常】error: jump to case label [-fpermissive] - 简书</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>重构</tag>
      
      <tag>switch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析std::function &amp; std::bind</title>
    <link href="/2022/02/01/%E6%B5%85%E6%9E%90std-function-std-bind/"/>
    <url>/2022/02/01/%E6%B5%85%E6%9E%90std-function-std-bind/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>函数(Function)</code>封装了一系列可复用的操作集合，是各类编程语言中非常重要的概念</p><p>在<code>C++</code>中，除了普通函数，还增加了<code>仿函数(Functor)</code>，又称为<code>函数对象</code>，实际上是重载了<code>函数调用运算符operator()</code>的类</p><p>而<code>C++11</code>中新增的<code>lambda</code>表达式其实就是<code>匿名Functor</code></p><h3 id="这些统称为可调用对象-callable-entity"><a href="#这些统称为可调用对象-callable-entity" class="headerlink" title="这些统称为可调用对象(callable entity):"></a>这些统称为<code>可调用对象(callable entity)</code>:</h3><ul><li><p>普通函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a + b;&#125; <br></code></pre></td></tr></table></figure></li><li><p><code>lambda</code>表达式： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> mod = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a % b;&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数对象类：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">divide</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> denominator, <span class="hljs-type">int</span> divisor)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> denominator/divisor;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="問題点"><a href="#問題点" class="headerlink" title="問題点"></a>問題点</h2><p>以上三种可调用对象虽然调用形式都是 <code>int(int,int)</code></p><p>但是定义形式五花八门，导致很难用<strong>统一的方式</strong>传递或保存</p><p>如果再遇到类成员函数，如何声明和调用，更是令人头大</p><h2 id="大一统：平权衡，正度量，调轻重"><a href="#大一统：平权衡，正度量，调轻重" class="headerlink" title="大一统：平权衡，正度量，调轻重"></a>大一统：平权衡，正度量，调轻重</h2><p>天下分久必合，合久必分</p><p>是时候来统一度量衡了</p><h2 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a>std::function</h2><p><code>std::function</code>是一个可调用对象包装器，是一个类模板，可以容纳所有可调用对象，用统一的方式处理函数和仿函数，并允许保存和延迟它们的执行</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; a = add;<span class="hljs-comment">//普通函数</span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; b = mod;<span class="hljs-comment">//lambda</span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; c = <span class="hljs-built_in">divide</span>();<span class="hljs-comment">//divide()创建匿名对象</span><br><span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-built_in">c</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>这样便可以舒适地定义、存储与调用一切<code>可调用对象</code>了</p><blockquote><p>如果这还不酷，什么是酷？—— 《Effective C++中文版（第三版）》p175</p></blockquote><h2 id="等一下"><a href="#等一下" class="headerlink" title="等一下"></a>等一下</h2><p>ちょっと待って，我刚刚是不是说了“一切”</p><p>我是不是忘了什么</p><p>什么呢</p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>成员函数的传递与调用一直是一个令人头疼的问题</p><p>但只要抓住其与普通函数的区别便可以一击毙命</p><h2 id="成员函数-vs-普通函数"><a href="#成员函数-vs-普通函数" class="headerlink" title="成员函数 vs 普通函数"></a>成员函数 vs 普通函数</h2><p>成员函数属于类，且可以使用成员变量（非static函数）</p><p>而成员变量依赖于具体实例</p><p>在不明确具体实例的情况下，成员函数没有办法正确执行</p><p>正是因为如此，成员函数其实是有一个隐含参数的（指向具体实例指针）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Object</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a+b;&#125;<br>&#125;<br><span class="hljs-comment">//Object::sum的形式其实是</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(Object* ptr,<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>;<span class="hljs-comment">//隐式参数Object* ptr</span><br><span class="hljs-comment">//调用：</span><br>(ptr-&gt;*sum)(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//-&gt;*为成员指针访问运算符</span><br></code></pre></td></tr></table></figure><p>所以在调用成员函数时，必须想办法提供具体实例的指针</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>普通调用时，我们可以采用 <code>.*</code> 或者 <code>-&gt;*</code> 运算符</p><p>但是在<code>std::function</code>对象中，更为简便</p><p>直接具象为第一个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Object</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a+b;&#125;<br>&#125;<br>Object a;<br>std::function&lt;<span class="hljs-type">int</span>(Object*,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; func = &amp;Object::sum;<br><span class="hljs-built_in">func</span>(&amp;a,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//直接作为第一个参数即可</span><br></code></pre></td></tr></table></figure><p>如果你不想在调用时绑定实例，也可以通过<code>std::bind</code>函数在定义时绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Object a;<br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; func = std::<span class="hljs-built_in">bind</span>(&amp;Object::sum, &amp;a);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这样就把对象<code>a</code>的地址绑定到了函数对象<code>func</code>的第一个参数上（从三个参数变成了两个参数）</p><h4 id="顺便一提，std-bind其实是将对象进行了拷贝"><a href="#顺便一提，std-bind其实是将对象进行了拷贝" class="headerlink" title="顺便一提，std::bind其实是将对象进行了拷贝"></a>顺便一提，<code>std::bind</code>其实是将对象进行了<strong>拷贝</strong></h4><p>也就是说，如果对象<code>a</code>销毁，<code>func</code>照样可以正常调用</p><p>如果想将拷贝改为引用，可以采用<code>ref(a)</code>形式</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>其实，调用<code>std::bind</code>进行绑定还是有些麻烦的</p><blockquote><p>毕竟，只有”懒”，才能推动自动化</p></blockquote><p><code>lambda</code>其实本身就是为了简化函数定义而存在的</p><p>而且其本质是重载了<code>operator()</code>的匿名函数对象类</p><p>所以在传递给<code>std::function</code>时，是一个对象，也就无需额外传递实例信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; add = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br><span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>如果需要其余变量或者所在类的成员变量，可以通过<code>lambda</code>的捕获列表传递</p><p>peace</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/zh379835552/article/details/19542181">C++11中的Lambda表达式构成之——捕获值列表</a></p><p><a href="https://www.cnblogs.com/xusd-null/p/3698969.html">bind原理图释 - xusd-null - 博客园</a></p><p><a href="https://blog.csdn.net/analogous_love/article/details/77750629">关于std::bind绑定栈变量对象的思考</a></p><p><a href="https://www.jianshu.com/p/f191e88dcc80">C++11 中的std::function和std::bind - 简书</a></p><p><a href="https://www.zhihu.com/question/25146152">如何使用std::function指向类的成员函数？ - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>std::function</tag>
      
      <tag>std::bind</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt-无边框窗口 设置任务栏缩略图</title>
    <link href="/2021/12/23/Qt-%E6%97%A0%E8%BE%B9%E6%A1%86%E7%AA%97%E5%8F%A3-%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E6%A0%8F%E7%BC%A9%E7%95%A5%E5%9B%BE/"/>
    <url>/2021/12/23/Qt-%E6%97%A0%E8%BE%B9%E6%A1%86%E7%AA%97%E5%8F%A3-%E8%AE%BE%E7%BD%AE%E4%BB%BB%E5%8A%A1%E6%A0%8F%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p><strong>任务栏缩略图</strong>可以在不激活窗口的状态下提供窗口的缩略信息</p><p>对于音乐播放器等软件，尤其重要，不仅可以增加观感，还能添加控制按钮</p><p>是专业程序员的不二之选</p><h2 id="且"><a href="#且" class="headerlink" title="且"></a>且</h2><p>都1202年了，不会还有人不用<code>无边框窗口(Framless)</code>吧</p><h2 id="でも"><a href="#でも" class="headerlink" title="でも"></a>でも</h2><p><code>Qt</code>自带的<code>QWinThumbnailToolBar</code>类是可以很方便地进行任务栏缩略图的控制</p><p>但是，对于无边框窗口，貌似出现了一些问题：</p><ul><li>缩略图周围出现了[类似标题栏的边框] 导致图片错位 十分影响美观</li></ul><p><img src="/img/image-20211223155027008.png" alt="错位边框"></p><p>在仔细阅读了<code>Qt</code>文档后，并没有什么收获，该类十分简洁，并无多于函数可供操作</p><p>焯</p><h2 id="止まるんじゃねよ"><a href="#止まるんじゃねよ" class="headerlink" title="止まるんじゃねよ"></a>止まるんじゃねよ</h2><blockquote><p>不要停下来啊 团长！</p></blockquote><p>毕竟<code>Qt</code>还是封装的<code>Windows API</code></p><p>所以还得从<a href="https://docs.microsoft.com/zh-cn/windows/win32/shell/taskbar-extensions?redirectedfrom=MSDN"><code>Windows API</code></a>文档入手</p><p>在搜寻了关于<code>TaskBar</code>的内容后，我找到了这样一个函数：<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/dwmapi/nf-dwmapi-dwmseticonicthumbnail"><code>DwmSetIconicThumbnail</code></a></p><p>这个函数与Qt-<code>QWinThumbnailToolBar::setIconicThumbnailPixmap</code>不能说很像，简直就是同父异母</p><h2 id="DwmSetIconicThumbnail"><a href="#DwmSetIconicThumbnail" class="headerlink" title="DwmSetIconicThumbnail"></a>DwmSetIconicThumbnail</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">HRESULT <span class="hljs-title">DwmSetIconicThumbnail</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] HWND    hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] HBITMAP hbmp,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD   dwSITFlags</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>重点在于最后一个参数 <code>dwSITFlags</code>：</p><ul><li>0 (0x00000000) - 提供的缩略图周围不显示任何<strong>框架</strong></li><li>DWM_SIT_DISPLAYFRAME (0x00000001) - 在提供的缩略图周围显示一个<strong>框架</strong></li></ul><p>主要就在于这个参数中的<strong>框架</strong>二字，联想我们之前出现的错位情况，那可不就是多了一个<strong>框架</strong>嘛</p><p>那么只要将参数设置为<strong>0</strong>，不就可以解决了嘛</p><h2 id="根源"><a href="#根源" class="headerlink" title="根源"></a>根源</h2><p>可是，<code>Qt</code> 为什么会出现这样的问题，难道是！</p><p>说罢，我便去查阅了<a href="https://code.woboq.org/qt5/qtwinextras/src/winextras/qwinthumbnailtoolbar.cpp.html#_ZN27QWinThumbnailToolBarPrivate21updateIconicThumbnailEPKi"><code>Qt</code>源码</a>：</p><p>やはり啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">QWinThumbnailToolBarPrivate::updateIconicThumbnail</span><span class="hljs-params">(<span class="hljs-type">const</span> MSG *message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!iconicThumbnail)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-function"><span class="hljs-type">const</span> QSize <span class="hljs-title">maxSize</span><span class="hljs-params">(HIWORD(message-&gt;lParam), LOWORD(message-&gt;lParam))</span></span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> HBITMAP bitmap = iconicThumbnail.<span class="hljs-built_in">bitmap</span>(maxSize)) &#123;<br>        <span class="hljs-type">const</span> HRESULT hr = <span class="hljs-built_in">DwmSetIconicThumbnail</span>(message-&gt;hwnd, bitmap, dWM_SIT_DISPLAYFRAME);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FAILED</span>(hr))<br>            <span class="hljs-built_in">qWarning</span>() &lt;&lt; QWinThumbnailToolBarPrivate::<span class="hljs-built_in">msgComFailed</span>(<span class="hljs-string">&quot;DwmSetIconicThumbnail&quot;</span>, hr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意观察第7行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> HRESULT hr = <span class="hljs-built_in">DwmSetIconicThumbnail</span>(message-&gt;hwnd, bitmap, dWM_SIT_DISPLAYFRAME);<br></code></pre></td></tr></table></figure><p>最后一个参数 写死了 <code>dWM_SIT_DISPLAYFRAME</code></p><p>导致强制产生边框，与<code>无边框窗口</code> 产生冲突</p><p>而且还不提供接口修改参数</p><p><code>Qt</code>程序员也太不走心了吧</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>那咋办</p><p>其实哈，与<code>Windows API</code>打交道是很烦人的一件事</p><p>所以，能少写就少写，尽量用<code>Qt</code>封装的类</p><p>だから、我们将采用<code>Qt API</code>与<code>Windows API</code>结合的方式 完成缩略图</p><p>毕竟 就只有<code>setIconicThumbnailPixmap</code>这一个函数写得不好嘛</p><p>我们只要用<code>DwmSetIconicThumbnail</code>代替它即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">HBITMAP hbm = QtWin::<span class="hljs-built_in">toHBITMAP</span>(pixmap.<span class="hljs-built_in">scaled</span>(maxSize, Qt::KeepAspectRatio, Qt::SmoothTransformation));<br><span class="hljs-keyword">if</span> (hbm) &#123;<br>    HRESULT hr = <span class="hljs-built_in">DwmSetIconicThumbnail</span>((HWND)<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">winId</span>(), hbm, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">DeleteObject</span>(hbm);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="困难总比办法多"><a href="#困难总比办法多" class="headerlink" title="困难总比办法多"></a>困难总比办法多</h2><p>即可？什么<code>TM</code>的叫<code>TM</code>的即可</p><p>想在<code>Qt</code>中使用这样一个冷门的<code>Windows API</code>可不容易</p><h3 id="头文件：dwmapi-h"><a href="#头文件：dwmapi-h" class="headerlink" title="+头文件：dwmapi.h"></a>+头文件：<code>dwmapi.h</code></h3><blockquote><p>Error：undefined function 缺少定义</p></blockquote><p>What，不是加了头文件吗，一看，由于 <code>_WIN32_WINNT</code> 数值过低（版本不足）,导致定义屏蔽</p><h3 id="头文件中覆盖宏定义："><a href="#头文件中覆盖宏定义：" class="headerlink" title="头文件中覆盖宏定义："></a>头文件中覆盖宏定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WINVER 0x0A00</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _WIN32_WINNT 0x0A00 <span class="hljs-comment">//Win10</span></span><br></code></pre></td></tr></table></figure><blockquote><p>Error：undefined reference 缺少引用（需要链接库）</p></blockquote><h3 id="pro：LIBS-lDwmapi-lGdi32"><a href="#pro：LIBS-lDwmapi-lGdi32" class="headerlink" title="+.pro：LIBS += -lDwmapi -lGdi32"></a>+.pro：<code>LIBS += -lDwmapi -lGdi32</code></h3><p>这就完了？Nonono</p><p>缩略图大小是有限制的，<code>Windows</code>不会自动帮你缩放</p><p>那么如何知道大小限制</p><p>答：在<code>Windows</code>传递的native Message中有</p><p>但是很可惜 我们用了<code>QWinThumbnailToolBar</code>，导致事件被拦截，我们无法获取</p><p><strong>焯</strong></p><p>什么叫寄人篱下</p><p><strong>寄</strong></p><p>这时候就只能想点偷鸡摸狗的办法了</p><p><code>DwmSetIconicThumbnail</code>函数的返回值可以标识调用是否成功</p><p>图片过大则不成功</p><p><code>Size</code>从大到小开始遍历，直到返回<code>S_OK</code></p><h2 id="我滴任务，完成啦！啊哈哈哈哈"><a href="#我滴任务，完成啦！啊哈哈哈哈" class="headerlink" title="我滴任务，完成啦！啊哈哈哈哈"></a>我滴任务，完成啦！啊哈哈哈哈</h2><p><img src="/img/image-20211223163614109.png" alt="成品"></p><h2 id="TNND-跟我玩阴的是吧"><a href="#TNND-跟我玩阴的是吧" class="headerlink" title="TNND 跟我玩阴的是吧"></a>TNND 跟我玩阴的是吧</h2><p>遍历Size会导致耗时过长，导致缩略图刷新不及时，显示为空白（需要鼠标移动刷新）</p><p><strong>焯</strong></p><p>根源还是在于获取不到<code>maxSize</code>（<code>Qt</code>类获取<code>NativeEvent</code>后<code>return true</code> 拦截消息 不再传递）</p><p>所以还是得想办法以高优先级 获取<code>NativeEvent</code></p><h2 id="直接来吧"><a href="#直接来吧" class="headerlink" title="直接来吧"></a>直接来吧</h2><p>参考<code>Qt</code>源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">QCoreApplication::<span class="hljs-built_in">instance</span>()-&gt;<span class="hljs-built_in">installNativeEventFilter</span>(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>要想以高优先级获取<code>NativeEvent</code>必须<code>installNativeEventFilter</code>并且重载<code>nativeEventFilter</code>函数</p><p>但要想重载这个函数，就必须实现<code>QAbstractNativeEventFilter</code>接口</p><p>在<code>C++</code>中，采用多继承实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> : <span class="hljs-keyword">public</span> QWidget, <span class="hljs-keyword">public</span> QAbstractNativeEventFilter<br></code></pre></td></tr></table></figure><p>关于<code>installNativeEventFilter</code></p><blockquote><p>If multiple event filters are installed, the filter that was installed last is activated first.</p><p>也就是如果多个filter被安装，则后安装的先激活</p></blockquote><p>我们要与<code>QWinThumbnailBar</code>竞争所以必须在其之后安装，也就是在它构造之后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">QWinThumbnailToolBar* thumbbar = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QWinThumbnailToolBar</span>(<span class="hljs-keyword">this</span>);<br>qApp-&gt;<span class="hljs-built_in">installNativeEventFilter</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//后安装filter的先获取nativeEvent 所以在↑构造之后</span><br></code></pre></td></tr></table></figure><p>这样，在<code>nativeEventFilter</code>中就可以接收到请求缩略图和实时预览图的消息了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Widget::nativeEventFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> QByteArray&amp; eventType, <span class="hljs-type">void</span>* message, <span class="hljs-type">long</span>* result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> MSG* msg = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> MSG*&gt;(message);<br>    <span class="hljs-keyword">switch</span> (msg-&gt;message) &#123;<br>    <span class="hljs-keyword">case</span> WM_DWMSENDICONICTHUMBNAIL: &#123;<br>        <span class="hljs-function"><span class="hljs-type">const</span> QSize <span class="hljs-title">maxSize</span><span class="hljs-params">(HIWORD(msg-&gt;lParam), LOWORD(msg-&gt;lParam))</span></span>;<span class="hljs-comment">//获取最大Size</span><br>        <span class="hljs-built_in">setThumbnailPixmap</span>(pixmap, maxSize);<br>   &#125;<br>    <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> WM_DWMSENDICONICLIVEPREVIEWBITMAP:<br>        <span class="hljs-built_in">setLivePreviewPixmap</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">grab</span>());<span class="hljs-comment">//实时预览图 没有大小限制 直接截图</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原本的信号连接就可以删了，但是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">thumbbar-&gt;<span class="hljs-built_in">setIconicPixmapNotificationsEnabled</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//进行一些属性设置，否则不能设置缩略图</span><br></code></pre></td></tr></table></figure><p>这句话还是得留着的↑</p><h2 id="我滴任务-又完成啦-啊哈哈哈哈"><a href="#我滴任务-又完成啦-啊哈哈哈哈" class="headerlink" title="我滴任务 又完成啦 啊哈哈哈哈"></a>我滴任务 又完成啦 啊哈哈哈哈</h2><hr><h2 id="ちょっと待って-2022-1-30"><a href="#ちょっと待って-2022-1-30" class="headerlink" title="ちょっと待って(2022.1.30)"></a>ちょっと待って(2022.1.30)</h2><p>既然是对类的修正 就应该封装为类</p><p>重点就是：</p><ul><li>继承<code>QAbstractNativeEventFilter</code></li><li>安装过滤器 <code>QCoreApplication::instance()-&gt;installNativeEventFilter(this);</code></li><li>重载<code>nativeEventFilter</code>并捕获<code>WM_DWMSENDICONICTHUMBNAIL</code>消息</li><li>重写<code>setIconicThumbnailPixmap</code>，采用<code>Windows API(DwmSetIconicThumbnail)</code></li></ul><p>注：删去对<code>WM_DWMSENDICONICLIVEPREVIEWBITMAP</code>的捕获，没必要，直接用原生的即可</p><h2 id="附：Qt源码"><a href="#附：Qt源码" class="headerlink" title="附：Qt源码"></a>附：Qt源码</h2><p><a href="https://code.woboq.org/qt5/qtwinextras/src/winextras/qwinthumbnailtoolbar.cpp.html">https://code.woboq.org/qt5/qtwinextras/src/winextras/qwinthumbnailtoolbar.cpp.html</a></p><h2 id="附：QtWinThumbnailToolBar原理浅析-Qt源码"><a href="#附：QtWinThumbnailToolBar原理浅析-Qt源码" class="headerlink" title="附：QtWinThumbnailToolBar原理浅析(Qt源码)"></a>附：QtWinThumbnailToolBar原理浅析(Qt源码)</h2><p><code>Native</code>事件交给单独的<code>QWinThumbnailToolBarPrivate</code>类(继承自<code>QAbstractNativeEventFilter</code>)处理，本体持有其指针</p><p>接收到<code>Native</code>事件后，开始更新缩略图（如果用<code>setIconicThumbnailPixmap</code>设置过的话）</p><p>并<code>emit iconicThumbnailPixmapRequested</code>供用户更新缩略图</p><p>如果要调用<code>Windows API</code>手动设置缩略图 就不能调用<code>setIconicThumbnailPixmap</code>否则会被覆盖</p><p><code>setIconicLivePreviewPixmap</code>不进行实际更新</p><p>实际更新在<code>Native Event</code>时<code>updateIconicLivePreview()</code></p><p>所以我们在接收事件时必须往下传递，不能<code>return true</code>，否则没有代码去实现<code>LivePreview</code>了</p><p># 其实根本没有必要重写与拦截<code>LivePreview</code>事件，用原生的就行</p><p># 重写<code>Thumbail</code>就行</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/shell/taskbar-extensions?redirectedfrom=MSDN">任务栏扩展 - Win32 apps | Microsoft Docs</a></p><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/dwmapi/nf-dwmapi-dwmseticonicthumbnail">DwmSetIconicThumbnail 函数 (dwmapi.h) - Win32 应用 | 微软文档</a></p><p><a href="https://docs.microsoft.com/en-us/cpp/porting/modifying-winver-and-win32-winnt?view=msvc-170">Update WINVER and _WIN32_WINNT | Microsoft Docs</a></p><p><a href="https://www.cnblogs.com/163yun/p/9711867.html">一个体验好的Windows 任务栏缩略图开发心得 - 网易数帆 - 博客园</a></p><p><a href="https://cpp.hotexamples.com/examples/-/-/DwmSetIconicThumbnail/cpp-dwmseticonicthumbnail-function-examples.html">C++ (Cpp) DwmSetIconicThumbnail Examples - HotExamples</a></p><p><a href="https://code.woboq.org/qt5/qtwinextras/src/winextras/qwinthumbnailtoolbar.cpp.html#_ZN27QWinThumbnailToolBarPrivate21updateIconicThumbnailEPKi">qwinthumbnailtoolbar.cpp source code [qtwinextras&#x2F;src&#x2F;winextras&#x2F;qwinthumbnailtoolbar.cpp] - Woboq Code Browser</a></p><p><a href="https://www.coder.work/article/1239944">c++ - Qt::nativeEvent 调用 - IT工具网</a></p><p><a href="https://blog.csdn.net/nicai_xiaoqinxi/article/details/95251380">使用Qt接口获取Windows系统的事件_Qt君-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_34179968/article/details/86336424?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant">qt捕获全局windows消息_weixin_34179968的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinPcap in Qt - _snprintf等函数冲突定义问题</title>
    <link href="/2021/11/30/WinPcap-in-Qt-_snprintf%E7%AD%89%E5%87%BD%E6%95%B0%E5%86%B2%E7%AA%81%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/30/WinPcap-in-Qt-_snprintf%E7%AD%89%E5%87%BD%E6%95%B0%E5%86%B2%E7%AA%81%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，在<code>Windows</code>中访问底层网络需要用到<code>WinPcap</code>这个工具</p><p>比如，<code>Wireshark</code>（网络封包分析软件）就用到了<code>WinPcap</code></p><p>那么，如何在<code>Qt</code>平台中使用<code>WinPcap</code>呢？</p><h3 id="安装-WinPcap-for-Qt"><a href="#安装-WinPcap-for-Qt" class="headerlink" title="安装 WinPcap for Qt"></a>安装 WinPcap for Qt</h3><p>众所周知，<code>C++</code>想要使用库，就必须提供<code>.h .lib .dll</code>等文件，那么只要下载对应文件即可</p><p><a href="http://www.winpcap.org/">WinPcap官网</a></p><blockquote><p>1.<a href="http://www.winpcap.org/install/default.htm">首先下载安装winpcap.exe</a></p><p>目的是安装相关驱动和dll，安装完成之后基于winpcap的应用程序才能够正常运行</p></blockquote><blockquote><p>2.<a href="http://www.winpcap.org/devel.htm">下载winpcap的开发包，头问文件和库文件</a> </p><p>解压即可得到 Include &amp; Lib 文件夹</p></blockquote><p>From <a href="https://www.cnblogs.com/sunniflyer/p/3983909.html">windows下安装配置winpcap - sunnycs - 博客园</a></p><p>接下来，我们需要在<code>Qt</code>中引用这些文件(假设解压目录：<code>E:\WpdPack</code>)</p><p>在<code>.pro</code>文件中添加：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">INCLUDEPATH += E:/WpdPack/Include<br>LIBS += E:/WpdPack/Lib/x64/wpcap.lib \<br>        E:/WpdPack/Lib/x64/Packet.lib <span class="hljs-comment">#假设是x64程序 若为x86程序 观察Lib目录下的文件</span><br></code></pre></td></tr></table></figure><p>用以引入头文件和库文件路径</p><p>然后在<code>mainwindow.h</code>文件中引入头文件<code>&quot;pcap.h&quot;</code>以测试是否成功安装</p><h2 id="正文：Error"><a href="#正文：Error" class="headerlink" title="正文：Error"></a>正文：Error</h2><p>果不其然，琳琅满目的30个报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">E:\Qt5<span class="hljs-number">.14</span><span class="hljs-number">.2</span>\Tools\mingw730_64\x86_64-w64-mingw32\include\stdio.h:<span class="hljs-number">735</span>: <br>error: conflicting declaration of <span class="hljs-string">&#x27;int _snprintf(char*, size_t, const char*, ...)&#x27;</span> with <span class="hljs-string">&#x27;C&#x27;</span> linkage<br>   _CRTIMP <span class="hljs-type">int</span> __cdecl _snprintf(<span class="hljs-type">char</span> * __restrict__ _Dest,<span class="hljs-type">size_t</span> _Count,<span class="hljs-type">const</span> <span class="hljs-type">char</span> * __restrict__ _Format,...) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;<br>                       ^~~~~~~~~<br></code></pre></td></tr></table></figure><p>不过仔细观察</p><p>错误多为：<strong>conflicting declaration</strong> （定义冲突）&amp; <strong>has not been declared</strong> （未声明）</p><p>且翻来覆去就那几个函数：<strong>_snprintf()</strong>   <strong>_vsnprintf()</strong></p><p>而且而且，貌似都跟 <strong>stdio.h</strong> 有关</p><h2 id="列文虎克"><a href="#列文虎克" class="headerlink" title="列文虎克"></a>列文虎克</h2><p>等一下，我们引入的是 <code>pcap.h</code> 头文件，为什么会引发标准库错误</p><blockquote><p>まさか、真実はいつも一つ</p></blockquote><p>让我们进入 <code>pcap.h</code> の <code>pcap/pcap.h</code> の <code>pcap-stdinc.h</code></p><p>发现了令人震惊的一幕：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> _MSC_VER &lt; 1500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> snprintf _snprintf</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vsnprintf _vsnprintf</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> strdup _strdup</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这个头文件 居然对 <code>snprintf</code> &amp; <code>vsnprintf</code> 函数进行了<code>#define</code> 替换</p><p>众所周知，<code>#define</code> 的作用域是<strong>该语句到文件尾</strong></p><p>好巧不巧，该语句后正好有 <code>#include&lt;stdio.h&gt;</code></p><p>而 <code>stdio.h</code> 中又同时定义了 <code>snprintf</code> <code>_snprintf</code> &amp; <code>vsnprintf</code> <code>_vsnprintf</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vsnprintf</span> <span class="hljs-params">(<span class="hljs-type">char</span> * __restrict__ __stream, <span class="hljs-type">size_t</span> __n, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * __restrict__ __format, va_list __local_argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> __ms_vsnprintf (__stream, __n, __format, __local_argv);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">snprintf</span> <span class="hljs-params">(<span class="hljs-type">char</span> * __restrict__ __stream, <span class="hljs-type">size_t</span> __n, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * __restrict__ __format, ...)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> __retval;<br>  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );<br>  __retval = __ms_vsnprintf (__stream, __n, __format, __local_argv);<br>  __builtin_va_end( __local_argv );<br>  <span class="hljs-keyword">return</span> __retval;<br>&#125;<br><br>__attribute__((__format__ (ms_printf, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))) __MINGW_ATTRIB_NONNULL(<span class="hljs-number">3</span>)<br>  _CRTIMP <span class="hljs-type">int</span> __cdecl _snprintf(<span class="hljs-type">char</span> * __restrict__ _Dest,<span class="hljs-type">size_t</span> _Count,<span class="hljs-type">const</span> <span class="hljs-type">char</span> * __restrict__ _Format,...) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;<br>  __attribute__((__format__ (ms_printf, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>))) __MINGW_ATTRIB_NONNULL(<span class="hljs-number">3</span>)<br>  _CRTIMP <span class="hljs-type">int</span> __cdecl _vsnprintf(<span class="hljs-type">char</span> * __restrict__ _Dest,<span class="hljs-type">size_t</span> _Count,<span class="hljs-type">const</span> <span class="hljs-type">char</span> * __restrict__ _Format,va_list _Args) __MINGW_ATTRIB_DEPRECATED_SEC_WARN;<br></code></pre></td></tr></table></figure><p>导致 <code>snprintf</code> <code>vsnprintf</code> 被替换为 _ 下划线版本 导致重定义</p><p>同时导致&lt;<code>QMainWindow</code>&gt;中引用了 <code>stdio.h</code> 的标准库文件 都出现了<code>snprintf</code> <code>vsnprintf</code> 未定义问题</p><h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><p>既然 <code>#define</code> 的作用域是垂直向下的，那么只要把 <code>stdio.h</code> 从其下方排除即可</p><p>为了最大限度避免修改头文件</p><p>我们需要用到另一个性质：</p><p>头文件一半为了防止重复包含，一般会写上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STH_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STH_H</span><br>...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>所以头文件不会二次引用</p><p>也就是说，只要在 那个罪恶的 <code>#define</code> <strong>之前</strong> 写下 <code>#include&lt;stdio.h&gt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pcap.h&quot;</span> </span><br></code></pre></td></tr></table></figure><p>这样 <code>pcap.h</code> 中的 <code>#include &lt;stdio.h&gt;</code> 就不会生效 也不会产生替换了</p><p>而其他位置的<code>snprintf</code> <code>vsnprintf</code> 替换并无大碍（我猜的），因为都有定义</p><p>或者</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QMainWindow&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pcap.h&quot;</span> <span class="hljs-comment">//或者让&lt;QMainWindow&gt;(里面可能包含stdio)置于pacp.h前面，阻止对stdio.h中某些函数的重定义</span></span><br></code></pre></td></tr></table></figure><p>peace</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://blog.csdn.net/houqd2012/article/details/8028538">使用Winpcap示例程序的时候，会出现很多错误（转）_天道酬勤-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
      <category>WinPcap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
      <tag>WinPcap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性-R原生字符串</title>
    <link href="/2021/11/29/C++11%E6%96%B0%E7%89%B9%E6%80%A7-R%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/11/29/C++11%E6%96%B0%E7%89%B9%E6%80%A7-R%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>C++</code>字符串中有些字符具有特殊含义，需要转义（如<code>&#39;\\&#39; &#39;\&quot;&#39;</code>)</p><p>特别是在表示<code>Windows</code>路径时，极其麻烦（<code>&#39;\\&#39;</code>含量超标）</p><p>那么有什么办法可以告诉编译器取消转义呢？</p><h2 id="最懂我"><a href="#最懂我" class="headerlink" title="最懂我"></a>最懂我</h2><p>没错，原生字符串<code>(Raw string literal)</code>现已加入<code>C++11</code>豪华午餐</p><p>只需要使用<code>R</code>前缀，即可取消转义</p><h2 id="专业释义"><a href="#专业释义" class="headerlink" title="专业释义"></a>专业释义</h2><blockquote><p>prefix(optional) <strong>R”</strong><em>d-char-sequence</em>(optional)<strong>(</strong><em><strong>r-char-sequence</strong></em>(optional)<strong>)</strong> <em>d-char-sequence</em>(optional)<strong>“</strong>      <em>since C++11</em></p></blockquote><blockquote><p>Raw string literal. Used to avoid escaping of any character. Anything between the delimiters becomes part of the string. <em>prefix</em>, if present, has the same meaning as described above. The terminating <em>d-char-sequence</em> is the same sequence of characters as the initial <em>d-char-sequence</em>.</p></blockquote><p>From <a href="https://en.cppreference.com/w/cpp/language/string_literal">String literal - cppreference.com</a></p><h2 id="本地翻译"><a href="#本地翻译" class="headerlink" title="本地翻译"></a>本地翻译</h2><p>什么意思呢</p><p>就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">R&quot;(原始字符串)&quot;</span> == <span class="hljs-string">&quot;转义的字符串&quot;</span><br></code></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">string str1 = <span class="hljs-string">&quot;E:\\test.jpg&quot;</span>;<br>string str2 = <span class="hljs-string">R&quot;sth(E:\test.jpg)sth&quot;</span>;<span class="hljs-comment">//sth在括号前后 用来描述字符串（可选）</span><br><span class="hljs-comment">//输出: E:\test.jpg</span><br></code></pre></td></tr></table></figure><p>也就是<code>()</code>内的字符串原样输出（包括换行、空白字符），不进行转义，所见即所得</p><p>妈妈再也不用担心我的<code>Windows</code>路径</p><h2 id="ちょっと"><a href="#ちょっと" class="headerlink" title="ちょっと"></a>ちょっと</h2><p>等下 忘记吐槽了</p><p><code>C++11</code> 这都2021年了 10年了 算个卵新特性</p><p>这叫旧特性 焯</p><p>peace</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串，新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt配置应用程序图标</title>
    <link href="/2021/11/20/Qt%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87/"/>
    <url>/2021/11/20/Qt%E9%85%8D%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>应用程序图标是软件的标识符，就像品牌符号一样重要</p><p>程序可以摆，图标不能烂</p><p>那么，如何在<code>Qt</code>中给程序上图标呢？</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>俗话说得好：</p><blockquote><p>不会美工的程序员不是好项目经理</p></blockquote><p>图标设计明明是美工的活，凭什么要我程序员干！</p><p>醒醒，你没有美工，你一个人即是一支军队</p><h2 id="真·正文"><a href="#真·正文" class="headerlink" title="真·正文"></a>真·正文</h2><p>那么怎么从无到有上图标呢（twice）</p><p>首先，我们得现有图标</p><h3 id="1-图标を手に入れる"><a href="#1-图标を手に入れる" class="headerlink" title="1.图标を手に入れる"></a>1.图标を手に入れる</h3><p>别想了，你就两条路</p><ul><li>自己画</li><li>自己找</li><li>摆烂</li></ul><p>要么自己动手丰衣足食，要么上资源网碰碰运气<br><a href="https://icon.52112.com/">https://icon.52112.com/</a></p><p><a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">iconfont-阿里巴巴矢量图标库</a></p><h3 id="2-转换格式"><a href="#2-转换格式" class="headerlink" title="2.转换格式"></a>2.转换格式</h3><p><code>PS</code>不能编辑<code>ICO</code>格式还是挺烦的</p><p>其实<code>ICO</code>格式并不是简简单单的一张图片</p><p>为了适应不同的场景（详细信息、小图标、大图标、缩略图），通常一个<code>ICO</code>文件里包含了多种不同分辨率的图片</p><p>为了将普通图片快捷地转换成多尺寸<code>ICO</code>格式，我们需要<code>Internet</code></p><p><a href="https://icoconvert.com/"><del>ICO Convert - Create Icons From PNG &amp; JPG Images Online</del></a></p><p><a href="https://www.aconvert.com/cn/icon/png-to-ico/">PNG转ICO - 在线转换图标文件 (aconvert.com)</a></p><h3 id="3-设置图标-in-Qt"><a href="#3-设置图标-in-Qt" class="headerlink" title="3.设置图标 in Qt"></a>3.设置图标 in Qt</h3><p>终于到了重点了啊，不过磨刀不误砍柴功嘛</p><p>有两种方式：</p><h4 id="其一"><a href="#其一" class="headerlink" title="其一"></a>其一</h4><p>在<code>.pro</code>文件中添加图标文件，然后重新编译即可</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">RC_ICONS = logo.ico <span class="hljs-comment">#相对路径</span><br></code></pre></td></tr></table></figure><h4 id="其二"><a href="#其二" class="headerlink" title="其二"></a>其二</h4><p>1.在项目文件夹中新建<code>logo.rc</code>文件，并写入</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">IDI_ICON1 ICON <span class="hljs-keyword">DISCARDABLE </span><span class="hljs-string">&quot;logo.ico&quot;</span><br></code></pre></td></tr></table></figure><p>2.在<code>.pro</code>文件里添加</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">RC_FILE = logo.rc<br></code></pre></td></tr></table></figure><p>重新编译即可</p><p>你学废了吗？</p><p>peace</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优秀博客转载</title>
    <link href="/2021/10/20/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E8%BD%AC%E8%BD%BD/"/>
    <url>/2021/10/20/%E4%BC%98%E7%A7%80%E5%8D%9A%E5%AE%A2%E8%BD%AC%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p><a href="https://zhuanlan.zhihu.com/p/370927844">高效Qt开发-快速加载本地图片并缩放显示的技巧 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/348164011">高效Qt开发-界面异步刷新技巧 - 知乎</a></p><p><a href="https://forum.qt.io/topic/3477/render-qgraphicseffect-into-pixmap">Render QGraphicsEffect into pixmap? | Qt Forum</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt自定义标题栏-移动窗口</title>
    <link href="/2021/10/09/Qt%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98%E6%A0%8F-%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2021/10/09/Qt%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98%E6%A0%8F-%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，一个最简单的窗口也是有标题栏的</p><p><code>Windows</code>默认提供的标题栏上有：</p><p>​<code>图标-窗口标题-Min-Max-Close按钮</code></p><p>但是，这未免太过局限</p><p>高自由度的自定义是极客<code>(Geek)</code>精神不可或缺的一部分</p><p>如果你想在标题栏上增加&#x2F;减少控件，或改变布局、颜色、Size</p><p>就必须抛弃<code>Windows</code>提供的嗟来之食</p><blockquote><p>蹴尔而与之，乞人不屑也</p></blockquote><h2 id="じゃあ、どうする"><a href="#じゃあ、どうする" class="headerlink" title="じゃあ、どうする"></a>じゃあ、どうする</h2><p>使用无边框窗口即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">setWindowFlags</span>(Qt::FramelessWindowHint);<span class="hljs-comment">//Qt</span><br></code></pre></td></tr></table></figure><p>这样就可以去除默认的标题栏，取而代之的便是光秃秃的客户区</p><p>你问我接下来怎么办？</p><p>那自然是自己写一个标题栏，当然这不是重点</p><p>只是你很快就会发现：<strong>根本没法移动窗口</strong></p><p>それは決まってんだろう（那可不废话）</p><p><code>衣来伸手饭来张口，吃久了五斗米都不知道怎么下地了</code></p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>前摇巨长，现在进入正题，重点讲讲如何移动窗口</p><p>有两种方式：</p><ul><li>监测鼠标动作</li><li>响应<code>Windows</code>消息，伪造标题栏</li></ul><h3 id="手动模拟"><a href="#手动模拟" class="headerlink" title="手动模拟"></a>手动模拟</h3><p>第一种最直观，平时移动窗口的方式不就是：</p><p>​<strong>在鼠标在标题栏按下左键并移动 就可以带着窗口一起飞嘛</strong></p><p>那只要手动检测鼠标状态 并移动窗口即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::mousePressEvent</span><span class="hljs-params">(QMouseEvent* event)</span><span class="hljs-comment">//鼠标按下</span></span><br><span class="hljs-function"></span>&#123;<br>    curPos = event-&gt;<span class="hljs-built_in">screenPos</span>().<span class="hljs-built_in">toPoint</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::mouseMoveEvent</span><span class="hljs-params">(QMouseEvent* event)</span><span class="hljs-comment">//鼠标按着并移动</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!(event-&gt;<span class="hljs-built_in">buttons</span>() &amp; Qt::LeftButton)) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//左键按下</span><br>    QPoint mousePos = event-&gt;<span class="hljs-built_in">screenPos</span>().<span class="hljs-built_in">toPoint</span>();<br>    QPoint newPos = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pos</span>() + mousePos - curPos;<br>    curPos = mousePos;<br>    <span class="hljs-built_in">move</span>(newPos);<br>&#125;<br></code></pre></td></tr></table></figure><p>每次鼠标移动都会触发<code>Move</code>消息，只要计算与上次移动的差值并同步移动窗口，即可</p><p>这里要注意几个细节：</p><ul><li><p>最好用函数自带的参数<code>event</code>，因为<code>QCursor::pos()</code>更新相对滞后</p></li><li><p>最好用鼠标的全局坐标<code>event-&gt;screenPos()</code>，而不是相对窗口坐标<code>event-&gt;pos()</code>，因为后者在鼠标快速移动的情况下可能越界导致<code>Bomb</code>爆炸，窗口鬼畜</p></li></ul><h3 id="伪造消息"><a href="#伪造消息" class="headerlink" title="伪造消息"></a>伪造消息</h3><p>第二种，欺骗<code>Windows</code>，假装自定义标题栏就是原来的标题栏</p><p>响应<code>Windows</code>消息即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Widget::nativeEvent</span><span class="hljs-params">(<span class="hljs-type">const</span> QByteArray&amp; eventType, <span class="hljs-type">void</span>* message, <span class="hljs-type">long</span>* result)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Q_UNUSED</span>(eventType);<br>    MSG* msg = (MSG*)message;<br>    <span class="hljs-keyword">switch</span> (msg-&gt;message) &#123;<br>    <span class="hljs-keyword">case</span> WM_NCHITTEST:<span class="hljs-comment">//鼠标移动消息</span><br>        <span class="hljs-type">int</span> xPos = <span class="hljs-built_in">GET_X_LPARAM</span>(msg-&gt;lParam) - <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">frameGeometry</span>().<span class="hljs-built_in">x</span>();<span class="hljs-comment">//解析鼠标相对坐标</span><br>        <span class="hljs-type">int</span> yPos = <span class="hljs-built_in">GET_Y_LPARAM</span>(msg-&gt;lParam) - <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">frameGeometry</span>().<span class="hljs-built_in">y</span>();<br>        <span class="hljs-keyword">if</span> (ui-&gt;label_title-&gt;<span class="hljs-built_in">geometry</span>().<span class="hljs-built_in">contains</span>(xPos, yPos)) <span class="hljs-comment">//标题栏(伪)</span><br>            *result = HTCAPTION;<span class="hljs-comment">//POINT重点语句，通过result指针返回--------------------------------&lt;-</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//其他部分不做处理，返回false，留给其他事件处理器处理</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//此处返回false，留给其他事件处理器处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>result</code>指针，将结果返回给<code>Windows</code>，假装是<code>标题栏(CAPTION)</code></p><p>Peace</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++在继承模板时无法访问父类成员问题</title>
    <link href="/2021/09/23/C++%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%A8%A1%E6%9D%BF%E6%97%B6%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/23/C++%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%A8%A1%E6%9D%BF%E6%97%B6%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="单刀直入"><a href="#单刀直入" class="headerlink" title="单刀直入"></a>单刀直入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123; <br>    <span class="hljs-type">int</span> x; <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> : B&lt;T&gt; &#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; x = <span class="hljs-number">0</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这种情况下，编译器会报错</p><p><code>foo()</code>内的<code>x</code>标识符无法被找到</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>C++</code>的模板中的名称会进行两次查找，称为两阶段查找（two-phase lookup）。</p><p>对于一个<code>非依赖型名称</code>（不以任何方式依赖于模板参数的名称），在模板声明进行解析的时候就会进行查找</p><p>但<code>C++</code>标准中规定（14.6.2 3），一个非受限的名称查找的时候将不会考虑依赖型的基类</p><p>而<code>x</code>是一个<code>非依赖型名称</code>，在第一阶段现场查找（此时模板父类未实例化），不会搜索父类scope</p><p>导致找不到<code>x</code>标识符</p><h2 id="进两步分析"><a href="#进两步分析" class="headerlink" title="进两步分析"></a>进两步分析</h2><p>但是在第二阶段，等模板实例化了，就能够查找父类scope，此时就能找到<code>x</code></p><p>那只要想办法将其延迟到第二阶段即可</p><p>也就是将其变成<code>依赖型名称</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>有两种办法：</p><p><code>this-&gt;x</code>(因为<code>this</code>代表实例指针)</p><p><code>Base&lt;T&gt;::x</code>(明确指出搜索父类模板)</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/sb985/article/details/79670881?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">c++模板类在继承中子类无法访问父类的成员_小源的博客-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/28139230">如何理解 模板类继承模板类， 子类看不到父类成员？ - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>继承</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windeployqt发布项目 为何总是缺少dll</title>
    <link href="/2021/09/17/windeployqt%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE-%E4%B8%BA%E4%BD%95%E6%80%BB%E6%98%AF%E7%BC%BA%E5%B0%91dll/"/>
    <url>/2021/09/17/windeployqt%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE-%E4%B8%BA%E4%BD%95%E6%80%BB%E6%98%AF%E7%BC%BA%E5%B0%91dll/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>众所周知，<code>Qt</code>直接编译产生的<code>exe</code>文件很难在其他电脑中运行</p><p>其根源在于<code>Qt</code>采用动态链接，所依赖的函数与类等，封装在<code>dll(动态链接库·Dynamic Link Library)</code>中</p><p>所以，单单复制<code>exe</code>文件，会导致缺失<code>dll依赖库</code>，致使无法正确运行</p><p>知道了问题所在，解决方法也是一目了然，只要将<code>exe</code>同<code>dll依赖库</code>一齐打包即可</p><p>由于手动寻找依赖库极其不便，<code>Qt</code>贴心地提供了部署工具<code>windeployqt</code></p><h2 id="Usage・偽"><a href="#Usage・偽" class="headerlink" title="Usage・偽"></a>Usage・偽</h2><p>[由于<code>windeployqt</code>现已加入<code>Windows</code>豪华环境变量]</p><p>所以只要在<code>CMD</code>中改变(<code>cd·Change Directory</code>)工作目录至<code>exe</code>所在目录</p><p>并执行<code>windeployqt test.exe</code></p><p>便会自动将依赖文件（包括<code>dll</code>和图标等众文件）拷贝至<code>exe</code>所在目录</p><p>此时，打包为压缩包并一齐发布即可</p><h2 id="Pause"><a href="#Pause" class="headerlink" title="Pause"></a>Pause</h2><p>真有这么简单？</p><p>是的，我就是这么干的，然后课上Presentationの時疯狂<code>“缺失dll”</code></p><p>直接社死</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这究竟是人性的扭曲还是道德的沦丧</p><p>这显然是 <code>复制了但没有完全复制</code></p><p>社死的我回到座位上开始找度娘</p><p>度娘的做法和我稍稍、削削有那么一点点 不同</p><p>不是<code>Windows</code>自带<code>CMD</code>而是<code>Qt</code>提供的命令行环境：<code>Qt 5.14.2 (MinGW 7.3.0 64-bit)</code></p><p><img src="/img/Qt%E5%91%BD%E4%BB%A4%E8%A1%8C.jpg" alt="Qt 5.14.2 (MinGW 7.3.0 64-bit)"></p><h2 id="进两步分析"><a href="#进两步分析" class="headerlink" title="进两步分析"></a>进两步分析</h2><p>那莫，这俩究竟有何区别，造成最终拷贝的<code>dll</code>数量不相同呢</p><p>我们先来看看 <code>Qt 5.14.2 (MinGW 7.3.0 64-bit)</code> 究竟是何方神圣</p><p>实际上这玩意儿是个<code>link（快捷方式）</code></p><p><img src="/img/Qt%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B1%9E%E6%80%A7.png" alt="Qt命令行属性"></p><p>注意<code>目标(T)</code>处代码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMD"><span class="hljs-function">C:\<span class="hljs-title">Windows</span>\<span class="hljs-title">System32</span>\<span class="hljs-title">cmd.exe</span> /<span class="hljs-title">A</span> /<span class="hljs-title">Q</span> /<span class="hljs-title">K</span> <span class="hljs-title">E</span>:\<span class="hljs-title">Qt5</span>.14.2\5.14.2\<span class="hljs-title">mingw73_64</span>\<span class="hljs-title">bin</span>\<span class="hljs-title">qtenv2.bat</span></span><br></code></pre></td></tr></table></figure><p>实际上是调用<code>CMD</code>执行了<code>qtenv2.bat</code>（批处理文件）</p><p>那么，猫腻也许就藏在这个<code>bat</code>文件中</p><p>我们来看看其中的内容：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs BAT">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-built_in">echo</span> Setting up environment <span class="hljs-keyword">for</span> Qt usage...<br><span class="hljs-built_in">set</span> <span class="hljs-built_in">PATH</span>=E:\Qt5.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>\<span class="hljs-number">5</span>.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>\mingw73_64\bin;E:/Qt5.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>/Tools/mingw730_64\bin;<span class="hljs-variable">%PATH%</span><br><span class="hljs-built_in">cd</span> /D E:\Qt5.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>\<span class="hljs-number">5</span>.<span class="hljs-number">14</span>.<span class="hljs-number">2</span>\mingw73_64<br></code></pre></td></tr></table></figure><p>其实真正能够造成影响的是第3行的<code>set PATH</code>中的第二个<code>path(E:/Qt5.14.2/Tools/mingw730_64\bin)</code></p><p>因为第一个<code>path</code>其实已经默认加入了环境变量 无伤大雅</p><p>而<code>path(E:/Qt5.14.2/Tools/mingw730_64\bin)</code>中并不在环境变量中，导致一般的<code>CMD</code>方式无法读取其中的<code>dll</code>，导致<code>dll缺失</code></p><h2 id="Last-And-Absolutely-Last"><a href="#Last-And-Absolutely-Last" class="headerlink" title="Last And Absolutely Last"></a>Last And Absolutely Last</h2><p>真相了，就缺这么一个目录，少了一堆<code>dll</code></p><p>下次记得用<code>Qt</code>命令行环境</p><p>哦 对了 如果使用<code>Enigma Virtual Box</code>封包</p><p>记得不要拖入<strong>文件夹</strong>！而是拖入文件(without exe)</p><p>否则【cannot load library Qt5Core.dll】！！</p><p>Peace</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
      <tag>windeployqt</tag>
      
      <tag>CMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt打开指定目录并选中文件</title>
    <link href="/2021/08/26/Qt%E6%89%93%E5%BC%80%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E5%B9%B6%E9%80%89%E4%B8%AD%E6%96%87%E4%BB%B6/"/>
    <url>/2021/08/26/Qt%E6%89%93%E5%BC%80%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E5%B9%B6%E9%80%89%E4%B8%AD%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>有时，为了方便用户查看，我们可能需要提供<code>在资源管理器中打开文件</code>的功能</p><p>比如：Qt(<code>在Explorer中显示</code>)、Chrome(<code>在文件夹中显示</code>)</p><p><img src="/img/Qt-%E5%9C%A8Explorer%E4%B8%AD%E6%98%BE%E7%A4%BA.jpg" alt="Qt-在Explorer中显示"></p><p><img src="/img/Chrome-%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E6%98%BE%E7%A4%BA.jpg" alt="Chrome-在文件夹中显示"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>该功能用于打开一个指定文件夹，并选中指定<code>文件</code></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>打开<code>文件夹</code>本质上和打开<code>文件</code>没什么区别，说白了就是一个<code>URL</code>(Uniform Resource Locator)</p><p>打开<code>URL</code>，我们能想到很多种方法：</p><ul><li><code>Windows API</code>中的<code>ShellExecute()</code>函数</li><li><code>CMD</code> 的 start命令</li><li>Qt自带的<code>QDesktopServices::openUrl(const QUrl &amp;url)</code>静态函数</li><li>and so on…</li></ul><p>打开<code>URL</code>并不是什么难事</p><p>但我们在打开<code>文件夹</code>后还必须选中<code>文件</code></p><p>这一点，一般的函数都做不到</p><h2 id="もっと分析"><a href="#もっと分析" class="headerlink" title="もっと分析"></a>もっと分析</h2><p>究其原因</p><p>我们要明白，<code>资源管理器</code>本质上是一个<code>应用程序</code></p><p>即<code>explorer.exe</code></p><p>我们要对<code>应用程序</code>下手，最好的办法还是通过其自身的参数</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>所谓命令行参数，就是在启动时传递给程序的参数，用以执行不同操作</p><p>比如：传递给图片查看器<code>图片的绝对路径</code></p><p>在<code>C/C++</code>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br></code></pre></td></tr></table></figure><p><code>argv</code>指针数组便是命令行参数</p><p>通过这些参数，程序自身便可以进行判断，获取更多外界信息</p><p>我们可以通过<code>CMD</code>或者拖拽文件传递命令行参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs command">test.exe argument<br></code></pre></td></tr></table></figure><p><em>应用程序路径 + 空格 + 参数即可</em>（参数间用空格分开）</p><h3 id="explorer参数"><a href="#explorer参数" class="headerlink" title="explorer参数"></a>explorer参数</h3><p>明白了这些，我们只需要给<code>explorer</code>传递对应参数即可选中文件</p><p>格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs command">explorer.exe /select, URL<br></code></pre></td></tr></table></figure><h2 id="理论存在-实践开始"><a href="#理论存在-实践开始" class="headerlink" title="理论存在 实践开始"></a>理论存在 实践开始</h2><p>要能非阻塞开启外部程序，并传递参数</p><p>我们大体有两种方法：</p><ul><li><code>ShellExecute()</code></li><li><code>QProcess</code></li></ul><h3 id="ShellExecute-Windows-API"><a href="#ShellExecute-Windows-API" class="headerlink" title="ShellExecute() - Windows API"></a>ShellExecute() - Windows API</h3><p><code>ShellExecute</code>函数原型及参数含义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ShellExecute</span>(<br>hWnd: HWND; <span class="hljs-comment">//&#123;指定父窗口[句柄]&#125;</span><br>Operation: PChar; <span class="hljs-comment">//&#123;指定动作, 譬如: open、runas、print、edit、explore、find&#125;</span><br>FileName: PChar; <span class="hljs-comment">//&#123;指定要打开的文件或程序&#125;</span><br>Parameters: PChar; <span class="hljs-comment">//&#123;给要打开的程序指定参数&#125; &lt;-命令行参数</span><br>Directory: PChar; <span class="hljs-comment">//&#123;缺省目录&#125;</span><br>ShowCmd: Integer <span class="hljs-comment">//&#123;打开选项&#125;</span><br>);<br></code></pre></td></tr></table></figure><p>看起来复杂，但主要就是<code>FileName</code>和<code>Parameters</code>，举个例子便一目了然</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ShellExecute</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;explorer&quot;</span>, <span class="hljs-string">&quot;/select, E:\test.png&quot;</span>, <span class="hljs-literal">NULL</span>, SW_SHOW);<span class="hljs-comment">//打开E:\test.png并选中</span><br></code></pre></td></tr></table></figure><p>但是在实际应用中，我们还是要注意一点</p><p>大多<code>Windows API</code>都分为了两个版本：W版和A版</p><p>也就是<code>ShellExecuteW</code>和<code>ShellExecuteA</code></p><p>区别是W代表宽字符，采用Unicode编码，A代表ASCII编码</p><p>由于<code>文件路径</code>可能出现中文，所以我们采用<code>ShellExecuteW</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ShellExecuteW</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;open&quot;</span>, <span class="hljs-string">L&quot;explorer&quot;</span>, <span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;/select, \&quot;%1\&quot;&quot;</span>).<span class="hljs-built_in">arg</span>(ImagePath).<span class="hljs-built_in">toStdWString</span>().<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">NULL</span>, SW_SHOW);<br></code></pre></td></tr></table></figure><p><code>L&quot;open&quot;</code>前的<code>L</code>代表将<code>&quot;open&quot;</code>转化为宽字符，否则不符合参数类型<code>LPCWSTR</code>(<code>typedef const wchar_t* LPCWSTR;</code>)</p><p>而QString也要相应地转化为宽字符版本</p><p><strong>Perfect</strong></p><h3 id="QProcess-Qt类"><a href="#QProcess-Qt类" class="headerlink" title="QProcess - Qt类"></a>QProcess - Qt类</h3><p>接下来我们看看Qt特有的类-QProcess</p><p>该类可用于完成启动外部程序，并与之交互通信</p><p>但此次我们不需要通信，只要传入参数并非阻塞启动即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">QProcess process;<br>process.<span class="hljs-built_in">startDetached</span>(<span class="hljs-built_in">QString</span>(<span class="hljs-string">&quot;explorer /select,\&quot;%1\&quot;&quot;</span>).<span class="hljs-built_in">arg</span>(ImagePath));<span class="hljs-comment">//启动后分离，即非阻塞</span><br></code></pre></td></tr></table></figure><p>由于是Qt内部的类，所以不需要特殊处理宽字符，因为Qt一律采用Unicode编码</p><p><em>Windows API，你看看人家</em></p><p>Over</p><p>两种方法，掷硬币决定吧</p>]]></content>
    
    
    <categories>
      
      <category>Qt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>艳阳小故事 其一：鬼节买纸</title>
    <link href="/2021/08/22/%E8%89%B3%E9%98%B3%E5%B0%8F%E6%95%85%E4%BA%8B-%E5%85%B6%E4%B8%80%EF%BC%9A%E9%AC%BC%E8%8A%82%E4%B9%B0%E7%BA%B8/"/>
    <url>/2021/08/22/%E8%89%B3%E9%98%B3%E5%B0%8F%E6%95%85%E4%BA%8B-%E5%85%B6%E4%B8%80%EF%BC%9A%E9%AC%BC%E8%8A%82%E4%B9%B0%E7%BA%B8/</url>
    
    <content type="html"><![CDATA[<p>今天是风和日丽、艳阳高照的<code>鬼节</code> </p><p>李小姐要去买<code>纸</code></p><blockquote><p>哈~ 逛了一下午 累死了</p></blockquote><ul><li>卫生纸</li><li>餐巾纸</li><li>卷纸</li></ul><blockquote><p>あああああ　どちらはいいんだよ～　大変だ</p></blockquote><p>出于程序员的直觉，为了防止出现意外</p><p>李小姐决定备一个灭火器</p><blockquote><p>老板，灭火器，一つ　お願い</p></blockquote><blockquote><p><strong>老板：</strong>かしこまりました　ありがとうございました</p></blockquote><p>艳阳掏出成卷的纸，发现没带打火机</p><p>又从后面抽烟的大叔那，借了火</p><blockquote><p>兹 Fire 轰轰轰<br>呲呲呲呲呲呲</p></blockquote><p>烟雾触发了警报器</p><p>全村唯一去过迪厅的花洒，吃了生瓜蛋子般地尽情喷洒</p><p>那一夜，人们似乎不再被疫情的阴霾笼罩</p><p>艳阳之下，人群开始躁动，往日冷清的商场散发出格外耀眼的光芒</p><p>一切，又恢复了曾经的生机与活力</p><p>只是老板他</p><p>却<code>栈溢出</code>了</p><p>进化为了<code>Ghost</code></p><p>老板平日待人和善，成了<code>Ghost</code>，脾气也不坏</p><p>只是</p><p>他嘴里一直念叨着</p><blockquote><p>纸 纸 我的纸</p></blockquote><p>为了纪念老板</p><p>为了找回人们心中那个善良可爱的老板</p><p>大家决定，将每年的这一天定为<code>Ghost Festival</code>，即<code>鬼节</code></p><p>每年的今天，大家都会来到这，通过火焰，将<code>纸</code>与<code>纸上的思念</code>灵体化，传达给老板</p><p>这便是 <code>鬼节</code>的由来</p><hr><p>故事讲完了</p><p>现在我们来讲讲<a href="https://www.bilibili.com/video/BV1DK411n7e1"><code>栈溢出</code></a></p><p>…</p>]]></content>
    
    
    <categories>
      
      <category>小故事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>story</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于通过ShellExecute()启动CMD的环境变量问题</title>
    <link href="/2021/08/21/%E5%85%B3%E4%BA%8E%E9%80%9A%E8%BF%87ShellExecute-%E5%90%AF%E5%8A%A8CMD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/21/%E5%85%B3%E4%BA%8E%E9%80%9A%E8%BF%87ShellExecute-%E5%90%AF%E5%8A%A8CMD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p><code>CMD</code>(命令提示符)是Windows上的命令解释程序</p><p>我们可以快速地在系统菜单中启动<code>CMD</code>，并执行一系列快捷操作</p><p>但作为一个程序员，我们可能经常需要在程序中调用<code>CMD</code>来执行指令以辅助执行任务</p><p>这就涉及到<strong>外部程序调用</strong></p><p>众所周知，我们可以在<code>C/C++</code>中使用<code>system()</code>函数来执行<code>CMD</code>指令</p><p>でもね，<code>system()</code>是阻塞函数，顾名思义，在<code>CMD</code>指令执行完毕之前，程序流都会阻塞在<code>system()</code></p><p>有时候，这并不是我们想要的效果。（比如在执行耗时指令时）</p><h2 id="正片"><a href="#正片" class="headerlink" title="正片"></a>正片</h2><p>此时，就需要非阻塞函数来开启<code>CMD</code>进程</p><p>比如：<a href="https://baike.baidu.com/item/Shellexecute/5788449"><code>ShellExecute()</code></a> <em><a href="https://blog.csdn.net/helinsen/article/details/50464581">注意事项</a></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">ShellExecute</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, SW_SHOW);<br></code></pre></td></tr></table></figure><p>但是，我惊奇地发现，用<code>ShellExecute()</code>开启的<code>CMD</code>与手动开启的<code>CMD</code>有些许不同</p><p>比如：有些<code>环境变量</code>在后者正常使用，却在前者无法被识别</p><p>提示：<em>XXX不是内部或外部命令，也不是可运行的程序或批处理文件</em></p><h2 id="百思"><a href="#百思" class="headerlink" title="百思"></a>百思</h2><p>なんだろうね</p><p>どうしてんだよ</p><p>なぜだだだだだだだだだだだ</p><p>(。´･ω･)?</p><p>为啥呀，明明启动的是同一个exe文件</p><p>难道是工作目录不同？不对，我已经设置了对应的工作目录，而且<code>环境变量</code>无关工作目录</p><p>难道是…</p><h2 id="得"><a href="#得" class="headerlink" title="得"></a>得</h2><p>我还发现一个细节：不是所有的<code>环境变量</code>都不能使用，而是某些…</p><p>欸，某些！</p><p>我遂进入<code>环境变量</code>设置入口查看</p><p><img src="/img/image-20210821181712344.png" alt="环境变量"></p><p>原来<code>环境变量</code>分为两种：<code>用户变量</code>与<code>系统变量</code></p><p><code>用户变量</code>只能被特定用户识别，而<code>系统变量</code>可以为所有用户使用</p><p>而且，那些不能被<code>ShellExecute()</code>启动的<code>CMD</code>识别的环境变量就在<code>用户变量</code>的PATH中</p><h2 id="其解"><a href="#其解" class="headerlink" title="其解"></a>其解</h2><p>破案了</p><p>虽然不知道为什么，但</p><h4 id="ShellExecute-启动的CMD貌似不能识别用户变量"><a href="#ShellExecute-启动的CMD貌似不能识别用户变量" class="headerlink" title="ShellExecute()启动的CMD貌似不能识别用户变量"></a><code>ShellExecute()</code>启动的<code>CMD</code>貌似不能识别<code>用户变量</code></h4><p>遂，将之设为<code>系统变量</code>，重启，solve！</p><h4 id="记得一定要重启哈-lt-解决99-问题"><a href="#记得一定要重启哈-lt-解决99-问题" class="headerlink" title="!!!记得一定要重启哈 &lt;-解决99%问题"></a>!!!记得一定要重启哈 &lt;-解决99%问题</h4>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>CMD</tag>
      
      <tag>环境变量</tag>
      
      <tag>ShellExecute</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
